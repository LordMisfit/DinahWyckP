class DDPlayerPawn : PlayerPawn
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double PlayerDefenseIgnoreFactor;

	mixin HUDRecovery;
	bool IPAttack;
	bool takendrowndmg;
	bool willgasp;
	
	int PoisonDmgPainInt;
	int AirTime, MaxAirTime;
	int InWaterTime;
	
	int ipmodecooldowntimer;
	bool isvoodoodoll;
	int neverbleeds;
	bool recalledall;
	int ipchargesoundtimer;
	double truespeed;
	int armortier;
	int IPLoopTimer;
	int beattimer;
	int beatpulse;
	
	int lasthealth;
	int breathdirection; // 0 = down [size decreases], 1 = up [size increases]
	int breathframe;

	
	int DashTimer; int MaxDashTimer; 
	int cooldash; bool sounddash; 
	int thrudash; bool isdashing;
	double floordashvel, airdashvel, dashjumpstrength;
	double dashvelx, dashvely, dashvelz;

	int dashcooldown;
	int dashcooldownmax;
	
	int deadtimer;
	int fadetime;
	int originalheight;
	int originalradius;
	int originalmass;

	int firsttic;
	int buttons, input;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	mixin IPCostCheck;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;

	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
		RenderStyle "Add";
		Alpha 1.0;
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		bool grunted;

		// [RH] only make noise if alive
		if (self.health > 0 && !self.player.morphTics)
		{
			grunted = false;
			// Why should this number vary by gravity?
			double truegruntspeed = self.player.mo.GruntSpeed;
			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) truegruntspeed *= 1.34;
			//Console.Printf("%.8f (%.8f) [%.8f]", self.Vel.Z, truegruntspeed, self.player.mo.GruntSpeed);
			if (self.Vel.Z < -truegruntspeed)
			{
				A_StartSound("*grunt", CHAN_VOICE);
				grunted = true;
			}
			bool isliquid = (pos.Z <= floorz) && HitFloor();
			if (onmobj != NULL || !isliquid)
			{
				A_StartSound("*land", CHAN_BODY);
			}
		}
	}

	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;

		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}

	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (dydudebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}

		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}

	override bool ResetAirSupply(bool playgasp)
	{
		let player = self.player;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		bool wasdrowning;
		if (AirTime <= 0) 
		{
			wasdrowning = true;
			AirTime = 0;
			if (dydudebug_airmeter) Console.Printf("wasdrowning");
		}
		
		if (AirTime < MaxAirTime)
		{
			double airreplen;
			if (MaxAirTime > 0) 
			airreplen = (MaxAirTime / (TICRATE * 5));
			if (airreplen < 1) airreplen = 1;
			if (MiscItem) airreplen *= (1.0 + (MiscItem.PlayerLevel * 0.0125));
			if (MaxAirTime > 0 && airreplen > (TICRATE / 35)) airreplen = (MaxAirTime / TICRATE);
			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) airreplen *= 1.25;
			if (CountInv("PowerIronFeet") || CountInv("PowerIronFeet2") || CountInv("PowerMask")) airreplen *= 1.625;
			AirTime += airreplen;
			if (dydudebug_airmeter) Console.Printf("airreplen: %d (%d / %d)", airreplen, AirTime, MaxAirTime);
		}
		if (AirTime > MaxAirTime) AirTime = MaxAirTime;

		if (playgasp)
		{
			if (wasdrowning)
			{
				if (takendrowndmg)
				{
					takendrowndmg = false;
					A_StopSound(CHAN_VOICE);
					A_StartSound("dinah/drowngasp1",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
					willgasp = false;
				}
				else
				{
					A_StopSound(CHAN_VOICE);
					if (random(1,9) <= 6) 
					{
						A_StartSound("dinah/drowngasp1",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
						willgasp = false;
					}
				}
			}
			else
			{
				if (willgasp)
				{
					int AirMeterRatio;
					if (MaxAirTime > 0) 
					{
						AirMeterRatio = (AirTime * 100 / MaxAirTime);
						if (AirMeterRatio <= randompick(16,17,17))
						{
							A_StopSound(CHAN_VOICE);
							A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
						}
						else
						if (AirMeterRatio <= randompick(33,33,34))
						{
							A_StopSound(CHAN_VOICE);
							if (random(1,9) <= 8) 
							{
								A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
							}
						}
						else
						if (AirMeterRatio <= randompick(66,67,67))
						{
							A_StopSound(CHAN_VOICE);
							if (random(1,9) <= 4) 
							{
								A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
							}
						}
						else
						if (AirMeterRatio <= randompick(83,83,84))
						{
							A_StopSound(CHAN_VOICE);
							if (random(1,9) <= 1) 
							{
								A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
							}
						}
					}
					willgasp = false;
				}
			}
		}
		return wasdrowning;
	}

	override void CheckAirSupply()
	{
		if (!player || !player.mo || player.mo != self)
		{
			super.CheckAirSupply();
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			MaxAirTime = (12 * TICRATE);
			if (MiscItem)
			{
				MaxAirTime += (MiscItem.PlayerLevel * 2.916666666666667);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxAirTime *= 1.25;
			}
			if (GetAge() <= 1 && AirTime != MaxAirTime) AirTime = MaxAirTime;

			int DrownDmg = 2 + (-AirTime / TICRATE);
			DrownDmg = ceil(DrownDmg * frandompick(0.625,0.75,0.875,1.000));
			if (DrownDmg < 0) DrownDmg = 0;
			if (dydudebug_airmeter) Console.Printf("InWaterTime: %d, WaterLevel: %d, AirTime: %d / %d, DrownDmg: %d, willgasp: %d, takendrowndmg: %d", InWaterTime, waterlevel, AirTime, MaxAirTime, DrownDmg, willgasp, takendrowndmg);
			// Handle air supply	
			//if (level.airsupply > 0)
			{
				let player = self.player;
				if (waterlevel >= 3)
				{
					if (InWaterTime <= 0)
					{
						A_StartSound("misc/enterwater",215,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.8,1.2));
					}
					InWaterTime++;
					
					if (CountInv("PowerIronFeet") || 
							CountInv("PowerIronFeet2") || 
							CountInv("PowerMask"))
					{
						willgasp = false;
					}
					else
					{
						willgasp = true;
					}
				}
				else 
				{
					if (InWaterTime > 0)
					{
						A_StartSound("misc/exitwater",215,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
						if (dydudebug_airmeter) Console.Printf("misc/exitwater");
					}
					InWaterTime = 0;
				}
				
				if (waterlevel < 3 || (bInvulnerable) || 
					(player.cheats & (CF_GODMODE | CF_NOCLIP2)) || (player.cheats & CF_GODMODE2) || 
					CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
				{
					ResetAirSupply(true);
				}
				else
				{
					AirTime--;
					if (AirTime > MaxAirTime) AirTime = MaxAirTime;
					if (AirTime <= 0)
					{
						if (!(level.maptime & 31) && DrownDmg)
						{
							DamageMobj(NULL, NULL, DrownDmg, 'Drowning');
							string drownsnd = "misc/drowning";
							if (health <= 0) drownsnd = "misc/drowninglong";
							if (health > 0)
							{
								if (MiscItem)
								{
									if (MiscItem.drowndebufflevel < 10)
									{
										MiscItem.drowndebufflevel++;
										MiscItem.drowndebufftimer += random(25,35);
									}
								}
							}
							A_StopSound(120);
							A_StartSound(drownsnd,120,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(1.375,1.5));
							takendrowndmg = true;
						}
					}
				}
			}
			int tempAirTime = AirTime;
			if (tempAirTime < 0) tempAirTime = 0;
			int tempMaxAirTime = MaxAirTime;
			if (tempMaxAirTime < 0) tempMaxAirTime = 0;
			A_SetInventory("AirMeter", tempAirTime);
			A_SetInventory("MaxAirMeter", tempMaxAirTime);
		}
	}
	
	override void MovePlayer()
	{
		if (!player || !player.mo || player.mo != self)
		{
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			int PlayerLevel;
			if (MiscItem) PlayerLevel = MiscItem.PlayerLevel;
			double AirControlBase = frandom(0.2432,0.2436);

			// Level Based AirControl
			double LVLAirControl = 1.00 + (PlayerLevel * 0.00125);

			// Armor items
			double ArmorAirControl = 1.00;
			if (CountInv("KnightGownItem"))			ArmorAirControl += 0.0667;
			if (CountInv("KnightGownItem2"))		ArmorAirControl += 0.10;
			if (CountInv("KnightGownItem3"))		ArmorAirControl += 0.1334;
			if (CountInv("KnightGownItem4"))		ArmorAirControl += 0.18;
			if (MiscItem)
			{
				if (MiscItem.WineDefTier == 1 || MiscItem.WineDefTier == -1) ArmorAirControl *= frandom(0.98,1.00);
				if (MiscItem.WineDefTier == 2 || MiscItem.WineDefTier == -2) ArmorAirControl *= frandom(0.96,1.00);
				if (MiscItem.WineDefTier == 3 || MiscItem.WineDefTier == -3) ArmorAirControl *= frandom(0.93,1.00);
				if (MiscItem.WineDefTier == 4 || MiscItem.WineDefTier == -4) ArmorAirControl *= frandom(0.88,1.00);
				if (MiscItem.WineDefTier == 5 || MiscItem.WineDefTier == -5) ArmorAirControl *= frandom(0.81,1.00);
			}

			// Buffs
			double BuffAirControl = 1.00;
			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) BuffAirControl *= 1.334;
			if (CountInv("PowerFruitBuff")) BuffAirControl *= 1.125;
			if (CountInv("PowerRoastBuff")) BuffAirControl *= 1.5;
			if (CountInv("PowerMealBuff")) BuffAirControl *= 2;
			if (CountInv("PowerMeal2Buff")) BuffAirControl *= 2;

			level.aircontrol = AirControlBase
											* LVLAirControl
											* ArmorAirControl
											* BuffAirControl;
			level.airfriction = level.aircontrol * -0.0941 + 1.0004;

			if (dydudebug_playermove)
			{
				Console.Printf("    \czSV_AirControl:\c- \cz%.8f\c-  \cwTotalAirControl:\c- \cw%.8f\c-, \cyAirControlBase:\c- \cy%.8f\c-, LVLAirControl: %.8f, ArmorAirControl: %.8f, BuffAirControl: %.8f", sv_aircontrol, level.aircontrol, AirControlBase, LVLAirControl, ArmorAirControl, BuffAirControl);
				Console.Printf("    \cwTotalFriction:\c- \cw%.8f\c-, \cyLevelAirFriction:\c- \cy%.8f\c-", friction, level.airfriction);
				Console.Printf("    \c[blue]Player.ForwardMove: (%.2f, %.2f), Player.SideMove: (%.2f, %.2f), Player.ViewBob: %.2f", ForwardMove1, ForwardMove2, SideMove1, SideMove2, ViewBob);
			}
		}
		
		super.MovePlayer();
	}
	
	Override void Tick()
	{
		// VOODOO Doll Protection
		if ((!player || !player.mo || player.mo != self)) 
		{
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (dydudebug_showvoodoodoll) Console.Printf("Player [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			let globalvars = DDGlobalVariables.Get();
			if (dydudebug_mapinfo)
			{
				Console.Printf("Player Age [tics]: %d, levelnum: \cx%d\c-, cluster: \cx%d\c-, clusterflags: \cx%d\c-, NextMap: \cy%s\c-, NextSecretMap: \cy%s\c-,\ntime: \cx%d\c-, maptime: \cx%d\c-, totaltime: \cx%d\c-, starttime: \cx%d\c-, partime: \cx%d\c-, sucktime: \cx%d\c-,\nlevelname: \cy%s\c-, mapname: \cy%s\c-, \ngravity: \cx%.8f\c-, aircontrol: \cx%.8f\c-, airfriction: \cx%.8f\c-, \cxTranslation #:\c- %d, \cyMapCheckSum:\cx %s", 
												GetAge(),
												level.levelnum, level.cluster, level.clusterflags, level.NextMap, level.NextSecretMap,
												level.time, level.maptime, level.totaltime, level.starttime, level.partime, level.sucktime,
												level.levelname, level.mapname,
												level.gravity, level.aircontrol, level.airfriction,
												translation, level.GetChecksum());
			}
			
			// Check IP Buttons [general check for quick editing later across all definitions]
			
			if (ipmodecooldowntimer) ipmodecooldowntimer--;
			int IPbuttonspressed = 0;
			if (buttons & BT_USE) IPbuttonspressed++;
			if (buttons & BT_SPEED) IPbuttonspressed++;
			if (exex_ikaripointsenabled)
			{
				if (exex_ikaripointtechpresstype == 0)
				{
					if (IPbuttonspressed >= 2) 
					{
						A_SetInventory("IPUseMode",1);
					}
					else
					{
						A_SetInventory("IPUseMode",0);
					}
				}
				else
				if (exex_ikaripointtechpresstype >= 1 && exex_ikaripointtechpresstype <= 2)
				{
					if (IPbuttonspressed >= 2) 
					{
						if (ipmodecooldowntimer <= 0)
						{
							ipmodecooldowntimer = random(9,12);
							if (CountInv("IPUseMode")) A_SetInventory("IPUseMode",0);
																		else A_SetInventory("IPUseMode",1);
						}
					}
				}
			}
			else
			{
				A_SetInventory("IPUseMode",0);
			}
			
			// The "Charge" sound[s] that plays in a loop while IP mode is active and the one that plays when it disperses [thanks to LilWhiteMouse for the sounds from Wolfen, wherever she herself had found them] :V
			
			double ipmodevol = 1.0;
			double basevollvl = 0.25;
			double ipmodepitch = 1.0;
			if (!CountInv("INTERMAPChecker"))
			{
				if (health > 0)
				{
					if (MiscItem && globalvars && MiscItem.MaxItemPoints)
					{
						ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
						if (MiscItem.IPNoGainTimer) ipmodevol *= 0.001;
					}
					if (dydudebug_ipdisplays) Console.Printf("ipmodevol: %.4f, ipmodepitch: %.4f", ipmodevol, ipmodepitch);
					if (CountInv("IPUseMode"))
					{
						if (ipchargesoundtimer == 0)
						{
							if (MiscItem && globalvars)
							{
								ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
								if (MiscItem.IPNoGainTimer) ipmodevol *= 0.001;
							}
							A_StopSound(255);
							A_StartSound("ipmode/start",255,CHANF_NOSTOP,ipmodevol,ATTN_NORM,ipmodepitch);
						}
						ipchargesoundtimer++;
						if (ipchargesoundtimer >= 56)
						{
							int ipchargesoundtimer2 = ipchargesoundtimer % 56;
							if (ipchargesoundtimer2 == 0) 
							{
								A_StopSound(255);
								A_StartSound("ipmode/loop",255,CHANF_NOSTOP|CHANF_LOOPING,ipmodevol,ATTN_NORM,ipmodepitch);
							}
							if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer2: %d / 55", ipchargesoundtimer2);
						}
					}
					else
					{
						if (ipchargesoundtimer != 0)
						{
							ipchargesoundtimer = 0;
							A_StopSound(255);
							A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
						}
					}
				}
				else
				{
					if (ipchargesoundtimer != 0)
					{
						ipchargesoundtimer = 0;
						A_StopSound(255);
						A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
					}
					MiscItem.ItemPoints = 0;
					globalvars.ItemPoints = 0;
				}
				if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer: %d", ipchargesoundtimer);
			}
			
			// ??????
			double IPLevelGateInc = 1.0;
			if (!CountInv("INTERMAPChecker"))
			{
				if (exex_ikaripointsenabled && CountInv("IPUseMode"))
				{
					if (buttons & BT_ZOOM && CountInv("FistPlayerBlockItem"))
					{
						bool wasnodmgthrust;
						bool wasforceradius;
						if (bNODAMAGETHRUST) wasnodmgthrust = true;
						if (bFORCERADIUSDMG) wasforceradius = true;
						double cost = A_GetIPCost(-1);
						//Console.Printf("TrueIPLevelGate: %d, IP: %d (%d), Level: %d, TrueIPCooldownTimer: %d", MiscItem.TrueIPLevelGate, MiscItem.ItemPoints, globalvars.ItemPoints, MiscItem.PlayerLevel, MiscItem.TrueIPCooldownTimer);
						if (MiscItem.TrueIPLevelGate <= 0 && MiscItem.ItemPoints >= cost && globalvars.ItemPoints >= cost && MiscItem.PlayerLevel > 0 && MiscItem.TrueIPCooldownTimer <= 0)
						{
							globalvars.TrueIPTimesUsed += 1;
							if (skill == SKILL_VERY_EASY) IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.625);
							if (skill == SKILL_EASY) IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.75);
							if (skill == SKILL_NORMAL) IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.875);
							if (skill == SKILL_HARD) IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 1.0);
							if (skill == SKILL_VERY_HARD) IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 1.125);
							if (IPLevelGateInc < 1) IPLevelGateInc = 1;
							MiscItem.TrueIPLevelGate += IPLevelGateInc;
							int truecost = MiscItem.ItemPoints;
							MiscItem.ItemPoints -= cost;
							globalvars.ItemPoints -= cost;
							A_IPUseHUD(truecost);
							
							if (MiscItem.IPDissipateTimer > 0) MiscItem.IPDissipateTimer = 0;
							MiscItem.IPNoGainTimer = 60 * TICRATE;
							MiscItem.TrueIPCooldownTimer = ((300 * TICRATE) * (1.0 - (MiscItem.PlayerLevel * 0.008)));
							if (MiscItem.TrueIPCooldownTimer <= (60 * TICRATE)) MiscItem.TrueIPCooldownTimer = 60 * TICRATE;
							A_SetBlend("ff c0 00",1.00,(random(40,70)*2));
							double xp = pos.x;
							double yp = pos.y;
							double zp = pos.z;
							ThinkerIterator MonsterFinder = ThinkerIterator.Create("Actor");
							Actor mo;
							int numfound = 0;
							nm = "CCardGhostMarker";
							while (mo = Actor(MonsterFinder.Next()))
							{
								if (mo.bISMONSTER && 
										mo.bSHOOTABLE && 
										(mo.bCOUNTKILL || mo.CountInv(nm)) && 
										mo.health > 0 &&
										!mo.bFRIENDLY)
								{
									if (abs(xp - mo.pos.x) <= 16384 || 
											abs(yp - mo.pos.y) <= 16384 ||
											abs(zp - mo.pos.z) <= 16384)
									{
										/*
										if (!wasnodmgthrust) bNODAMAGETHRUST = true;
										if (!wasforceradius) bFORCERADIUSDMG = true;
										int counthit = A_Explode(64,16384,0,0,16384);
										if (!wasforceradius) bFORCERADIUSDMG = false;
										if (!wasnodmgthrust) bNODAMAGETHRUST = false;
										*/
										numfound++;
										int dmginf = (mo.health * frandompick(0.2,0.25,0.25,0.25,0.25,0.334));
										if (mo.CountInv(nm)) dmginf = ((mo.SpawnHealth() + mo.Stamina) * 2.0);
										mo.DamageMobj(self, self, dmginf, "TrueIP", DMG_NO_ARMOR|DMG_FORCED|DMG_NO_FACTOR|DMG_NO_PROTECT|DMG_NO_ENHANCE|DMG_EXPLOSION|DMG_THRUSTLESS, angle);
									}
								}
							}
							if (dydudebug_ipdisplays) Console.Printf("%d", numfound);
							if (numfound)
							{
								string sndname = "dinah/superdie";
								if (random(1,2) <= 1) sndname =  "dinah/YoullPayForThat";
								A_StopSound(CHAN_VOICE);
								A_StopSound(303);
								A_StopSound(304);
								A_StopSound(401);
								A_StopSound(402);
								A_StopSound(403);
								A_StartSound(sndname,CHAN_VOICE,CHANF_OVERLAP,0.8,ATTN_NONE,1.0);
								A_StartSound(sndname,303,CHANF_OVERLAP,0.7,ATTN_NONE,0.97);
								A_StartSound(sndname,304,CHANF_OVERLAP,0.7,ATTN_NONE,1.03);
								A_StartSound("DinahIP/IPBoom1",401,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
								A_StartSound("DinahIP/IPBoom2",402,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
								A_StartSound("DinahIP/IPBoom3",403,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							}
							
							A_StopSound(501);
							A_StopSound(502);
							A_StopSound(503);
							A_StopSound(504);
							A_StartSound("DinahIP/IPActivate1",501,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate2",502,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate3",503,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate4",504,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							if (!CountInv("DinahTrueIPState")) 
							{
								A_SetInventory("DinahTrueIPState",1);
								let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
								if (TrueIPItem) TrueIPItem.EffectTics = ((60 * TICRATE) * (1.0 + ((MiscItem.PlayerLevel - 1) * 0.005)));
							}
							else
							{
								let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
								if (TrueIPItem) TrueIPItem.EffectTics += ((60 * TICRATE) * (1.0 + ((MiscItem.PlayerLevel - 1) * 0.005)));
							}
						}
					}
				}
			}
			
			int IPLoopInt;
			if (!CountInv("INTERMAPChecker"))
			{
				if (CountInv("DinahTrueIPState"))
				{
					let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
					double raddmg = random(6,12) * 4;
					double radradius = (radius * 3.75);
					double radradius2 = (radius * 2.875);
					if (TrueIPItem)
					{
						raddmg = (random(6,12) * 4) * (frandom(0.475,0.525) + (TrueIPItem.EffectTics * 1.0 / (60 * TICRATE)));
						if (CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
						{
							raddmg *= randompick(12,16,20,24,32,36,40,48,60);
							radradius *= 2.0;
							radradius2 *= 2.0;
						}
					}
					bool wasnodmgthrust;
					bool wasforceradius;
					if (bNODAMAGETHRUST) wasnodmgthrust = true;
					if (bFORCERADIUSDMG) wasforceradius = true;
					if (!wasnodmgthrust) bNODAMAGETHRUST = true;
					if (!wasforceradius) bFORCERADIUSDMG = true;
					A_Explode(raddmg,radradius,0,0,radradius2,0,0,"","TrueIP");
					if (!wasforceradius) bFORCERADIUSDMG = false;
					if (!wasnodmgthrust) bNODAMAGETHRUST = false;
					double loopvol = frandom(0.45,0.55);
					if (TrueIPItem) loopvol = frandom(0.475,0.525) * (TrueIPItem.EffectTics * 1.0 / (60 * TICRATE));
					//Console.Printf("loopvol: %.2f", loopvol);
					IPLoopTimer++;
					IPLoopInt = IPLoopTimer % 91;
					if (IPLoopInt == 0)
					{
						A_StopSound(701);
						A_StartSound("DinahIP/IPLoop3",701,CHANF_NOSTOP|CHANF_LOOPING,loopvol,ATTN_NORM,frandom(0.9,1.1));
					}
				}
				else
				{
					IPLoopTimer = 0;
					A_StopSound(701);
				}
			}
			
			//
			double fademax = 1.00;
			if (health <= 0)
			{
				if (deadtimer <= 0) 
				{
					fadetime = int(TICRATE*frandom(2.1667,2.8334));
					A_SetBlend("00 00 00",0.00, fadetime, "00 00 00",fademax);
				}
				if (deadtimer > (fadetime-2)) A_SetInventory("BlackScreenHUD",1);
				deadtimer++;
				//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
			}
			else 
			{
				if (deadtimer > 0) 
				{
					fadetime *= 0.25;
					A_SetBlend("00 00 00",fademax, fadetime, "00 00 00",0.00);
					A_SetInventory("BlackScreenHUD",0);
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
				}
				deadtimer = 0;
			}
			
			// Heartbeat [low health]
			if (exex_playerbpm)
			{
				if (health > 0)
				{
					beattimer++;
					if (health <= (CountInv("PlayerMaxHP") * 0.01))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,frandom(1.0,1.2),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(10,11);
							beattimer = 0;
						}
					}
					else
					if (health <= (CountInv("PlayerMaxHP") * 0.05))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,frandom(1.0,1.2),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(15,17);
							beattimer = 0;
						}
					}
					else
					if (health <= (CountInv("PlayerMaxHP") * 0.10))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(28,42);
							beattimer = 0;
						}
					}
					else
					if (health <= (CountInv("PlayerMaxHP") * 0.25))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,frandom(0.675,0.825),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					if (health <= (CountInv("PlayerMaxHP") * 0.5))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,frandom(0.45,0.55),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(66,74);
							beattimer = 0;
						}
					}
					else
					{
						beatpulse = random(124,128);
						beattimer = 0;
					}
				}
				else
				{
					beatpulse = 5000;
				}
			}
			
			// Armor
			armortier = 0;
			double SavePercent = 0.000000;
			int MaxAbsorb = 0;
			int MaxFullAbsorb = 0;

			let armoritem = BasicArmor(player.mo.FindInventory("BasicArmor"));
			if (armoritem != null && CountInv("BasicArmor") > 0)
			{
				SavePercent = armoritem.SavePercent;
				MaxAbsorb = armoritem.MaxAbsorb;
				MaxFullAbsorb = armoritem.MaxFullAbsorb;
				if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
				if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
				if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
				if (savepercent >= 0.87500 && savepercent <= 0.93749) armortier = 3;
				if (savepercent >= 0.93750 && savepercent <= 0.99999) armortier = 4;
				if (savepercent >= 1.00000) armortier = 5;
				
				if (dydudebug_armordisplays) Console.Printf("\c[sapphire]Armor -\c- SavePercent: %.8f, Tier: %d, MaxAbsorb: %d, MaxFullAbsorb: %d", savepercent, armortier, MaxAbsorb, MaxFullAbsorb);
			}
			
			if (armortier == 1) A_SetInventory("KnightGownItem",1); else A_SetInventory("KnightGownItem",0);
			if (armortier == 2) A_SetInventory("KnightGownItem2",1); else A_SetInventory("KnightGownItem2",0);
			if (armortier == 3) A_SetInventory("KnightGownItem3",1); else A_SetInventory("KnightGownItem3",0);
			if (armortier == 4) A_SetInventory("KnightGownItem4",1); else A_SetInventory("KnightGownItem4",0);
			
			if (MiscItem) MiscItem.GetSpeedFactor();
		}

		// Recall All
		if (recalledall)
		{
			if (dydudebug_recalldisplays) Console.Printf("Recall All Attempt");

			actor recalleetarg;
			recalleetarg = actor(AimTarget());

			int numberrecalled = 0;
			ActorIterator it = Level.CreateActorIterator(1000);
			Actor recallee;
			while (recallee = it.Next())
			{
				if (recallee.bISMONSTER && recallee.bFRIENDLY)
				{
					if (dydudebug_recalldisplays) Console.Printf("\cx(Recall All)\c- Name: %s (TID: %d)", recallee.GetClassName(), recallee.tid);
					Vector3 savedpos = (pos.x, pos.y, (pos.z + random(6.0,12.0)));
					recallee.SetOrigin(savedpos,false);
					recallee.angle += frandom(0.0,360.0);
					recallee.vel.x += frandom(-4.0,4.0);
					recallee.vel.y += frandom(-4.0,4.0);
					recallee.vel.z += frandom(4.0,8.0);
					numberrecalled++;
					if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) recallee.target = recalleetarg;
				}
			}
			
			if (numberrecalled > 0)
			{
				//A_StartSound("monstersummon", 161, CHANF_DEFAULT);
				A_SpawnItemEx("PlayerWhistle",0.0,0.0,32.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
				Vector3 savedpos2 = (pos.x, pos.y, pos.z+(height*0.25));
				Actor fog = Spawn("TeleportFog", savedpos2, ALLOW_REPLACE); 
				if (fog != null)
				{
					fog.scale.x *= frandom(0.375, 0.625);
					fog.scale.y *= frandom(0.375, 0.625);
					fog.A_SetRenderStyle(frandom(0.375, 0.625),STYLE_Add);
				}
				
				if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) A_PrintBold(String.Format("\cfRecalled all allies to your location and gave them a new target!"), frandom(0.685,0.8));
				else A_PrintBold(String.Format("\cfRecalled all allies to your location!"), frandom(0.685,0.8));
			}
			else
			{
				A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
				A_PrintBold(String.Format("\cgRecall Failed: No creatures available to recall!"), frandom(0.685,0.8));
			}

			recalledall = false;
		}
		
		//****************************************************
		//*Flicker the Player when they survive a mortal hit *
		//****************************************************
		if (self.health == 1 && (player.cheats & CF_BUDDHA || player.cheats & CF_BUDDHA2) && lasthealth > 1)
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.MercyInvulnOn = true;
				MiscItem.MercyInvulnTimer = 1210; // 1.5 Seconds
				MiscItem.MercyInvulnTimer += int(MiscItem.PlayerLevel * 3.65);
				
				// IP Cost Reduction Bonuses do NOT occur for having Ultimate Buddha Mode [i.e. CF_BUDDHA2 flag] on by itself
				if (player.cheats & CF_BUDDHA)
				{
					if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 5))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer = 0;
						MiscItem.IPMortalBlowReduceTimer += 525;
					}
					else if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 4))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.2;
						MiscItem.IPMortalBlowReduceTimer += random(437,438);
					}
					else if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 3))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.4;
						MiscItem.IPMortalBlowReduceTimer += 350;
					}
					else if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 2))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.6;
						MiscItem.IPMortalBlowReduceTimer += random(262,263);
					}
					else if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.8;
						MiscItem.IPMortalBlowReduceTimer += 175;
					}
					else
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.98;
						MiscItem.IPMortalBlowReduceTimer += random(37,38);
					}
				}
				
				player.health = player.mo.health = 1;
			}
		}

		int basespeedvelsx;
		int basespeedvelsy;
		double basespeedvelsxd = 16.66666667;
		double basespeedvelsyd = 16.66666667;

		basespeedvelsxd *= ForwardMove2;
		basespeedvelsyd *= SideMove2;
		basespeedvelsx = (basespeedvelsxd * 65536);
		basespeedvelsy = (basespeedvelsyd * 65536);

		double newspeedvelsxd = basespeedvelsxd * truespeed;
		double newspeedvelsyd = basespeedvelsyd * truespeed;
		int newspeedvelsx = newspeedvelsxd * 65536;
		int newspeedvelsy = newspeedvelsyd * 65536;
		if (dydudebug_playermove) Console.Printf("\cz WaterLevel: %d\c-, \cz Angle: %.8f, Pitch: %.8f\c-, \czPosX: %d, PosY: %d, PosZ: %d\c-, VelX: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelY: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelZ: %.8f (%d)\c-", waterlevel, (angle % 360), pitch, pos.x, pos.y, pos.z, vel.x, newspeedvelsxd, (vel.x * 65536), newspeedvelsx, vel.y, newspeedvelsyd, (vel.y * 65536), newspeedvelsy, vel.z, (vel.z * 65536));

		lasthealth = health;
		
		Super.Tick();
	}

	override void CheckJump()
	{
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && player.onground && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDPlayPawn, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	// Reset Breathing Scale
	void A_APPBreatheReset()
	{
		if (!isvoodoodoll) 
		{
			scaleymulti = 1.00;
			breathdirection = 0;
			breathframe = 0;
			A_SetScale(basexscale,baseyscale*scaleymulti);
		}
	}
	
	// Breathing Function
	void A_APPBreathe(double startpoint = 1.00625, double endpoint = 0.99375, double breathincrementbase = 0.0025, double basetics = 4)
	{
		if (!isvoodoodoll) 
		{
			double HealthBreathSpeed = 1.0;
			double HealthRatio; 
			if (CountInv("PlayerMaxHP") > 0) 
			{
				HealthRatio = (health * 1.00) / (CountInv("PlayerMaxHP") * 1.00);
				// Console.Printf("%.8f", HealthRatio);
				if (health > 0)
				{
					if (HealthRatio >= 1.75001) HealthBreathSpeed = 0.01;
					if (HealthRatio >= 1.62501 && HealthRatio <= 1.75000) HealthBreathSpeed = 0.175;
					if (HealthRatio >= 1.50001 && HealthRatio <= 1.62500) HealthBreathSpeed = 0.34;
					if (HealthRatio >= 1.37501 && HealthRatio <= 1.50000) HealthBreathSpeed = 0.505;
					if (HealthRatio >= 1.25001 && HealthRatio <= 1.37500) HealthBreathSpeed = 0.67;
					if (HealthRatio >= 1.12501 && HealthRatio <= 1.25000) HealthBreathSpeed = 0.835;
					if (HealthRatio >= 0.87501 && HealthRatio <= 1.12500) HealthBreathSpeed = 1.00;
					if (HealthRatio >= 0.75001 && HealthRatio <= 0.87500) HealthBreathSpeed = 1.165;
					if (HealthRatio >= 0.62501 && HealthRatio <= 0.75000) HealthBreathSpeed = 1.33;
					if (HealthRatio >= 0.50001 && HealthRatio <= 0.62500) HealthBreathSpeed = 1.495;
					if (HealthRatio >= 0.37501 && HealthRatio <= 0.50000) HealthBreathSpeed = 1.66;
					if (HealthRatio >= 0.25001 && HealthRatio <= 0.37500) HealthBreathSpeed = 1.825;
					if (HealthRatio >= 0.12501 && HealthRatio <= 0.25000) HealthBreathSpeed = 1.99;
					if (HealthRatio >= 0.00001 && HealthRatio <= 0.12500) HealthBreathSpeed = 2.155;
					if (Health == 1) HealthBreathSpeed = 2.485;
				}
				breathincrementbase *= HealthBreathSpeed;
				
				double ticmulti = 1.00 * (tics / basetics);
				breathincrementbase *= ticmulti;

				if (breathdirection == 0)
				{
					breathframe++;
					scaleymulti -= breathincrementbase;
					if (scaleymulti <= endpoint) { scaleymulti = endpoint; breathdirection = 1; breathframe = 0; }
				}
				else
				{
					breathframe++;
					scaleymulti += breathincrementbase;
					if (scaleymulti >= startpoint) { scaleymulti = startpoint; breathdirection = 0; breathframe = 0; }
				}

				if (dydudebug_playerbreathedisplays)
				{
					Console.Printf("scaleymulti = %.8f, breathincrementbase = %.8f, breathdirection = %d, breathframe = %d, HealthBreathSpeed = %.8f, ticmulti = %.8f, actualtics = %d, basetics = %d [gametic: %d]", 
													scaleymulti, 
													breathincrementbase, 
													breathdirection, 
													breathframe, 
													HealthBreathSpeed, 
													ticmulti, 
													tics, 
													basetics,
													gametic);
				}
			}
			else
			{
				scaleymulti = 1.00;
				breathdirection = 0;
				breathframe = 0;
			}
			A_SetScale(basexscale,baseyscale*scaleymulti);
		}
	}
	
	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = 0;
				if (bNOBLOODDECALS) bNOBLOODDECALS = 1;
			}
		}
		else
		{
			//Console.Printf("(A_CheckNeverBleed [player], damage: %d)", damage);
			if (flags & !DMG_EXPLOSION)
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = 1;
					bNOBLOODDECALS = 1;
				}
			}
		}
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (CountInv("EvadeAnAttack"))
		{
			if (!((source == null && inflictor == null) &&
					(mod == 'Slime' || mod == 'Magma' || mod == 'Crush' || 	mod == 'Drowning' || mod == 'SigilDrain' || mod == 'Falling')) || mod == 'SigilDrain')
			{
				A_StartSound("player/dodge",305,CHANF_OVERLAP|CHANF_LOCAL,frandom(0.75,1.25),ATTN_NORM,frandom(0.75,1.25));
				if (exex_playerdmglog)
				{
					if (mod == 'NONE') mod = 'Typeless';
					string combatlogmsg = "\c[sapphire]*\c- Dodged";
					if (source) // Has a source
					{
						combatlogmsg.AppendFormat(" \c[purple]%s\c-", source.GetTag());
						if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
					}
					else
					if (inflictor) // No source, but has an inflictor
					{
						combatlogmsg.AppendFormat(" \c[brick]%s!", inflictor.GetTag());
					}
					else // If no source OR inflictor
					{
						if (mod == 'Slime') combatlogmsg.AppendFormat(" a damaging surface");
						else if (mod == 'Lava' || mod == 'Magma') combatlogmsg.AppendFormat(" a damaging surface");
						else if (mod == 'Crush') combatlogmsg.AppendFormat(" a crushing ceiling");
						combatlogmsg.AppendFormat("!");
					}
					combatlogmsg.AppendFormat(" [%s]", mod);
					if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
					if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
					Console.Printf(combatlogmsg);
				}
				if (dydudebug_playerdamagemobj) Console.Printf("Evasion - no damage");
				return 0;
			}
			else
			{
				int prevdmg = damage;
				damage *= (frandompick(0.2,0.2,0.2,0.25,0.25,0.25,0.25,0.25,0.25,0.334) * randompick(1,1,1,2,2,2,2,2,2,3));
				if (damage > prevdmg) damage = prevdmg;
			}
		}

		class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
		string nm, nn, no, np;
		
		int firstdmg = damage;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();

		int PlayerLevel;
		if (MiscItem) PlayerLevel = MiscItem.PlayerLevel;
		
		Actor AttackingActor;
		Actor UniqueProjectile;
		FastProjectile UniqueProjectileFast;
		Actor ailmentproj;
		FastProjectile ailmentprojfast;
		Actor singleripproj;
		FastProjectile singlefastripproj;
		
		if (dydudebug_playerdamagemobj)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
			if (flags & DMG_NO_PAIN) Console.Printf("    (\cyPainless?: yes)");
		}
		if (dydudebug_playerdamagemobj) Console.Printf("DamageType: %s", mod);
		
		if (source) AttackingActor = Actor(source);
		if (inflictor) 
		{
			UniqueProjectile = Actor(inflictor);
			UniqueProjectileFast = FastProjectile(inflictor);
			ailmentproj = Actor(inflictor);
			ailmentprojfast = FastProjectile(inflictor);
			singleripproj = Actor(inflictor);
			singlefastripproj = FastProjectile(inflictor);
		}
		
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		int olddmg;
		armortier = 0;
		double SavePercent = 0.000000;
		int MaxAbsorb = 0;
		int MaxFullAbsorb = 0;
		
		int flatdefense;
		bool useflatdefense;
		let armoritem = BasicArmor(player.mo.FindInventory("BasicArmor"));
		if (armoritem != null && CountInv("BasicArmor") > 0)
		{
			SavePercent = armoritem.SavePercent;
			MaxAbsorb = armoritem.MaxAbsorb;
			MaxFullAbsorb = armoritem.MaxFullAbsorb;
			if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
			if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
			if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
			if (savepercent >= 0.87500 && savepercent <= 0.93749) armortier = 3;
			if (savepercent >= 0.93750 && savepercent <= 0.99999) armortier = 4;
			if (savepercent >= 1.00000) armortier = 5;
			
			if (dydudebug_playerdamagemobj) Console.Printf("Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
		}
		
		bool SigilDrain;
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1] - Base: %d", damage);
		if (mod == 'SigilDrain' && source == null && inflictor == self && flags & DMG_NO_ARMOR)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
			flags |= DMG_NO_PAIN;
			SigilDrain = true;
			if (dydudebug_playerdamagemobj) Console.Printf("SigilDrain"); 
		}
		if (mod == 'Crush' && source == null && inflictor == null)
		{
			if (random(1,8) <= 7) flags |= DMG_NO_ARMOR;
			if (random(1,8) <= 1) flags |= DMG_NO_FACTOR;
			if (dydudebug_playerdamagemobj) Console.Printf("Crush"); 
		}
		
		if (mod != 'Slime' || 
				mod != 'Magma' || 
				mod != 'Crush' || 
				mod != 'Falling' || 
				mod != 'Poison' || 
				mod != 'PoisonCloud' || 
				mod != 'Magic' || 
				mod != 'Eldritch' || 
				mod != 'Sigil' || 
				mod != 'SigilDrain' || 
				mod != 'SpectralLow')
		{
			if (mod == 'Beats' && flags & DMG_EXPLOSION && AttackingActor == self)
			{
				flags |= DMG_NO_ARMOR;
				flags |= DMG_THRUSTLESS;
				damage = ceil(damage * frandompick(1.0,1.0,1.0,1.125,1.125));
				if (dydudebug_playerdamagemobj) Console.Printf("Grimophone Alt-Fire (%d)", damage);
				if (damage >= health) return 0;
			}
			else
			{
				if (SigilDrain) { } else damage = ceil(damage * 1.125);
			}
			if (SigilDrain) { } else if (CountInv("DoingSpinAttack")) damage *= 0.25;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1b]: %d", damage);
		}
		else
		if (mod == 'Magic' || 
				mod == 'Poison' || 
				mod == 'PoisonCloud' || 
				mod == 'Eldritch' || 
				mod == 'Sigil' ||
				mod == 'SigilDrain' ||
				mod == 'SpectralLow')
		{
			if (SigilDrain) { } else damage = ceil(damage * 0.875);
			if (SigilDrain) { } else if (CountInv("DoingSpinAttack")) damage *= 0.25;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (non-normal base) [Step 1b]: %d", damage);
		}
		else
		if (mod == 'Slime' || 
				mod == 'Magma' ||
				mod == 'Crush' || 
				mod == 'Falling')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.125,1.125,1.25));
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (misc base) [Step 1b]: %d", damage);
		}
		
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)  
		{
			if (dydudebug_playerdamagemobj) Console.Printf("\cyIS A VOODOO DOLL\c-)", damage);
			//*********************************************************************
			return super.DamageMobj(inflictor, source, damage, mod, flags, angle); 
			//*********************************************************************
		}

		// Direct Damage Changes
		if (flags & DMG_INFLICTOR_IS_PUFF)
		{
			if (AttackingActor != self)
			{
				if (BulletPuff(self))
				{
					olddmg = damage;
					if (dydudebug_playerdamagemobj) Console.Printf("Hit by Doom Bullet");
					if (armortier == 0) damage = ceil(damage * 0.9375);
					if (armortier == 1) damage = ceil(damage * 0.875);
					if (armortier == 2) damage = ceil(damage * 0.75);
					if (armortier == 3) damage = ceil(damage * 0.625);
					if (armortier == 4) damage = ceil(damage * 0.5);
					if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.667,0.75,0.75,0.75,0.75,0.75,0.834));
					if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.667,0.75,0.75,0.75,0.75,0.75,0.834) * 0.25));
					if (CountInv("DoingSpinAttack")) damage *= 0.25; // Cricket Bat Spin Attack almost entirely negates bullet damage

					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Bullet Buff]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		olddmg = damage;
		if (flags & DMG_EXPLOSION)
		{
			if (AttackingActor == self)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Own AOE");
				
				if (mod == 'Beats')
				{
				}
				else
				{
					damage = ceil(damage * (0.25 - (MiscItem.PlayerLevel * 0.005)));
					if (MiscItem.PlayerLevel <= 100 && damage < 1) damage = 1;
					if (armortier == 1) damage = ceil(damage * 0.975);
					if (armortier == 2) damage = ceil(damage * 0.9625);
					if (armortier == 3) damage = ceil(damage * 0.95);
					if (armortier == 4) damage = ceil(damage * 0.925);
					useflatdefense = false;
				}
			}
			else
			{
				double set1, set2, set3;
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Not Own AOE");
				set1 = (0.750 - (MiscItem.PlayerLevel * 0.0150));
				set2 = (0.875 - (MiscItem.PlayerLevel * 0.0175));
				set3 = (1.000 - (MiscItem.PlayerLevel * 0.0200));
				if (AttackingActor != null)
				{
					if (sour == "Cyberdemon") 
					{
						set1 = (0.875 - (MiscItem.PlayerLevel * 0.0175));
						set2 = (0.9375 - (MiscItem.PlayerLevel * 0.01875));
						set3 = (1.0 - (MiscItem.PlayerLevel * 0.02));
					}
					else 
					if (sour == "Archvile" || sour == "ArchvileNew") 
					{
						set1 = (0.50 - (MiscItem.PlayerLevel * 0.01));
						set2 = (0.625 - (MiscItem.PlayerLevel * 0.0125));
						set3 = (0.75 - (MiscItem.PlayerLevel * 0.015));
					}
				}
				damage = ceil(damage * frandompick(set1,set1,set2,set2,set2,set2,set2,set2,set3,set3));
				if (MiscItem.PlayerLevel <= 100 && damage < 1) damage = 1;
				if (armortier == 1) damage = ceil(damage * 0.9875);
				if (armortier == 2) damage = ceil(damage * 0.975);
				if (armortier == 3) damage = ceil(damage * 0.9625);
				if (armortier == 4) damage = ceil(damage * 0.95);
				useflatdefense = true;
			}

			// Prevents AOE from IP Attacks that somehow still manage to deal you damage from being able to kill you
			DDProjectile IPAtkSource;
			if (inflictor)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire](IP ATTACK W/ AOE [INFLICTOR] ATTEMPT)");
				IPAtkSource = DDProjectile(inflictor);
				if (dydudebug_playerdamagemobj && IPAtkSource) Console.Printf("\c[fire](IP ATTACK W/ AOE [INFLICTOR] ATTEMPT [2])");
				if (IPAtkSource && IPAtkSource.IPattack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK W/ AOE [INFLICTOR])");
					return 0;
				}
			}
			if (!IPAtkSource && source)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire](IP ATTACK W/ AOE [SOURCE] ATTEMPT)");
				IPAtkSource = DDProjectile(source);
				if (dydudebug_playerdamagemobj && IPAtkSource) Console.Printf("\c[fire](IP ATTACK W/ AOE [SOURCE] ATTEMPT [2])");
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK W/ AOE [SOURCE])");
					return 0;
				}
			}
			
			if (EggShot(inflictor) ||
			    EggGrenade(inflictor) ||
			    EggMini(inflictor))
			{
				flags |= DMG_THRUSTLESS;
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG [AOE])");
				return 0;
			}
			if (EggShot(source) ||
			    EggGrenade(source) ||
			    EggMini(source))
			{
				flags |= DMG_THRUSTLESS;
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG [AOE])");
				return 0;
			}

			if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.334,0.5,0.5,0.5,0.5,0.5,0.667));
			if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.334,0.5,0.5,0.5,0.5,0.5,0.667) * 0.25));
			if (CountInv("DoingSpinAttack")) damage *= 0.05; // Cricket Bat Spin Attack almost entirely negates AOE damage
			
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [AOE]: %d (%d)", damage, olddmg);
		}
		else
		{
			// Prevents IP Attacks that somehow still manage to deal you damage from being able to kill you
			DDProjectile IPAtkSource;
			if (inflictor)
			{
				IPAtkSource = DDProjectile(inflictor);
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK [INFLICTOR])");
					return 0;
				}
			}
			if (!IPAtkSource && source)
			{
				IPAtkSource = DDProjectile(source);
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK [SOURCE])");
					return 0;
				}
			}
			
			if (EggShot(inflictor) ||
			    EggGrenade(inflictor) ||
			    EggMini(inflictor))
			{
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG)");
				return 0;
			}
			if (EggShot(source) ||
			    EggGrenade(source) ||
			    EggMini(source))
			{
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG)");
				return 0;
			}
		}
		
		olddmg = damage;
		if (source != null)
		{
			if (Crusader(source))
			{
				if (flags & DMG_EXPLOSION) // The Crusader's death AOE does very little damage to Dinah (37.5% and dropping)
				{
					damage = ceil(damage * frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
					if (armortier == 1) damage *= 0.90;
					if (armortier == 2) damage *= 0.80;
					if (armortier == 3) damage *= 0.60;
					if (armortier == 4) damage *= 0.20;
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderAOE]: %d (%d)", damage, olddmg);
				}
				if (inflictor != null)
				{
					if (CrusaderMissile(inflictor) || FastFlameMissile(inflictor)) // The Crusader's attacks are very wanting against Dinah overall (37.5% and dropping)
					{
						damage = ceil(damage * frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
						if (armortier == 1) damage *= 0.90;
						if (armortier == 2) damage *= 0.80;
						if (armortier == 3) damage *= 0.60;
						if (armortier == 4) damage *= 0.20;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderProj]: %d (%d)", damage, olddmg);
					}
				}
			}
			
			if (Revenant(source))
			{
				if (inflictor != null)
				{
					if (RevenantTracer(inflictor))
					{
						damage = ceil(damage * frandompick(0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.875,0.875,1.0) - 0.25);
						if (armortier == 1) damage *= 0.95;
						if (armortier == 2) damage *= 0.90;
						if (armortier == 3) damage *= 0.80;
						if (armortier == 4) damage *= 0.60;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [RevMissile]: %d (%d)", damage, olddmg);
					}
				}
			}
		}
		
		olddmg = damage;
		if (source != null || inflictor != null)
		{
			let weapon = player.ReadyWeapon;
			if (mod == 'Zap' && weapon is "WizardPike")
			{
				if (!DDPlayerPawn(source)) damage *= frandompick(0.1667,0.20,0.20,0.20,0.25,0.25,0.25,0.25,0.25,0.25,0.334,0.334,0.334,0.40);
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [ZapShot w/ Pike Equipped]: %d (%d)", damage, olddmg);
			}
		}

		// Check FRIGHTENED/FRIENDLY flags
		if (damage > 0)
		{
			if (AttackingActor)
			{
				if (AttackingActor != self)
				{
					if (AttackingActor.bFRIENDLY)
					{
						damage = 0;
						if (dydudebug_playerdamagemobj) Console.Printf("END DAMAGE ATTEMPT (FRIENDLY)");
						return 0;
					}
					else
					{
						if (AttackingActor.CountInv("ScramblerConfusion")) // If the attacker is under the effect of the Confusion debuff from the Scrambler
						{
							damage = ceil(damage * frandompick(0,0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1.0));
							if (damage == 0) return 0;
						}
						else
						{
							if (AttackingActor.bFRIGHTENED) // Attacker is frightened, AND the Player is the one that is doing the frightening
							{
								if (player.cheats & CF_FRIGHTENING || bFRIGHTENING) damage = ceil(damage * frandompick(0.625,0.6875,0.75)); else damage = ceil(damage * frandompick(0.9375,0.95,0.9625));
							}
						}
					}
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Friendly/Frighten Check]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		// Armor Checks
		if (armortier)
		{
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Drowning' || mod == 'Falling'))
			{
				olddmg = damage;
				if (mod == 'Crush')
				{
					if (useflatdefense)
					{
						if (armortier == 1) 
						{
							if (CountInv("KnightGownIP1Buff")) damage -= randompick(1,1,2,2,3);
																						else damage -= randompick(0,0,0,0,1);
						}
						if (armortier == 2) 
						{
							if (CountInv("KnightGownIP2Buff")) damage -= randompick(2,2,3,3,4);
																						else damage -= randompick(0,0,0,1,1);
						}
						if (armortier == 3)
						{
							if (CountInv("KnightGownIP3Buff")) damage -= randompick(3,3,4,4,5);
																						else damage -= randompick(0,0,1,1,2);
						}
						if (armortier >= 4) 
						{
							if (CountInv("KnightGownIP4Buff")) damage -= randompick(5,5,6,6,7);
																						else damage -= randompick(1,1,2,2,3);
						}
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,32) > 1) damage = 1;
						if (armortier == 3 && random(1,32) > 2) damage = 1;
						if (armortier >= 4 && random(1,32) > 4) damage = 1;
					}
				}
				else
				{
					if (useflatdefense)
					{
						if (armortier == 1) 
						{
							if (CountInv("KnightGownIP1Buff")) damage -= (random(0,4) + (PlayerLevel * 0.125));
																						else damage -= (random(0,1) + (PlayerLevel * 0.025));
						}
						if (armortier == 2) 
						{
							if (CountInv("KnightGownIP2Buff")) damage -= (random(4,8) + (PlayerLevel * 0.250));
																						else damage -= (random(1,2) + (PlayerLevel * 0.050));
						}
						if (armortier == 3) 
						{
							if (CountInv("KnightGownIP3Buff")) damage -= (random(8,12) + (PlayerLevel * 0.375));
																						else damage -= (random(2,3) + (PlayerLevel * 0.075));
						}
						if (armortier >= 4) 
						{
							if (CountInv("KnightGownIP4Buff")) damage -= (random(16,20) + (PlayerLevel * 0.625));
																						else damage -= (random(4,5) + (PlayerLevel * 0.125));
						}
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,8) > 1) damage = 1;
						if (armortier == 3 && random(1,8) > 2) damage = 1;
						if (armortier >= 4 && random(1,8) > 4) damage = 1;
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Raw Armor Def]: %d", damage, olddmg);
			}
			else
			{
				if (useflatdefense)
				{
					if (armortier == 1) 
					{
						if (CountInv("KnightGownIP1Buff")) damage -= randompick(0,0,0,0,0,0,0,1,1,2,2,3,3);
																					else damage -= randompick(0,0,0,0,0,0,0,0,0,0,0,0,1);
					}
					if (armortier == 2) 
					{
						if (CountInv("KnightGownIP2Buff")) damage -= randompick(0,0,0,0,0,0,1,1,2,2,3,3,4);
																					else damage -= randompick(0,0,0,0,0,0,0,0,0,0,0,1,1);
					}
					if (armortier == 3)
					{
						if (CountInv("KnightGownIP3Buff")) damage -= randompick(0,0,0,0,0,1,1,2,2,3,3,4,4);
																					else damage -= randompick(0,0,0,0,0,0,0,0,0,0,1,1,2);
					}
					if (armortier >= 4) 
					{
						if (CountInv("KnightGownIP4Buff")) damage -= randompick(0,0,0,1,1,2,2,3,3,4,4,5,5);
																					else damage -= randompick(0,0,0,0,0,0,0,0,1,1,2,2,3);
					}
				}
			}
		}
		
		// Berserk Effects
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD") && !SigilDrain)
		{
			olddmg = damage;
			if (mod == 'Falling') damage = ceil(damage * frandom(0.625,0.75));
			if (mod == 'Crush') damage = ceil(damage * frandom(0.75,0.875));
			if (mod == 'Drowning') damage = ceil(damage * frandom(0.875,1.000));
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Berserk Effects]: %d", damage, olddmg);
		}
		
		if (CountInv("PlayerDashing") && !SigilDrain)
		{
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Dashing Avoids Damage]");
			return 0;
		}

		if (CountInv("PowerTimeFreezer") || 
				CountInv("DDMiscTimeFreezer") || 
				(CountInv("DebugTimeFreezer") && dydudebug_timeslowinterval > 1) || 
				CountInv("TimePotionTimeFreezer") || 
				CountInv("DashTimeFreezer"))
		{
			if (mod == 'Slime' || mod == 'Magma')
			{
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [TimeFreeze on Slime abort]");
				return 0;
			}
		}
		
		olddmg = damage;
		if (mod == "CCardsPoison")
		{
			double dmg1base = 0.00;
			if (armortier == 1) 
			{
				damage *= frandom(0.875,1.000);
				dmg1base = 6.25;
			}
			if (armortier == 2) 
			{
				damage *= frandom(0.625,0.875);
				dmg1base = 12.5;
			}
			if (armortier == 3) 
			{
				damage *= frandom(0.25,0.625);
				dmg1base = 43.75;
			}
			if (armortier == 4) 
			{
				damage *= frandom(0.0,0.25);
				dmg1base = 87.5;
			}
			if (frandom(0.1,100.0) > dmg1base && damage < 1) damage = 1;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CCards Acid w/ Armor]: %d (%d)", damage, olddmg);
		}
		
		bool isinvuln = false;
		// If Invulnerable
		{
			if (bINVULNERABLE || player.cheats & CF_GODMODE2 || player.cheats & CF_GODMODE || CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
			{ 
				if (SigilDrain) damage = 0;
				A_StartSound("Player/TookNoDamageInvuln",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				isinvuln = true;
			}
		}
		
		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = 0.00;
		if (damage > 0)
		{
			if (inflictor == null && source == null)
			{
			}
			else
			{
				if (!CountInv("DinahTrueIPState")) // The Flower Crown IP Mode Negates most Defense Ignoring attacks :V
				{
					double PikeAOEFactor = 0.334;
					if (mod == 'Zap') PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					if (mod == 'Zap' && flags & DMG_EXPLOSION) PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					if (flags & DMG_INFLICTOR_IS_PUFF && (PikePuff(inflictor) || PikePuff(source))) PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
					if (mod == 'Beats') PlayerDefenseIgnoreFactor += (BeatsFactor * (1.00 - PlayerDefenseIgnoreFactor));
					double BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
					if (mod == 'Beats' && flags & DMG_EXPLOSION) PlayerDefenseIgnoreFactor += (BeatsAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double BarrelFactor = 0.50;
					if (skill <= 0) BarrelFactor = 0.0;
					if (skill == 1) BarrelFactor = 0.25;
					if (skill == 2) BarrelFactor = 0.5;
					if (skill == 3) BarrelFactor = 0.75;
					if (skill >= 4) BarrelFactor = 1.0;
					if ((ExplosiveBarrel(inflictor) || ExplosiveBarrel(source) || Pod(inflictor) || Pod(source)) && flags & DMG_EXPLOSION) PlayerDefenseIgnoreFactor += (BarrelFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double SuckFactor = 0.334;
					if (mod == 'Suck') PlayerDefenseIgnoreFactor += (SuckFactor * (1.00 - PlayerDefenseIgnoreFactor));
				}
			}
		}
		
		int armoramt = CountInv("BasicArmor");
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Final] - Final Damage: %d", damage);
		
		if (dydudebug_playerdamagemobj && armoramt) Console.Printf("Armor Amount: %d", armoramt);
		//******************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//******************************
		ret = PostDamageMobj(inflictor, source, damage, mod, flags, angle, 
												 ret, armoramt, firstdmg, isinvuln, oldhealth, oldhealthratio, SigilDrain,
												 infl, sour, vict);
		
		return ret;
	}
	
	int PostDamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, int ret, int armoramt, int firstdmg, bool isinvuln, int oldhealth, int oldhealthratio, bool SigilDrain, string infl, string sour, string vict)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		
		string combatlogmsg = "\c[sapphire]*\c- ";
		int armdmg = (armoramt - CountInv("BasicArmor"));
		if (armdmg <= 0) armdmg = 0;
		if (dydudebug_playerdamagemobj && armdmg) Console.Printf("Armor Damage: %d", armdmg);
		if (armdmg && exex_armordmgsounds)
		{
			A_StopSound(213);
			if (CountInv("BasicArmor")) A_StartSound("armordamaged",213,CHANF_DEFAULT,1.0,ATTN_NORM);
														 else A_StartSound("armorbroken",213,CHANF_DEFAULT,1.0,ATTN_NORM);
		}
		if (exex_playerdmglog)
		{
			if (ret || armdmg)
			{
				if (armdmg && !ret) combatlogmsg.AppendFormat("\c[darkgreen]%d AP\c- ", armdmg);
				else if (armdmg && ret) combatlogmsg.AppendFormat("\c[darkred]%d HP\c- & \c[darkgreen]%d AP\c- ", ret, armdmg);
				else combatlogmsg.AppendFormat("\c[darkred]%d HP\c- ", ret);
				if (dydudebug_dmgdiffdebug)
				{
					int dmgdiff = ((ret + armdmg) - firstdmg);
					//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
					if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2)
					{
						combatlogmsg.AppendFormat("[", dmgdiff);
						if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
						if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
						if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
						combatlogmsg.AppendFormat(" (", dmgdiff);
					}
					else
					{
						combatlogmsg.AppendFormat("[", dmgdiff);
					}
					if (dydudebug_dmgdiffdebug >= 2 && dydudebug_dmgdiffdebug <= 3 && MiscItem)
					{
						double dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
						if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
						if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
						if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
						if (dydudebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																				else combatlogmsg.AppendFormat(")", dmgdiff);
					}
					if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
				}
				if (mod == 'SigilDrain') combatlogmsg.AppendFormat("of damage drained");
														else combatlogmsg.AppendFormat("of damage taken");
			}
			else
			{
				if (isinvuln) 
				{
					combatlogmsg.AppendFormat("\c[green]Invulnerable!\c- No Damage taken\c-");
				}
				else
				{
					A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
					combatlogmsg.AppendFormat("\c[white]No Damage taken\c-");
				}
			}
			if (source) // Has a source
			{
				combatlogmsg.AppendFormat(" from \c[purple]%s\c-", source.GetTag());
				if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
			}
			else
			if (inflictor) // No source, but has an inflictor
			{
				if (mod == 'SigilDrain') combatlogmsg.AppendFormat(" by the Sigil!");
														else combatlogmsg.AppendFormat(" from \c[brick]%s!", inflictor.GetTag());
			}
			else // If no source OR inflictor
			{
				if (mod == 'Slime') combatlogmsg.AppendFormat(" from a damaging surface");
				else if (mod == 'Lava' || mod == 'Magma') combatlogmsg.AppendFormat(" from a damaging surface");
				else if (mod == 'Crush') combatlogmsg.AppendFormat(" from a crushing ceiling");
				else if (mod == 'Falling') combatlogmsg.AppendFormat(" from falling");
				else if (mod == 'Drowning') combatlogmsg.AppendFormat(" from drowning");
				combatlogmsg.AppendFormat("!");
			}
			combatlogmsg.AppendFormat(" [%s]", mod);
			if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
			if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
			Console.Printf(combatlogmsg);
		}

		// Item/Ikari Point Gains
		if (exex_ikaripointsenabled && ret && MiscItem && globalvars && health > 0)
		{
			int gain = 0;
			if ((source && source != self) && (inflictor && inflictor != self)) gain += 1;
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Drowning' || mod == 'Falling' || mod == 'Crush')) gain += 1;
			if (gain && MiscItem.IPNoGainTimer <= 0)
			{
				double base;
				// The mod's first and original formula
				if (exex_ikaripointscalctype <= 0)
				{
					base = ret * 100.0 / MiscItem.MaxHealthTrue;
					if (oldhealthratio == 0) base *= 1.0;
					if (oldhealthratio == 1) base *= 1.125;
					if (oldhealthratio == 2) base *= 1.25;
					if (oldhealthratio == 3) base *= 1.5;
					if (oldhealthratio == 4) base *= 2.25;
					if (oldhealth > 1 && health == 1) base *= 3.25;
					if (MiscItem.PlayerLUCK) base *= (0.125 + (MiscItem.PlayerLevel * 0.00125) + (random(1,MiscItem.PlayerLUCK) * frandompick(0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.001,0.001,0.001,0.001,0.001,0.001,0.002,0.002,0.002,0.002,0.003,0.003)));
															else base *= (0.125 + (MiscItem.PlayerLevel * 0.00125));
					
				}
				// The more Lufia II equse formula
				if (exex_ikaripointscalctype >= 0)
				{
					base = ret * 100.0 / oldhealth; // % of remaining HP removed
					if (base >= 0.001)
					{
						if (base >= 0.001 && base <= 50.000) base *= 0.50; // <= 50% equals half of the percent in IP points given [up to 25%]
						if (base >= 50.001 && base <= 65.000) base *= 0.558077; 
						if (base >= 65.001 && base <= 75.000) base *= 0.646154;
						if (base >= 75.001 && base <= 85.000) base *= 0.76; 
						if (base >= 85.001 && base <= 90.000) base *= 0.90; 
						if (base >= 90.001 && base <= 100.000) base *= 1.00; 
						if (base >= 100.001) base *= 1.25;
						if (oldhealth > 1 && health == 1) base += MiscItem.MaxItemPoints;
					}
				}
				nm = "CCards_Actor_AcidBlood"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.375,1.5,1.5,1.5,1.5,1.5,1.625);
				nm = "CCards_Actor_HighVoltageZapp"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.5625,1.75,1.75,1.75,1.75,1.75,1.9375);
				nm = "CCards_Actor_ThrownCorpseHitbox"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.1875,1.25,1.25,1.25,1.25,1.25,1.3125);
				if (mod == 'SigilDrain')
				{
					base *= frandompick(0.2,0.25,0.25,0.25,0.25,0.25,0.334);
				}
				if (DDOrigCreature(source) || DDOrigCreature(inflictor))
				{
					base *= frandompick(1.667,2.0,2.0,2.0,2.0,2.5,2.5,2.5,2.5,3);
				}
				if (DDOrigBoss(source) || DDOrigBoss(inflictor))
				{
					base *= (frandompick(1.667,2.0,2.0,2.0,2.0,2.5,2.5,2.5,2.5,3) * frandompick(1.5,2.0));
				}
				double basef = base;
				if (SigilDrain)
				{
					base *= (1.0 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
					basef *= (0.334 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
				}
				A_AddIP(base, basef, true, true);
			}
		}
		
		if (ret)
		{
			int damagetakefactor = ret * 100 / MiscItem.MaxHealthTrue;
			MiscItem.HPHUDShakeType = 1;
			if (damagetakefactor >= 10) MiscItem.HPHUDShakeType = 2;
			if (damagetakefactor >= 50) MiscItem.HPHUDShakeType = 3;
			if (damagetakefactor >= 100) MiscItem.HPHUDShakeType = 4;
		}
		
		if (armdmg && armortier)
		{
			int armmax;
			if (armortier == 1) armmax = 250;
			if (armortier == 2) armmax = 500;
			if (armortier == 3) armmax = 1000;
			if (armortier == 4) armmax = 2000;
			if (armmax)
			{
				int damagetakefactor = armdmg * 100 / armmax;
				MiscItem.APHUDShakeType = 1;
				if (damagetakefactor >= 10) MiscItem.APHUDShakeType = 2;
				if (damagetakefactor >= 50) MiscItem.APHUDShakeType = 3;
				if (damagetakefactor >= 100) MiscItem.APHUDShakeType = 4;
			}
		}
		
		A_LossHUD(ret, 0, true);
		A_LossHUD(armdmg, 1, true);
		
		return ret;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (!player || !player.mo || player.mo != self)
		{
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PPawnVoodoo] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return true;
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PPawnVoodoo] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}
		else
		{
			// Non-passive means the one moving into the other is performing the checks.
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PlayerPawn] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [PlayerPawn] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
					return false;
				}
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PlayerPawn] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}

		// We don't really care about others making the check.
		return true;
	}
	
	void A_DDPain()
	{
		if (GetClassName() == "DinahPlayer")
		{
			double MaxHealthTrue = CountInv("PlayerMaxHP");
			if ((!player || !player.mo || player.mo != self) || !MaxHealthTrue) MaxHealthTrue = SpawnHealth();
			double HealthRatio = health / MaxHealthTrue;
			// Console.Printf("%.8f", HealthRatio);
			if (health > 0)
			{
				string painsnd = "";
				if (HealthRatio >= 0.751) painsnd = "Dinah/Pain1A";
				else if (HealthRatio >= 0.501 && HealthRatio < 0.750) painsnd = "Dinah/Pain2A";
				else if (HealthRatio >= 0.251 && HealthRatio <= 0.500) painsnd = "Dinah/Pain3A";
				else if (HealthRatio < 0.251) painsnd = "Dinah/Pain4A";
				A_StopSound(CHAN_VOICE);
				A_StartSound(painsnd,CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
			}
		}
	}
	
	int HasBuddha()
	{
		if (player.playerstate == PST_DEAD) return 0;
		if (player.cheats & CF_BUDDHA2) return 2;
		
		if ((player.cheats & CF_BUDDHA) ||
				(player.mo.bBUDDHA) ||
				 player.mo.FindInventory("PowerBuddha") != null) return 1;
		
		return 0;
	}
	
	const PPD_ALLOWPOWERFACTORS = 1;
	const PPD_ALLOWDAMAGEFACTORS = 2;
	const PPD_ALLOWSKILLDAMAGEFACTORS = 4;
	const PPD_POISONCANKILL = 8;
	const PPD_ALLOWAUTOHEALTH = 16;
	const PPD_ALLOWSTRIFEAUTOHEALTH = 32;
	
	void PlayerPoisonDamage(actor source, int damage, bool playPainSound, int PoisonFlags = 63, int PainInterval = 63)
	{
		bool allowpowerups, allowdmgfactors, allowskilldmgfactor, cankill, allowautohealth, allowstrifeautohealth;
		
		if (PoisonFlags & PPD_ALLOWPOWERFACTORS) allowpowerups = true;
		if (PoisonFlags & PPD_ALLOWDAMAGEFACTORS) allowdmgfactors = true;
		if (PoisonFlags & PPD_ALLOWSKILLDAMAGEFACTORS) allowskilldmgfactor = true;
		if (PoisonFlags & PPD_POISONCANKILL) cankill = true;
		if (PoisonFlags & PPD_ALLOWAUTOHEALTH) allowautohealth = true;
		if (PoisonFlags & PPD_ALLOWSTRIFEAUTOHEALTH) allowstrifeautohealth = true;
		
		actor target;
		
		if (player == null)
		{
			return;
		}
		target = player.mo;
		if (target.health <= 0)
		{
			return;
		}
		
		// This must be checked before any modifications. Otherwise, power amplifiers
		// may result in doing too much damage that cannot be negated by regular buddha,
		// which is inconsistent. The raw damage must be the only determining factor for
		// determining if telefrag is actually desired.
		bool telefragDamage = (damage >= TELEFRAG_DAMAGE && !(target.bLAXTELEFRAGDMG));
		
		if ((player.cheats & CF_GODMODE2) || (target.bNODAMAGE) || //These two are never subjected to telefrag thresholds.
			(!telefragDamage && ((target.bINVULNERABLE) || (player.cheats & CF_GODMODE))))
		{ // target is invulnerable
			return;
		}
		
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage (pre-factor): %d", damage);
		if (allowskilldmgfactor)
		{
			// Take half damage in trainer mode
			damage = int(damage * SKILLP_DamageFactor * sv_damagefactorplayer);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowskilldmgfactor - damage: %d", damage);
		}
		if (allowpowerups)
		{
			// Handle passive damage modifiers (e.g. PowerProtection)
			damage = target.GetModifiedDamage(player.poisontype, damage, true, null, source);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowpowerups - damage: %d", damage);
		}
		if (allowdmgfactors)
		{
			// Modify with damage factors
			damage = target.ApplyDamageFactor(player.poisontype, damage);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowdmgfactors - damage: %d", damage);
		}
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage (post-factor): %d", damage);
		
		if (damage <= 0)
		{ // Damage was reduced to 0, so don't bother further.
			return;
		}
		
		if (allowautohealth)
		{
			if (damage >= player.health
				&& (SKILLP_AutoUseHealth || deathmatch)
				&& !player.morphTics)
			{ // Try to use some inventory health
				AutoUseHealth(damage - player.health+1);
			}
		}
		player.health -= damage; // mirror mobj health here for Dave
		if (allowstrifeautohealth)
		{
			int threshold = 50;
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem) threshold = (MiscItem.MaxHealthTrue * 0.5);
			if (player.health < threshold && !deathmatch)
			{
				AutoUseStrifeHealth();
			}
		}
		
		int healthfloor;
		if (cankill) healthfloor = 0; else healthfloor = 1;
		
		if (player.health < healthfloor) player.health = healthfloor;
		
		player.attacker = source;
		
		//*****************
		//* do the damage *
		//*****************
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage: %d", damage);
		target.health -= damage;
		if (target.health < healthfloor) target.health = healthfloor;
		if (target.health <= 0)
		{ // Death
			int buddha = HasBuddha();
			if (telefragDamage && buddha == 1) buddha = 0;
			if (buddha)
			{ // [SP] Save the player... 
				player.health = target.health = 1;
			}
			else
			{
				target.special1 = damage;
				if (player && !player.morphTics)
				{ // Check for flame death
					if ((player.poisontype == 'Fire') && (target.health > -50) && (damage > 25))
					{
						target.DamageType = 'Fire';
					}
					else
					{
						target.DamageType = player.poisontype;
					}
				}
				target.Die(source, source);
				return;
			}
		}
		if (PainInterval <= 0) PainInterval = 63;
		int PoisonTargInv = randompick(4,5,5,5,5,5,6);
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) PoisonTargInv -= randompick(0,1,1,1,1,1,1,1,1,1,1,1,1,2);
		int targtime = target.level.time & 63; // target.level.time % PainInterval;
		if (playPainSound)
		{
			bool PainSnd = false;
			if (!(targtime & 63))
			{
				PainSnd = true;
			}
			else
			{
				PoisonDmgPainInt++;
			}
			if (PoisonDmgPainInt >= PoisonTargInv) 
			{
				PainSnd = true;
				PoisonDmgPainInt = 0;
			}
			
			if (PainSnd)
			{
				state painstate = target.FindState("Pain", player.poisonpaintype);
				if (painstate != null) target.SetState(painstate);
			}
			if (dydudebug_playerpoisondisplays) Console.Printf("targtime: %d / %d, PoisonDmgPainInt: %d / %d", targtime, PainInterval, PoisonDmgPainInt, PoisonTargInv);
		}
	}
	
	override void CheckPoison()
	{
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		int countdec = randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7);
		int countint = randompick(14,15,15,15,15,15,15,15,15,15);
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD"))
		{
			countdec = (randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7) - randompick(0,1,1,1,1,1,1,1,1,2));
			countint = randompick(13,13,13,14,14,14,14,14,14,15);
		}
		let player = self.player;
		let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
		if (player.poisoncount && !(Level.maptime & countint))
		{
			player.poisoncount -= countdec;
			if (player.poisoncount < 0) player.poisoncount = 0;
			if (dydudebug_playerpoisondisplays) Console.Printf("poisoncount: %d [\c[green]-%d\c-]", player.poisoncount, countdec);

			if (!(bINVULNERABLE ||
						CountInv("PowerInvulnerable") ||
						CountInv("PowerInvulnDD") ||
						player.cheats & CF_GODMODE2 ||
						player.cheats & CF_GODMODE))
			{
				int poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) 
				{
					poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3);
					poisdmg *= frandompick(1.25,1.375,1.375,1.5,1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
				}
				if (MiscItem) 
				{
					poisdmg = ((randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3) * 0.01) * MiscItem.MaxHealthTrue);
					if (poisdmg < 1) poisdmg = 1;
				}
				if (poisdmg > 0 && health > poisdmg)
				{
					int PainInterval = (63 - (player.poisoncount / randompick(4,5,5,5,5,6)));
					if (PainInterval < 15) PainInterval = 15;
					if (random(1,4) <= 1) 
					{
						if (random(1,8) <= 1) PainInterval *= 0.25;
														 else PainInterval *= 0.5;
					}
					PlayerPoisonDamage(player.poisoner, poisdmg, true, PPD_ALLOWAUTOHEALTH|PPD_ALLOWSTRIFEAUTOHEALTH, PainInterval);
					//player.PoisonDamage(player.poisoner, poisdmg, true);
					
					A_LossHUD(poisdmg, 0, true);
					if (exex_playerdmglog)
					{
						string combatlogmsg = "\c[sapphire]*\c- Took";
						combatlogmsg.AppendFormat(" \c[darkred]%d damage\c-", poisdmg);
						combatlogmsg.AppendFormat(" from poisoning!");
						if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
						Console.Printf(combatlogmsg);
					}

					let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
					let globalvars = DDGlobalVariables.Get();
					// Item/Ikari Point Gains
					if (exex_ikaripointsenabled && poisdmg && MiscItem && globalvars && health > 0)
					{
						if (MiscItem.IPNoGainTimer <= 0)
						{
							double base;
							// The mod's first and original formula
							if (exex_ikaripointscalctype <= 0)
							{
								base = poisdmg * 100.0 / MiscItem.MaxHealthTrue;
								if (oldhealthratio == 0) base *= 1.0;
								if (oldhealthratio == 1) base *= 1.125;
								if (oldhealthratio == 2) base *= 1.25;
								if (oldhealthratio == 3) base *= 1.5;
								if (oldhealthratio == 4) base *= 2.25;
								if (oldhealth > 1 && health == 1) base *= 3.25;
								if (MiscItem.PlayerLUCK) base *= (0.125 + (MiscItem.PlayerLevel * 0.00125) + (random(1,MiscItem.PlayerLUCK) * frandompick(0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.001,0.001,0.001,0.001,0.001,0.001,0.002,0.002,0.002,0.002,0.003,0.003)));
																		else base *= (0.125 + (MiscItem.PlayerLevel * 0.00125));
								
							}
							// The more Lufia II equse formula
							if (exex_ikaripointscalctype >= 0)
							{
								base = poisdmg * 100.0 / oldhealth; // % of remaining HP removed
								if (base >= 0.001)
								{
									if (base >= 0.001 && base <= 50.000) base *= 0.50; // <= 50% equals half of the percent in IP points given [up to 25%]
									if (base >= 50.001 && base <= 65.000) base *= 0.558077; 
									if (base >= 65.001 && base <= 75.000) base *= 0.646154;
									if (base >= 75.001 && base <= 85.000) base *= 0.76; 
									if (base >= 85.001 && base <= 90.000) base *= 0.90; 
									if (base >= 90.001 && base <= 100.000) base *= 1.00; 
									if (base >= 100.001) base *= 1.25;
									if (oldhealth > 1 && health == 1) base += MiscItem.MaxItemPoints;
								}
							}
							base *= (frandompick(3.0,4.0,4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0,6.0,7.0) * 0.5);
							double basef = base;
							A_AddIP(base, basef, true, true);
						}
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("poisoncount: %d (maptime: %d)", player.poisoncount, Level.maptime);
			}
		}
	}
}

class DinahPlayer : DDPlayerPawn // HereticPlayer
{
	int breathtic;
	default
	{
		Player.DisplayName "Dinah Wyck";
		Player.SoundClass "DinahPlayer";
		Player.StartItem "PlayerStatItem";
		//Player.StartItem "DynamicMusic";
		Player.StartItem "PlayerDashJump";
		Player.StartItem "ResetInventory";
		Player.StartItem "CricketBat";
		Player.StartItem "HandToHand";
		Player.StartItem "MalletAmmo", 10;
		Player.Weaponslot 1, "HandToHand";
		Player.Weaponslot 2, "CricketBat";
		Player.Weaponslot 3, "Blundaxe", "Scrambler";
		Player.Weaponslot 4, "AppleJack";
		Player.Weaponslot 5, "WizardPike";
		Player.Weaponslot 6, "SuperVac";
		Player.Weaponslot 7, "Grimophone";
		Player.WeaponSlot 8, "SigilDD", "CandleWhip";
		Player.WeaponSlot 9, "CrazyBallDD";
		Player.ForwardMove 0.75, 0.75; // 0.75
		Player.SideMove 0.65, 0.65; // 0.65
		Player.ViewBob 0.5;
		Player.AttackZOffset 8;
		Player.AirCapacity 1;
		Player.JumpZ 9;
		//Player.GruntSpeed 12;
		Player.ViewHeight 36;
		Player.InvulnerabilityMode "Reflective";
		Species "Players";
		Health 80; // 100
		Player.MaxHealth 80;
		Player.MugShotMaxHealth -1; // 100
		XScale 1.0; //0.8572;
		YScale 0.95; //0.8572;
		Mass 60;
		Height 48; // Slightly Shorter than Flora in Aetherius
		Radius 12; // Dinah is actually SLIGHTLY thinner than even Flora is in Aetherius
		Tag "Dinah Wyck";
		+NOBLOOD
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}
	
	override void Tick()
	{
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
		
		if (InStateSequence(curstate,ResolveState("Death")) ||
				InStateSequence(curstate,ResolveState("XDeath")) ||
				InStateSequence(curstate,ResolveState("Burn")) ||
				InStateSequence(curstate,ResolveState("Ice")))
		{
			A_APPBreatheReset();
		}
		else
		{
			breathtic++;
			if (breathtic >= 4)
			{
				A_APPBreathe();
				breathtic = 0;
			}
		}
	}

	States
	{
		Spawn:
			DINA A 4
			{
			}
			Loop;
		See:
			DINA BCDE 4
			{
				tics = 4;
				let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
				if (MiscItem)
				{
					if (MiscItem.HUDSpeed >= 2.25) tics = ceil(tics *= 0.875);
					if (MiscItem.HUDSpeed >= 1.5) tics = ceil(tics *= 0.9375);
					if (MiscItem.HUDSpeed <= 0.667) tics = ceil(tics *= 1.25);
					if (MiscItem.HUDSpeed <= 0.334) tics = ceil(tics *= 1.5);
				}
				if (CountInv("PowerWineBuffIPWeak")) tics = ceil(tics *= 1.032258064516129);
				if (CountInv("PowerWineBuffIPStrong")) tics = ceil(tics *= 1.066666666666667);
				if (CountInv("PowerWineBuffIPStrongest")) tics = ceil(tics *= 1.103448275862069);
				if (CountInv("PowerWineBuffIPStrongestEven")) tics = ceil(tics *= 1.142857142857143);
				if (CountInv("PowerWineBuffIPMaximum")) tics = ceil(tics *= 1.230769230769231);
				if (CountInv("PowerWineBuffWeak")) tics = ceil(tics *= 1.142857142857143);
				if (CountInv("PowerWineBuffStrong")) tics = ceil(tics *= 1.333333333333333);
				if (CountInv("PowerWineBuffStrongest")) tics = ceil(tics *= 1.6);
				if (CountInv("PowerWineBuffStrongestEven")) tics = ceil(tics *= 2.0);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tics = ceil(tics *= 0.875);
				if (CountInv("OverFullHealth3")) tics = ceil(tics *= 0.85);
				if (CountInv("OverFullHealth2")) tics = ceil(tics *= 0.9);
				if (CountInv("OverFullHealth1")) tics = ceil(tics *= 0.95);
				if (CountInv("NormalHealth")) tics = ceil(tics *= 1);
				if (CountInv("DecentHealth")) tics = ceil(tics *= 1.125);
				if (CountInv("LowHealth")) tics = ceil(tics *= 1.25);
				if (CountInv("CriticalHealth")) tics = ceil(tics *= 1.375);
				
				if (dydudebug_playerwalkdisplays) Console.Printf("Tics (See): %d", tics);
				if (tics < 1) tics = 1;
				A_SetTics(tics);
			}
			Loop;
		Pain:
			DINA H 6 
			{
				A_DDPain();
			}
			Goto Spawn;
		Missile:
			DINA FG 6
			{
			}
			Goto Spawn;
		Melee:
			DINA FGF 4
			{
			}
			Goto Spawn;
		BatGuard:
			DINA LL 1
			{
			}
			DINA L 0
			{
			}
			Goto Spawn;
		SpinAttackBatPre:
			DINA FF 1
			{
			}
			DINA F 0
			{
			}
			Goto Spawn;
		SpinAttackBat:
			DINA GG 1
			{
			}
			DINA G 0
			{
			}
			Goto Spawn;
		Kick:
			DINA FF 1
			{
				A_SetInventory("PKicking",1);
			}
			DINA F 0
			{
				A_SetInventory("PKicking",0);
			}
			Goto Spawn;
		Kick2:
			DINA GG 1
			{
				A_SetInventory("PKicking",1);
			}
			DINA G 0
			{
				A_SetInventory("PKicking",0);
			}
			Goto Spawn;
		Death:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		XDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinXDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		Burn:
			goto Death;
		Ice:
			goto Death;
  }
}

class RavenPlayer : DDPlayerPawn
{
	default
	{
		Player.DisplayName "Dinah Wyck [Raven Form]";
		Tag "Dinah Wyck [Raven Form]";
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 16;
		Height 32;
		Speed 0.5;
		+NoSkin
		-PickUp
		+NoTarget
		Player.Viewheight 32;
		Player.DisplayName "Raven";
		Player.MorphWeapon "RavenWeapon";
	}
	States
	{
		Spawn:
			RVPL A 0;
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		See:
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		Pain:
			RVPL C 4 A_Pain;
			Goto Spawn;
		Death:
			TNT1 A -1;
			Stop;
	}
}

class RatPlayer : DDPlayerPawn
{
	default
	{
		Player.DisplayName "Dinah Wyck [Rat Form]";
		Tag "Dinah Wyck [Rat Form]";
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 10;
		Height 20;
		Speed 1;
		+NOSKIN
		-PICKUP
		PainSound "Rat/Pain";
		DeathSound "Rat/Death";
		Player.JumpZ 3;
		Player.Viewheight 18;
		Player.ForwardMove 0.75, 0.75;
		Player.SideMove 0.65, 0.65;
		Player.SpawnClass "Rat";
		Player.SoundClass "Rat";
		Player.DisplayName "Rat";
		Player.MorphWeapon "RatNose";
	}
	
	States
	{
		Spawn:
			RATS A 0 A_StopSound(5);
			RATS A -1;
			Stop;
		See:
			RATS ABC 3;
			Loop;
		Melee:
		Missile:
			RATS B 8;
			RATS A 8;
			Goto Spawn;
		Pain:
			RATS C 4 A_Pain();
			Goto Spawn;
		Death:
			RATS D 6 A_Scream();
			RATS E 6 A_NoBlocking();
			RATS F 6;
			TNT1 A 1 A_CheckPlayerDone();
			Wait;
	}
}
