class ClassID : Inventory
{
	default
	{
		Inventory.MaxAmount 1;
	}
}

class DDPlayerPawn : PlayerPawn
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	int TrueGameSkill;
	double airreplen, airreplentimer;
	double ArmorEnc, TempArmorEnc;
	int damagecntfrag;
	int mobjdmg;
	int playoutputdmg;
	int playtookdamage;
	
	bool wasongroundprevtic, wasongroundcurrtic;
	double PlayerDefenseIgnoreFactor, PlayerArmorIgnoreFactor, PlayerArmorIgnoreFactorGeneral;
	int ActualLevel;
	int TruePlayerLevel;
	int TruePlayerATK;
	int TruePlayerDEF;
	int TruePlayerSPD;
	
	int CLWater;
	
	int dimtimer;
	
	actor DmgSource;
	actor DmgInflictor;
	int DmgFlags;
	bool tookflrdmg;
	
	mixin HUDRecovery;
	mixin DynMusicControl;
	mixin TimerCheck;
	bool IPAttack;
	bool takendrowndmg;
	bool willgasp;
	
	int PoisonDmgPainInt;
	int AirTime, MaxAirTime;
	int InWaterTime;
	
	int ipmodecooldowntimer;
	bool isvoodoodoll;
	int neverbleeds;
	bool recalledall;
	int ipchargesoundtimer;
	double truespeed;
	int armortier;
	int IPLoopTimer;
	int beattimer;
	int beatpulse, hudbeatpulse;
	
	int lasthealth;
	int breathdirection; // 0 = down [size decreases], 1 = up [size increases]
	int breathframe;
	
	int DashTimer; int MaxDashTimer; 
	int cooldash; bool sounddash; 
	int thrudash; bool isdashing;
	double floordashvel, airdashvel, dashjumpstrength;
	double dashvelx, dashvely, dashvelz;

	int dashcooldown;
	int dashcooldownmax;
	
	int deadtimer;
	int fadetime;
	int originalheight;
	int originalradius;
	int originalmass;

	int firsttic;
	int buttons, input;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	mixin IPCostCheck;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	bool hasDied;
	bool clinicstart;
	
	Vector3 spot;
	Double lastAngle;
	
	int deathsongused;
	int deathtimerthres1;
	int deathtimerthres2;
	int deathtimerthres3;
	int deathtimerthres4;
	int deathfadetimebase;
	int deathtimer;
	int deathtimer_b;
	int revivebeattimer;
	
	Array<Name> weapons;
	Array<Name> ammos;
	Array<int> ammosamt;
	Array<Name> invitems;
	Array<Int> invitemsamt;
	
	bool revived;
	
	int whitehot;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
		//RenderStyle "Add";
		//Alpha 1.0;
	}
	
	void A_CheckDeathHeartBeats(int hbtimer)
	{
		if (exex_playerbpm)
		{
			double bmpbasevol = 1.00;
			int beat1 = 18; //18
			int beat2 = 42; //24
			int beat3 = 72; //30
			int beat4 = 108; //36
			int beat5 = 150; //42
			int beat6 = 198; //48
			int beat7 = 252; //54
			int beat8 = 312; //60
			int beat9 = 378; //66
			int beat10 = 450; //72
			double beat1vol = 0.95;
			double beat2vol = 0.85;
			double beat3vol = 0.75;
			double beat4vol = 0.65;
			double beat5vol = 0.55;
			double beat6vol = 0.45;
			double beat7vol = 0.35;
			double beat8vol = 0.25;
			double beat9vol = 0.15;
			double beat10vol = 0.05;
			// Fading Heartbeats when dead
			if (hbtimer == (beat1-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat2-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat3-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat4-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat5-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat6-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat7-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat8-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat9-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat10-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (dydudebug_deathtimerdisplays) Console.Printf("HBTimer [dead]: %d", hbtimer);
		}
	}

	void A_CheckReviveHeartBeats(int hbtimer)
	{
		if (exex_playerbpm)
		{
			double bmpbasevol = 1.00;
			int beat1 = 18; //18
			int beat2 = 42; //24
			int beat3 = 72; //30
			int beat4 = 108; //36
			int beat5 = 150; //42
			int beat6 = 198; //48
			int beat7 = 252; //54
			int beat8 = 312; //60
			int beat9 = 378; //66
			int beat10 = 450; //72
			double beat1vol = 0.05;
			double beat2vol = 0.15;
			double beat3vol = 0.25;
			double beat4vol = 0.35;
			double beat5vol = 0.45;
			double beat6vol = 0.55;
			double beat7vol = 0.65;
			double beat8vol = 0.75;
			double beat9vol = 0.85;
			double beat10vol = 0.95;
			// Gradually louder Heartbeats when reviving
			if (hbtimer == (beat1-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat1+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat1vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat2-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat2+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat2vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat3-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat3+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat3vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat4-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat4+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat4vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat5-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat5+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat5vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat6-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat6+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat6vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat7-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat7+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat7vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat8-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat8+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat8vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat9-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat9+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat9vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (hbtimer == (beat10-1)) A_StartSound("heartb2",134,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10)) A_StartSound("heartb2",135,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			if (hbtimer == (beat10+1)) A_StartSound("heartb2",136,CHANF_DEFAULT,(beat10vol*bmpbasevol),ATTN_NORM,1.0);
			
			if (dydudebug_deathtimerdisplays) Console.Printf("HBTimer [reviving]: %d", hbtimer);
		}
	}

	int A_CheckActualLevel(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - DDPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	bool A_CheckUOHYM()
	{
		bool UOHYM = false;
		if (Wads.CheckNumForName("EE-UOHYM", Wads.ns_global, -1, true) != -1) UOHYM = true;
		return UOHYM;
	}
	
	override void CheatGive(String name, int amount)
	{
		// empty
		// or you can add custom code here.
		//if (A_CheckUOHYM()) { } else 
		super.CheatGive(name, amount); // use this to call the original function
	}
	
	override void PlayerLandedMakeGruntSound(actor onmobj)
	{
		bool grunted;

		// [RH] only make noise if alive
		if (self.health > 0 && 
				self.player.morphTics == 0)
		{
			bool skip = false;
			if (A_CheckUOHYM() && texman.GetName(self.floorpic) == "GRAY11") { skip = true; return; }
			if (!skip)
			{
				grunted = false;
				// Why should this number vary by gravity?
				double truegruntspeed = self.player.mo.GruntSpeed;
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) truegruntspeed *= 1.34;
				//Console.Printf("%.8f (%.8f) [%.8f]", self.Vel.Z, truegruntspeed, self.player.mo.GruntSpeed);
				if (waterlevel <= 1)
				{
					if (self.Vel.Z < -truegruntspeed)
					{
						A_StartSound("*grunt", CHAN_VOICE);
						grunted = true;
					}
					bool isliquid = (pos.Z <= floorz) && HitFloor();
					bool foundstpsnd;
					/*
					if (onmobj) Console.Printf("%p [%s]", onmobj, onmobj.GetClassName());
					Console.Printf("isliquid");
					Console.Printf("player.onground: %d", player.onground);
					*/
					if (onmobj != NULL || !isliquid)
					{
						if (onmobj == NULL && !isliquid)
						{
							ThinkerIterator FStepFinder = ThinkerIterator.Create("EVP_Footsteps");
							EVP_Footsteps mo;
							while (mo = EVP_Footsteps(FStepFinder.Next()))
							{
								mo.HandleFootsteps(1,false); // Landing
								foundstpsnd = true;
								break;
							}
							
							double volmult = 1.00;
							if (foundstpsnd) volmult *= frandom(0.4,0.6);
							A_StartSound("*land", 811, CHANF_DEFAULT, volmult);
						}
					}
				}
			}
		}
	}

	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;

		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}

	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (dydudebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}
		
		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	
	/*
	==================
	=
	= P_CalcHeight
	=
	=
	Calculate the walking / running height adjustment
	=
	==================
	*/

	override void CalcHeight()
	{
		let player = self.player;
		double angle;
		double bob;
		bool still = false;

		// Regular movement bobbing
		// (needs to be calculated for gun swing even if not on ground)

		// killough 10/98: Make bobbing depend only on player-applied motion.
		//
		// Note: don't reduce bobbing here if on ice: if you reduce bobbing here,
		// it causes bobbing jerkiness when the player moves from ice to non-ice,
		// and vice-versa.

		if (player.cheats & CF_NOCLIP2)
		{
			player.bob = 0;
		}
		else if (bNoGravity && !player.onground)
		{
			player.bob = 0.5;
		}
		else
		{
			player.bob = player.Vel dot player.Vel;
			if (player.bob == 0)
			{
				still = true;
			}
			else
			{
				player.bob *= player.GetMoveBob();

				if (player.bob > MAXBOB)
					player.bob = MAXBOB;
			}
		}

		double defaultviewheight = ViewHeight + player.crouchviewdelta;
		if (A_CheckUOHYM())
		{
			if (level.mapname == "MAP01" ||
					level.mapname == "20PAM" ||
					level.mapname == "MAP02")
			{
				if (player.health > 0) defaultviewheight *= 1.166666666666667;
			}
		}

		if (player.cheats & CF_NOVELOCITY)
		{
			player.viewz = pos.Z + defaultviewheight;

			if (player.viewz > ceilingz-4)
				player.viewz = ceilingz-4;

			return;
		}

		if (still)
		{
			if (player.health > 0)
			{
				angle = Level.maptime / (120 * TICRATE / 35.) * 360.;
				bob = player.GetStillBob() * sin(angle);
			}
			else
			{
				bob = 0;
			}
		}
		else
		{
			angle = Level.maptime / (20 * TICRATE / 35.) * 360.;
			bob = player.bob * sin(angle) * (waterlevel > 1 ? 0.25f : 0.5f);
		}

		// move viewheight
		if (player.playerstate == PST_LIVE)
		{
			player.viewheight += player.deltaviewheight;

			if (player.viewheight > defaultviewheight)
			{
				player.viewheight = defaultviewheight;
				player.deltaviewheight = 0;
			}
			else if (player.viewheight < (defaultviewheight/2))
			{
				player.viewheight = defaultviewheight/2;
				if (player.deltaviewheight <= 0)
					player.deltaviewheight = 1 / 65536.;
			}
			
			if (player.deltaviewheight)	
			{
				player.deltaviewheight += 0.25;
				if (!player.deltaviewheight)
					player.deltaviewheight = 1/65536.;
			}
		}

		if (player.morphTics)
		{
			bob = 0;
		}
		player.viewz = pos.Z + player.viewheight + (bob * clamp(ViewBob, 0. , 1.5)); // [SP] Allow DECORATE changes to view bobbing speed.
		if (Floorclip && player.playerstate != PST_DEAD
			&& pos.Z <= floorz)
		{
			player.viewz -= Floorclip;
		}
		if (player.viewz > ceilingz - 4)
		{
			player.viewz = ceilingz - 4;
		}
		if (player.viewz < floorz + 4)
		{
			player.viewz = floorz + 4;
		}
	}
	
	void DepositAllStuff()
	{
		weapons.clear();
		ammos.clear();
		invitems.clear();
		invitemsamt.clear();
		
		DepositWeapon('CricketBat');
		DepositAmmo('MalletAmmo');
		DepositWeapon('BlunderAxe');
		DepositAmmo('BlunderAmmo');
		DepositWeapon('Scrambler');
		DepositAmmo('EggAmmo');
		DepositWeapon('AppleJack');
		DepositAmmo('JackAmmo');
		DepositWeapon('WizardPike');
		DepositWeapon('EvilWarriorShield');
		DepositAmmo('PikeAmmo');
		DepositWeapon('SuperVac');
		DepositAmmo('VacAmmo');
		DepositWeapon('Grimophone');
		DepositAmmo('MusicAmmo');
		DepositWeapon('CandleWhip');
		DepositAmmo('CandleAmmo');
		DepositWeapon('FosnianCandle');
		DepositAmmo('FCandleAmmo');
		DepositWeapon('CrazyBallDD');
		DepositAmmo('CzBall');
		DepositWeapon('SigilDD');
		
		DepositInvItem('FCandlePickup');
		DepositInvItem('PortalSatchel');
		DepositInvItem('TurkeyDinner');
		DepositInvItem('AppleWine');
		DepositInvItem('CherryBombPickup');
		DepositInvItem('SpinnerPickup');
		DepositInvItem('BRocketPickup');
		DepositInvItem('PopperPickup');
		DepositInvItem('SnakePickup');
		DepositInvItem('BirdPotion');
		DepositInvItem('TimePotion');
		DepositInvItem('FuryPotion');
		DepositInvItem('DivingHelm');
		DepositInvItem('PalaceKeyNew');
		DepositInvItem('DoorBell');
		DepositInvItem('RatPotion');
		DepositInvItem('AfasDrop');
		DepositInvItem('LegendaryMedicine');
		DepositInvItem('StrangeCrystalBall');
		DepositInvItem('BowlingBallPickup');
	}
	void DepositWeapon(name weap)
	{
		if (self.findInventory(weap))
		{
			weapons.push(weap); // weapons.push(Int(weap));
			self.takeInventory(weap, 1);
		}
	}
	
	void DepositAmmo(name ammo)
	{
		if (self.findInventory(ammo))
		{
			ammos.push(ammo); // ammos.push(Int(ammo));
			ammosamt.push(CountInv(ammo));
			self.SetInventory(ammo, 0);
		}
	}
	
	void DepositInvItem(name invi)
	{
		if (self.findInventory(invi))
		{
			invitems.push(invi); // invitems.push(Int(invi));
			invitemsamt.push(CountInv(invi));
			self.takeInventory(invi, CountInv(invi));
		}
	}
	
	//==========================================================================
	//
	// P_DeathThink
	//
	//==========================================================================
	
	override void DeathThink()
	{
		let player = self.player;
		int dir;
		double delta;

		player.Uncrouch();
		TickPSprites();

		player.onground = (pos.Z <= floorz);
		if (self is "PlayerChunk")
		{ // Flying bloody skull or flying ice chunk
			player.viewheight = 6;
			player.deltaviewheight = 0;
			if (player.onground)
			{
				if (Pitch > -19.)
				{
					double lookDelta = (-19. - Pitch) / 8;
					Pitch += lookDelta;
				}
			}
		}
		else if (!bIceCorpse)
		{ // Fall to ground (if not frozen)
			player.deltaviewheight = 0;
			if (player.viewheight > 6)
			{
				player.viewheight -= 1;
			}
			if (player.viewheight < 6)
			{
				player.viewheight = 6;
			}
			if (Pitch < 0)
			{
				Pitch += 3;
			}
			else if (Pitch > 0)
			{
				Pitch -= 3;
			}
			if (abs(Pitch) < 3)
			{
				Pitch = 0.;
			}
		}
		player.mo.CalcHeight ();
			
		if (player.attacker && player.attacker != self)
		{ // Watch killer
			double diff = deltaangle(angle, AngleTo(player.attacker));
			double delta = abs(diff);
	
			if (delta < 10)
			{ // Looking at killer, so fade damage and poison counters
				if (player.damagecount)
				{
					player.damagecount--;
				}
				if (player.poisoncount)
				{
					player.poisoncount--;
				}
			}
			delta /= 8;
			Angle += clamp(diff, -5., 5.);
		}
		else
		{
			if (player.damagecount)
			{
				player.damagecount--;
			}
			if (player.poisoncount)
			{
				player.poisoncount--;
			}
		}		

		if ((player.cmd.buttons & BT_USE ||
			((deathmatch || alwaysapplydmflags) && sv_forcerespawn)) && !sv_norespawn)
		{
			if (Level.maptime >= player.respawn_time || ((player.cmd.buttons & BT_USE) && player.Bot == NULL))
			{
				player.cls = NULL;		// Force a new class if the player is using a random class
				player.playerstate = (multiplayer || level.AllowRespawn || sv_singleplayerrespawn || G_SkillPropertyInt(SKILLP_PlayerRespawn)) ? PST_REBORN : PST_ENTER;
				if (special1 > 2)
				{
					special1 = 0;
				}
			}
		}
		
		if (A_CheckUOHYM() && 
				level.mapname == "MAP01" &&
				!(CountInv("UOHInCL") || CountInv("UOHInBR")))
		{
			if (health < 0) health = 0;
			double speed = sqrt((vel.x * vel.x) + (vel.y * vel.y) + (vel.z * vel.z));
			if (speed <= 0) 
			{
				clinicstart = true;
				spot = self.pos;
				lastAngle = self.angle;
			}
		
			if (!clinicstart ||
					 hasDied ||
					 self.curSector.special == 115)
			{
			}
			else
			{
				if (deathtimer <= 0) ++deathTimer;
				
				if (deathtimer > deathtimerthres1 && deathtimer < deathtimerthres2) 
				{
					++deathtimer_b;
					if (!self.findInventory('FadeToken'))
					{
						if (deathfadetimebase > 0) SetMusicVolume(1.0 - double(deathtimer_b / double(deathfadetimebase)));
					}
					if (dydudebug_deathtimerdisplays) Console.Printf("[processing] UOHYMTimer: %d, UOHYMTimer_b: %d", deathTimer, deathTimer_b);
				}
				else
				{
					if (dydudebug_deathtimerdisplays) Console.Printf("[dying] UOHYMTimer: %d, UOHYMTimer_b: %d", deathTimer, deathTimer_b);
					A_CheckDeathHeartBeats(deathTimer);
				}
				
				if (deathtimer > deathtimerthres2)
				{
					self.player.resurrect();
					deathsongused = 0;
					Teleport_NoFog(1964, 1, 0);
					ACS_NamedExecute("CheckHospital",0,0,0,0);
					self.player.cheats |= CF_TotallyFrozen;
					revived = true;
					
					DepositAllStuff();
				}
			}
		}
	}
	
	//===========================================================================
	//
	// PlayerPawn :: Die
	//
	//===========================================================================
	
	override void Die (Actor source, Actor inflictor, int dmgflags, Name MeansOfDeath)
	{
		Super.Die (source, inflictor, dmgflags, MeansOfDeath);

		if (player != NULL && player.mo == self) player.bonuscount = 0;

		if (player != NULL && player.mo != self)
		{ // Make the real player die, too
			player.mo.Die (source, inflictor, dmgflags, MeansOfDeath);
		}
		else
		{
			if (player != NULL && sv_weapondrop)
			{ // Voodoo dolls don't drop weapons
				let weap = player.ReadyWeapon;
				if (weap != NULL)
				{
					// kgDROP - start - modified copy from a_action.cpp
					let di = weap.GetDropItems();

					if (di != NULL)
					{
						while (di != NULL)
						{
							if (di.Name != 'None')
							{
								class<Actor> ti = di.Name;
								if (ti) A_DropItem (ti, di.Amount, di.Probability);
							}
							di = di.Next;
						}
					} 
					else if (weap.SpawnState != NULL &&
						weap.SpawnState != GetDefaultByType('Actor').SpawnState)
					{
						let weapitem = Weapon(A_DropItem (weap.GetClass(), -1, 256));
						if (weapitem)
						{
							if (weap.AmmoGive1 && weap.Ammo1)
							{
								weapitem.AmmoGive1 = weap.Ammo1.Amount;
							}
							if (weap.AmmoGive2 && weap.Ammo2)
							{
								weapitem.AmmoGive2 = weap.Ammo2.Amount;
							}
							weapitem.bIgnoreSkill = true;
						}
					}
					else
					{
						let item = Inventory(A_DropItem (weap.AmmoType1, -1, 256));
						if (item != NULL)
						{
							item.Amount = weap.Ammo1.Amount;
							item.bIgnoreSkill = true;
						}
						item = Inventory(A_DropItem (weap.AmmoType2, -1, 256));
						if (item != NULL)
						{
							item.Amount = weap.Ammo2.Amount;
							item.bIgnoreSkill = true;
						}
					}
				}
			}
			if (!multiplayer && level.deathsequence != 'None')
			{
				level.StartIntermission(level.deathsequence, FSTATE_EndingGame);
			}
		}
	}
	
	void ForwardThrust (double move, double angle)
	{
		if ((waterlevel || bNoGravity) && Pitch != 0 && !player.GetClassicFlight())
		{
			double zpush = move * sin(Pitch);
			if (waterlevel && waterlevel < 2 && zpush < 0) zpush = 0;
			Vel.Z -= zpush;
			move *= cos(Pitch);
		}
		Thrust(move, angle);
	}
	
	override bool ResetAirSupply(bool playgasp)
	{
		let player = self.player;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		
		bool wasdrowning;
		if (AirTime <= 0) 
		{
			wasdrowning = true;
			AirTime = 0;
			if (dydudebug_airmeter == 1) Console.Printf("wasdrowning");
		}
		
		if (AirTime < MaxAirTime)
		{
			if (ddafd_underwatercompat && 
					(CountInv("IsDynDuchess") || 
					 CountInv("IsAppetite") || 
					 CountInv("IsCarnOfSouls") || 
					 CountInv("IsWeddingCake")))
			{
				if (AirTime != MaxAirTime) AirTime = MaxAirTime;
			}
			else
			{
				if (MaxAirTime > 0) airreplen = ((MaxAirTime / (TICRATE * 5.0)) * 100.0);
				if (airreplen < 1) airreplen = 1;
				if (MiscItem) airreplen *= (1.0 + (ActualLevel * 0.0125));
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) airreplen *= 1.25;
				if (CountInv("PowerNoDrown") || CountInv("PowerIronFeet") || CountInv("PowerIronFeet2") || CountInv("PowerMask")) airreplen *= 1.625;
				double ssa = 1.00;
				if (CountInv("ExpeditionHat")) ssa += 2.00;
				if (CountInv("ClassyRibbon")) ssa += 1.00;
				airreplen *= ssa;
				if (MiscItem)
				{
					if (!exex_expenabled)
					{
						double DDTFactor = 0.0;
						if (CountInv("IsDynDuchess") || 
								CountInv("IsAppetite") || 
								CountInv("IsCarnOfSouls") || 
								CountInv("IsWeddingCake"))
						{
							if (MiscItem.DD_RoseMother) DDTFactor += 0.01875;
							if (MiscItem.DD_GameMother) DDTFactor += 0.01875;
							if (MiscItem.DD_MossMother) DDTFactor += 0.01875;
							if (MiscItem.DD_GlobeMother) DDTFactor += 0.01875;
							if (MiscItem.DD_SphinxMother) DDTFactor += 0.01875;
							if (MiscItem.DD_HandMother1) DDTFactor += 0.01875;
							if (MiscItem.DD_HandMother2) DDTFactor += 0.01875;
							if (MiscItem.DD_TrueHandMother) DDTFactor += 0.01875;
							if (MiscItem.AFD_Krag) DDTFactor += 0.025;
							if (MiscItem.AFD_Quisling) DDTFactor += 0.025;
							if (MiscItem.AFD_Lauritz) DDTFactor += 0.025;
							if (MiscItem.AFD_Jorgensen1) DDTFactor += 0.025;
							if (MiscItem.AFD_Jorgensen2) DDTFactor += 0.025;
							if (MiscItem.AFD_JorgCannon) DDTFactor += 0.025;
							if (MiscItem.CoS_Fafnir) DDTFactor += 0.025;
							if (MiscItem.CoS_FractalHens) DDTFactor += 0.025;
							if (MiscItem.CoS_HandMothers) DDTFactor += 0.025;
							if (MiscItem.CoS_ForsakenJorg) DDTFactor += 0.025;
							if (MiscItem.CoS_EvilDinah) DDTFactor += 0.025;
							if (MiscItem.CoS_Tempest) DDTFactor += 0.025;
							if (TrueGameSkill <= SKILL_VERY_EASY)	DDTFactor *= 4.0;
							if (TrueGameSkill == SKILL_EASY)			DDTFactor *= 3.5;
							if (TrueGameSkill == SKILL_NORMAL)		DDTFactor *= 3.0;
							if (TrueGameSkill == SKILL_HARD)			DDTFactor *= 2.5;
							if (TrueGameSkill >= SKILL_VERY_HARD)	DDTFactor *= 2.0;
							DDTFactor *= exex_nrpggeneraleffect;
							DDTFactor += 1.0;
							if (dydudebug_airmeter >= 1) Console.Printf("DDTFactor [airreplen]: %.8f", DDTFactor);
							DDTFactor = int(floor(DDTFactor));
							airreplen *= DDTFactor;
						}
					}
					if (MiscItem.drowndebufflevel)
					{
						airreplen *= (1.00 - (MiscItem.drowndebufflevel * frandompick(0.5,0.0625,0.0625,0.75,0.75,0.75,0.75,0.75,0.875,0.875,0.875,1.0)));
						if (airreplen < 1 && random(1,16) <= (16 - int(MiscItem.drowndebufflevel * frandom(0.8,1.2)))) airreplen = 1;
						if (airreplen < 0) airreplen = 0;
					}
				}
				airreplentimer += airreplen;
				while (airreplentimer > 100)
				{
					AirTime += 1;
					airreplentimer -= 100;
				}
				if (dydudebug_airmeter >= 1) Console.Printf("\c[sapphire]airreplentimer: %d, airreplen: %d (%d / %d)", airreplentimer, airreplen, AirTime, MaxAirTime);
			}
			if (AirTime > MaxAirTime) AirTime = MaxAirTime;
		}

		if (playgasp)
		{
			if (wasdrowning)
			{
				bool emergegaspsnd = false;
				if (takendrowndmg)
				{
					emergegaspsnd = true;
					takendrowndmg = false;
				}
				else if (random(1,9) <= 6) 
				{
					emergegaspsnd = true;
					willgasp = false;
				}

				if (emergegaspsnd)
				{
					if (waterlevel <= 2)
					{
						A_StopSound(CHAN_VOICE);
						if (GetClassName() == "DinahPlayer") A_StartSound("dinah/drowngasp1",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
					}
					willgasp = false;
				}
			}
			else
			{
				bool emergegaspsnd = false;
				if (willgasp)
				{
					int AirMeterRatio;
					if (MaxAirTime > 0) 
					{
						AirMeterRatio = (AirTime * 100 / MaxAirTime);
						
						if (AirMeterRatio <= 75) emergegaspsnd = true;
						else if (AirMeterRatio <= randompick(87,88) && random(1,16) <= 10) emergegaspsnd = true;
						else if (AirMeterRatio <= 100 && random(1,16) <= 4) emergegaspsnd = true;
						
						if (emergegaspsnd)
						{
							if (waterlevel <= 2)
							{
								A_StopSound(CHAN_VOICE);
								if (GetClassName() == "DinahPlayer") A_StartSound("dinah/watergasp",CHAN_VOICE,CHANF_DEFAULT,frandom(0.9,1.1),ATTN_NORM,1.0);
							}
						}
					}
					willgasp = false;
				}
			}
		}
		return wasdrowning;
	}
	
	void SpawnBubbles(string bubbletype = "AirBubble1", double bubblex = 0, double bubbley = 0, double bubblez = 0)
	{
		bubblex += random(3,11);
		bubblex += random(-2,2);
		bubblez += random((Player.ViewHeight-2),(Player.ViewHeight+2));
		A_SpawnItemEx("AirBubble1",bubblex,bubbley,bubblez,0,0,0,0,SXF_NOCHECKPOSITION);
	}
	
	override void CheckAirSupply()
	{
		if (!player || !player.mo || player.mo != self)
		{
			super.CheckAirSupply();
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			MaxAirTime = (20 * TICRATE); // 7000
			double DDTAirBonusMulti = 1.666666666666667;
			double GenAirBonusMulti = 1.666666666666667;
			
			if (ddafd_underwatercompat && 
					(CountInv("IsDynDuchess") || 
					 CountInv("IsAppetite") || 
					 CountInv("IsCarnOfSouls") || 
					 CountInv("IsWeddingCake")))
			{
				MaxAirTime = (20 * TICRATE);
				DDTAirBonusMulti = 1.666666666666667;
				GenAirBonusMulti = 1.666666666666667;
			}
			else
			{
				MaxAirTime = (15 * TICRATE); // (12 * TICRATE);
				DDTAirBonusMulti = 1.333333333333334; // 1.0;
				GenAirBonusMulti = 1.333333333333334; // 1.0;
			}
			if (dydudebug_airmeter >= 2) Console.Printf("DDTAirBonusMulti: %.8f, GenAirBonusMulti: %.8f", DDTAirBonusMulti, GenAirBonusMulti);
			
			if (!exex_expenabled)
			{
				double DDTFactor = 0.0;
				if (CountInv("IsDynDuchess") || 
						CountInv("IsAppetite") || 
						CountInv("IsCarnOfSouls") || 
						CountInv("IsWeddingCake"))
				{
					if (MiscItem.DD_RoseMother) DDTFactor += 0.01875;
					if (MiscItem.DD_GameMother) DDTFactor += 0.01875;
					if (MiscItem.DD_MossMother) DDTFactor += 0.01875;
					if (MiscItem.DD_GlobeMother) DDTFactor += 0.01875;
					if (MiscItem.DD_SphinxMother) DDTFactor += 0.01875;
					if (MiscItem.DD_HandMother1) DDTFactor += 0.01875;
					if (MiscItem.DD_HandMother2) DDTFactor += 0.01875;
					if (MiscItem.DD_TrueHandMother) DDTFactor += 0.01875;
					if (MiscItem.AFD_Krag) DDTFactor += 0.025;
					if (MiscItem.AFD_Quisling) DDTFactor += 0.025;
					if (MiscItem.AFD_Lauritz) DDTFactor += 0.025;
					if (MiscItem.AFD_Jorgensen1) DDTFactor += 0.025;
					if (MiscItem.AFD_Jorgensen2) DDTFactor += 0.025;
					if (MiscItem.AFD_JorgCannon) DDTFactor += 0.025;
					if (MiscItem.CoS_Fafnir) DDTFactor += 0.025;
					if (MiscItem.CoS_FractalHens) DDTFactor += 0.025;
					if (MiscItem.CoS_HandMothers) DDTFactor += 0.025;
					if (MiscItem.CoS_ForsakenJorg) DDTFactor += 0.025;
					if (MiscItem.CoS_EvilDinah) DDTFactor += 0.025;
					if (MiscItem.CoS_Tempest) DDTFactor += 0.025;
					if (TrueGameSkill <= SKILL_VERY_EASY)	DDTFactor *= 2.5;
					if (TrueGameSkill == SKILL_EASY)			DDTFactor *= 2.25;
					if (TrueGameSkill == SKILL_NORMAL)		DDTFactor *= 2.0;
					if (TrueGameSkill == SKILL_HARD)			DDTFactor *= 1.75;
					if (TrueGameSkill >= SKILL_VERY_HARD)	DDTFactor *= 1.5;
					DDTFactor *= exex_nrpggeneraleffect;
					DDTFactor += 1.0;
					if (dydudebug_airmeter >= 1) Console.Printf("DDTFactor [MaxAirTime]: %.8f", DDTFactor);
					MaxAirTime *= DDTFactor;
					MaxAirTime += (MiscItem.AirBonusAdd * DDTAirBonusMulti);
				}
			}
			else
			if (MiscItem) 
			{
				double lvlfactor = 2.916666666666667;
				if (TrueGameSkill <= SKILL_VERY_EASY)	lvlfactor = 4.666666666666667; // 1.6x
				if (TrueGameSkill == SKILL_EASY)			lvlfactor = 3.572916666666667; // 1.225x
				if (TrueGameSkill == SKILL_NORMAL)		lvlfactor = 2.916666666666667; // 1.0x
				if (TrueGameSkill == SKILL_HARD)			lvlfactor = 2.479166666666667; // 0.85x
				if (TrueGameSkill >= SKILL_VERY_HARD)	lvlfactor = 2.041666666666667; // 0.7x
				lvlfactor *= GenAirBonusMulti;
				MaxAirTime += (TruePlayerLevel * lvlfactor);
				MaxAirTime += (MiscItem.AirBonusAdd * DDTAirBonusMulti);
			}

			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxAirTime *= 1.25;
			if (MaxAirTime > 0) MaxAirTime *= AirCapacity;
			if (GetAge() <= 1 && AirTime != MaxAirTime) AirTime = MaxAirTime;
			
			// Drown Damage
			int DrownDmg = 2 + (-AirTime / TICRATE);
			DrownDmg = ceil(DrownDmg * frandompick(0.625,0.75,0.875,1.000));
			if (CLWater == 1) 
			{
				DrownDmg = 8 + (-AirTime / TICRATE);
				DrownDmg = ceil(DrownDmg * frandompick(0.875,0.9375,0.9675,1.000));
			}
			if (CLWater == 2) 
			{
				DrownDmg = 3 + (-AirTime / TICRATE);
				DrownDmg = ceil(DrownDmg * frandompick(0.6875,0.8375,0.9375,1.000));
			}

			if (DrownDmg < 0) DrownDmg = 0;
			if (dydudebug_airmeter == 1) Console.Printf("InWaterTime: %d, WaterLevel: %d (WaterDepth: %.4f), AirTime: %d / %d, DrownDmg: %d, willgasp: %d, takendrowndmg: %d", InWaterTime, waterlevel, WaterDepth, AirTime, MaxAirTime, DrownDmg, willgasp, takendrowndmg);
			// Handle air supply	
			//if (level.airsupply > 0)
			{
				let player = self.player;
				if (waterlevel >= 3)
				{
					if (InWaterTime <= 0)
					{
						A_StartSound("misc/enterwater",215,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.8,1.2));
					}
					InWaterTime++;
					
					if (CountInv("PowerNoDrown") || 
							CountInv("PowerIronFeet") || 
							CountInv("PowerIronFeet2") || 
							CountInv("PowerMask"))
					{
						willgasp = false;
					}
					else
					{
						willgasp = true;
					}
				}
				else 
				{
					if (InWaterTime > 0)
					{
						A_StartSound("misc/exitwater2",215,CHANF_DEFAULT,1.0,ATTN_NONE,frandom(0.8,1.2));
						if (dydudebug_airmeter == 1) Console.Printf("misc/exitwater2");
					}
					InWaterTime = 0;
				}
				
				if (waterlevel < 3 || (bInvulnerable) || 
					(player.cheats & (CF_GODMODE | CF_NOCLIP2)) || (player.cheats & CF_GODMODE2) || 
					CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
				{
					ResetAirSupply(true);
				}
				else
				{
					buttons = GetPlayerInput(INPUT_BUTTONS);

					double bubblex, bubbley, bubblez;
					if (!(CountInv("PowerNoDrown") || 
								CountInv("PowerIronFeet") || 
								CountInv("PowerIronFeet2") || 
								CountInv("PowerMask"))) 
					{
						if (CLWater)
						{
							if (CLWater == 2)
							{
								if (random(1,16) <= random(3,6)) airtime -= random(1,2);
																						else airtime -= random(2,4);
							}
							else airtime -= random(4,8);
						}
						else
						{
							AirTime--;
						}
					}
					if (AirTime > MaxAirTime) AirTime = MaxAirTime;
					if (AirTime <= 0)
					{
						int drownint = 31;
						if (CLWater)
						{
							if (AirTime <= 0) AirTime = 0;
							if (CLWater == 2)
							{
								if (random(1,16) <=  random(3,6)) drownint = 31;
																						 else drownint = 27;
							}
							else
							{
								drownint = 22;
							}
						}
						if (!(level.maptime & drownint) && DrownDmg)
						{
							DamageMobj(NULL, NULL, DrownDmg, 'Drowning');
							string drownsnd = "misc/drowning";
							if (health <= 0) drownsnd = "misc/drowninglong";
							if (health > 0)
							{
								if (MiscItem)
								{
									MiscItem.drowndebuginit = true;
									if (MiscItem.drowndebufflevel < 10)
									{
										MiscItem.drowndebufflevel++;
										if (CLWater)
										{
											if (CLWater == 2)
											{
												if (random(1,16) <= random(3,6)) MiscItem.drowndebufftimer += random(38,53);
																										else MiscItem.drowndebufftimer += random(25,35);
											}
											else
											{
												MiscItem.drowndebufftimer += random(50,70);
											}
										}
										else
										{
											MiscItem.drowndebufftimer += random(25,35);
										}
									}
								}
							}
							A_StopSound(120);
							A_StartSound(drownsnd,120,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(1.375,1.5));
							takendrowndmg = true;
							
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							if (random(1,3) <= random(1,2))
							{
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
								if (random(1,3) <= 1) 
								{
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
								}
							}
							if (CLWater == 1)
							{
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,3) <= random(1,2))
								{
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									SpawnBubbles("AirBubble1",frandom(-8,8),frandom(-8,8),frandom(-5,5));
									if (random(1,3) <= 1) 
									{
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
										SpawnBubbles("AirBubble1",frandom(-11,11),frandom(-11,11),frandom(-7,7));
									}
								}
							}
						}
					}
					else
					{
						int basechance = 64;
						bool extrabubbles = true;
						bool moveaffectchance = true;
						if (CountInv("PowerNoDrown") || 
								CountInv("PowerIronFeet") || 
								CountInv("PowerIronFeet2") || 
								CountInv("PowerMask"))
						{
							basechance *= 16;
							extrabubbles = false;
							if (random(1,32) <= 31) moveaffectchance = false;
						}
						
						if (moveaffectchance)
						{
							if (buttons & BT_FORWARD || 
									buttons & BT_BACK || 
									buttons & BT_MOVELEFT || 
									buttons & BT_MOVERIGHT)
							{
								basechance *= frandom(0.6,0.75);
								if (random(1,16) <= random(1,2)) basechance *= 0.5;
							}
							if (buttons & BT_JUMP || buttons & BT_CROUCH)
							{
								basechance *= frandom(0.6,0.75);
								if (random(1,16) <= random(1,2)) basechance *= 0.5;
							}
						}
						
						if (random(1,basechance) <= 1)
						{
							SpawnBubbles("AirBubble1",frandom(-4,4),frandom(-4,4),frandom(-2,2));
							if (extrabubbles)
							{
								if (random(1,(basechance*0.125)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*0.5)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*2)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
								if (random(1,(basechance*8)) <= 1) SpawnBubbles("AirBubble1",frandom(-5,5),frandom(-5,5),frandom(-3,3));
							}
						}
					}
				}
			}
			int tempAirTime = AirTime;
			if (tempAirTime < 0) tempAirTime = 0;
			int tempMaxAirTime = MaxAirTime;
			if (tempMaxAirTime < 0) tempMaxAirTime = 0;
			A_SetInventory("AirMeter", tempAirTime);
			A_SetInventory("MaxAirMeter", tempMaxAirTime);
		}
	}
	
	override void CheckFOV()
	{
		let player = self.player;

		if (!player) return;

		// [RH] Zoom the player's FOV
		float desired = player.DesiredFOV;
		// Adjust FOV using on the currently held weapon.
		if (player.playerstate != PST_DEAD &&		// No adjustment while dead.
			player.ReadyWeapon != NULL &&			// No adjustment if no weapon.
			player.ReadyWeapon.FOVScale != 0)		// No adjustment if the adjustment is zero.
		{
			// A negative scale is used to prevent G_AddViewAngle/G_AddViewPitch
			// from scaling with the FOV scale.
			desired *= abs(player.ReadyWeapon.FOVScale);
		}
		if (player.FOV != desired)
		{
			if (abs(player.FOV - desired) < 7.)
			{
				player.FOV = desired;
			}
			else
			{
				float zoom = MAX(7., abs(player.FOV - desired) * 0.025);
				if (player.FOV > desired)
				{
					player.FOV = player.FOV - zoom;
				}
				else
				{
					player.FOV = player.FOV + zoom;
				}
			}
		}
	}
	
	override void CheckCheats()
	{
		let player = self.player;
		// No-clip cheat
		if ((player.cheats & (CF_NOCLIP | CF_NOCLIP2)) == CF_NOCLIP2)
		{ // No noclip2 without noclip
			player.cheats &= ~CF_NOCLIP2;
		}
		bNoClip = (player.cheats & (CF_NOCLIP | CF_NOCLIP2) || Default.bNoClip);
		if (player.cheats & CF_NOCLIP2)
		{
			bNoGravity = true;
		}
		else if (!bFly && !Default.bNoGravity)
		{
			bNoGravity = false;
		}
	}
	
	override void PlayerThink()
	{
		wasongroundprevtic = player.onground;
		let player = self.player;
		UserCmd cmd = player.cmd;
		
		CheckFOV();

		if (player.inventorytics)
		{
			player.inventorytics--;
		}
		CheckCheats();

		if (bJustAttacked)
		{ // Chainsaw/Gauntlets attack auto forward motion
			cmd.yaw = 0;
			cmd.forwardmove = 0xc800/2;
			cmd.sidemove = 0;
			bJustAttacked = false;
		}

		bool totallyfrozen = CheckFrozen();

		// Handle crouching
		CheckCrouch(totallyfrozen);
		CheckMusicChange();

		if (player.playerstate == PST_DEAD)
		{
			DeathThink ();
			return;
		}
		if (player.jumpTics != 0)
		{
			player.jumpTics--;
			if (player.onground && player.jumpTics < -18)
			{
				player.jumpTics = 0;
			}
			//Console.Printf("player.jumpTics: %d", player.jumpTics);
		}
		if (player.morphTics && !(player.cheats & CF_PREDICTING))
		{
			MorphPlayerThink ();
		}

		CheckPitch();
		HandleMovement();
		CalcHeight ();

		if (!(player.cheats & CF_PREDICTING))
		{
			CheckEnvironment();
			// Note that after this point the PlayerPawn may have changed due to getting unmorphed or getting its skull popped so 'self' is no longer safe to use.
			// This also must not read mo into a local variable because several functions in this block can change the attached PlayerPawn.
			player.mo.CheckUse();
			player.mo.CheckUndoMorph();
			// Cycle psprites.
			player.mo.TickPSprites();
			// Other Counters
			if (player.damagecount)
			{
				if (player.damagecount >= uint(random(93,94))) damagecntfrag -= randompick(0,0,0,1,1,1,2,2,2);
				else if (player.damagecount >= 75) damagecntfrag -= randompick(1,1,2,2,3,3,4,4);
				else if (player.damagecount >= 50) damagecntfrag -= randompick(3,3,4,4,5,5,6,6);
				else if (player.damagecount >= 25) damagecntfrag -= randompick(5,6,6,7,7,8,8,9);
				else damagecntfrag -= randompick(8,8,9,9,9,9,10,10);
				while (damagecntfrag <= 0)
				{
					player.damagecount--;
					damagecntfrag += 10;
					if (player.damagecount <= 0) break;
				}
			}
			else
			{
				damagecntfrag = 10;
			}
			if (dydudebug_countdisplays == 1 && player.damagecount > 0) Console.Printf("player.damagecount: %d, damagecntfrag: %d", player.damagecount, damagecntfrag);
			if (player.bonuscount) player.bonuscount--;
			if (dydudebug_countdisplays == 1 && player.bonuscount > 0) Console.Printf("player.bonuscount: %d", player.bonuscount);

			if (player.hazardcount)
			{
				player.hazardcount--;
				if (player.hazardinterval <= 0)
					player.hazardinterval = 32; // repair invalid hazardinterval
				if (!(Level.maptime % player.hazardinterval) && player.hazardcount > 16*TICRATE)
					player.mo.DamageMobj (NULL, NULL, 5, player.hazardtype);
			}
			if (dydudebug_countdisplays == 2) Console.Printf("player.hazardcount: %d, player.hazardinterval: %d / 32, player.hazardtype: %s", player.hazardcount, player.hazardinterval, player.hazardtype);
			player.mo.CheckPoison();
			player.mo.CheckDegeneration();
			player.mo.CheckAirSupply();
		}
		wasongroundcurrtic = player.onground;
		if (dydudebug_playermove) Console.Printf("wasongroundprevtic: %d, wasongroundcurrtic: %d [gametic: %d]", wasongroundprevtic, wasongroundcurrtic, gametic);
	}

	override void MovePlayer()
	{
		if (!player || !player.mo || player.mo != self)
		{
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			double AirControlBase = frandom(0.2432,0.2436);
			int PlayerSPD;
			if (MiscItem) PlayerSPD = MiscItem.TruePlayerSPD;

			// Level Based AirControl
			// Stats Based AirControl
			double StatAirControl = 1.00;
			if (exex_expenabled) StatAirControl = 1.00 + ((ActualLevel + PlayerSPD) * 0.01);
											else StatAirControl = 1.00 + ((PlayerSPD) * 0.01);
			
			// DD NO-RPG Mode Air Control
			double NRPGAirControl = 1.0;
			if (!exex_expenabled)
			{
				if (A_CheckDDGame())
				{
					NRPGAirControl = 0.0;
					if (MiscItem.DD_RoseMother) NRPGAirControl += 0.01875;
					if (MiscItem.DD_GameMother) NRPGAirControl += 0.01875;
					if (MiscItem.DD_MossMother) NRPGAirControl += 0.01875;
					if (MiscItem.DD_GlobeMother) NRPGAirControl += 0.01875;
					if (MiscItem.DD_SphinxMother) NRPGAirControl += 0.01875;
					if (MiscItem.DD_HandMother1) NRPGAirControl += 0.01875;
					if (MiscItem.DD_HandMother2) NRPGAirControl += 0.01875;
					if (MiscItem.DD_TrueHandMother) NRPGAirControl += 0.01875;
					if (MiscItem.AFD_Krag) NRPGAirControl += 0.025;
					if (MiscItem.AFD_Quisling) NRPGAirControl += 0.025;
					if (MiscItem.AFD_Lauritz) NRPGAirControl += 0.025;
					if (MiscItem.AFD_Jorgensen1) NRPGAirControl += 0.025;
					if (MiscItem.AFD_Jorgensen2) NRPGAirControl += 0.025;
					if (MiscItem.AFD_JorgCannon) NRPGAirControl += 0.025;
					if (MiscItem.CoS_Fafnir) NRPGAirControl += 0.025;
					if (MiscItem.CoS_FractalHens) NRPGAirControl += 0.025;
					if (MiscItem.CoS_HandMothers) NRPGAirControl += 0.025;
					if (MiscItem.CoS_ForsakenJorg) NRPGAirControl += 0.025;
					if (MiscItem.CoS_EvilDinah) NRPGAirControl += 0.025;
					if (MiscItem.CoS_Tempest) NRPGAirControl += 0.025;
					if (TrueGameSkill <= SKILL_VERY_EASY)	NRPGAirControl *= 8;
					if (TrueGameSkill == SKILL_EASY)			NRPGAirControl *= 7;
					if (TrueGameSkill == SKILL_NORMAL)		NRPGAirControl *= 6;
					if (TrueGameSkill == SKILL_HARD)			NRPGAirControl *= 5;
					if (TrueGameSkill >= SKILL_VERY_HARD)	NRPGAirControl *= 4;
					NRPGAirControl *= exex_nrpggeneraleffect;
					NRPGAirControl += 1.0;
				}
			}

			// Armor items
			double ArmorAirControl = 1.00;
			if (CountInv("KnightGownItem"))			ArmorAirControl += 0.0667;
			if (CountInv("KnightGownItem2"))		ArmorAirControl += 0.10;
			if (CountInv("KnightGownItem3"))		ArmorAirControl += 0.1334;
			if (CountInv("KnightGownItem4"))		ArmorAirControl += 0.18;
			if (MiscItem)
			{
				if (MiscItem.WineDefTier == 1 || MiscItem.WineDefTier == -1) ArmorAirControl *= frandom(0.98,1.00);
				if (MiscItem.WineDefTier == 2 || MiscItem.WineDefTier == -2) ArmorAirControl *= frandom(0.96,1.00);
				if (MiscItem.WineDefTier == 3 || MiscItem.WineDefTier == -3) ArmorAirControl *= frandom(0.93,1.00);
				if (MiscItem.WineDefTier == 4 || MiscItem.WineDefTier == -4) ArmorAirControl *= frandom(0.88,1.00);
				if (MiscItem.WineDefTier == 5 || MiscItem.WineDefTier == -5) ArmorAirControl *= frandom(0.81,1.00);
			}

			// Buffs
			double BuffAirControl = 1.00;
			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) BuffAirControl *= 1.334;
			if (CountInv("PowerEggBuff") || CountInv("PowerEggBuff2")) BuffAirControl *= 1.5;
			if (CountInv("PowerFruitBuff") || CountInv("PowerFruitBuff2")) BuffAirControl *= 1.25;
			if (CountInv("PowerRoastBuff")) BuffAirControl *= 2.0;
			if (CountInv("PowerMealBuff") || CountInv("PowerMealBuff2")) BuffAirControl *= 3.0;
			if (CountInv("PowerMeal2Buff") || CountInv("PowerMeal2Buff2")) BuffAirControl *= 3.0;
			
			// ?
			double ssa = 1.00;
			if (CountInv("ExpeditionHat")) ssa += 0.50;
			if (CountInv("ClassyRibbon")) ssa += 2.00;

			level.aircontrol = AirControlBase
											* NRPGAirControl
											* StatAirControl
											* ArmorAirControl
											* BuffAirControl
											* ssa;
			if (level.aircontrol > 1.00) level.aircontrol = 1.00;
			level.airfriction = level.aircontrol * -0.0941 + 1.0004;

			if (dydudebug_playermove)
			{
				Console.Printf("\czSV_AirControl:\c- \cz%.8f\c-  \cwTotalAirControl:\c- \cw%.8f\c-, \cyAirControlBase:\c- \cy%.8f\c-, StatAirControl: %.8f, NRPGAirControl: %.8f, ArmorAirControl: %.8f, BuffAirControl: %.8f, ssa: %.8f", sv_aircontrol, level.aircontrol, AirControlBase, StatAirControl, NRPGAirControl, ArmorAirControl, BuffAirControl, ssa);
				Console.Printf("\cwTotalFriction:\c- \cw%.8f\c-, \cyLevelAirFriction:\c- \cy%.8f\c-", friction, level.airfriction);
				Console.Printf("\c[blue]Player.ForwardMove: (%.2f, %.2f), Player.SideMove: (%.2f, %.2f), Player.ViewBob: %.2f", ForwardMove1, ForwardMove2, SideMove1, SideMove2, ViewBob);
			}
			if (dydudebug_playerpos)
			{
				Console.Printf("\c[fire]cursector: %d, damagetype: %s, floorz: %.4f, floorpic: %s, ceilingz: %.4f, ceilingpic: %s, dropoffz: %.4f [tic: %d]", cursector.Index(), cursector.damagetype, floorz, texman.GetName(floorpic), ceilingz, texman.GetName(ceilingpic), dropoffz, gametic);
				if (cursector.Index() != ceilingsector.Index()) Console.Printf("  \c[sapphire]ceilingsector: %d, damagetype: %s, floorpic: %s, ceilingpic: %s [tic: %d]", ceilingsector.Index(), ceilingsector.damagetype, texman.GetName(floorpic), texman.GetName(ceilingpic), gametic);
				if (cursector.Index() != floorsector.Index()) Console.Printf("  \c[sapphire]floorsector: %d, damagetype: %s, floorpic: %s, ceilingpic: %s [tic: %d]", floorsector.Index(), floorsector.damagetype, texman.GetName(floorpic), texman.GetName(ceilingpic), gametic);
			}
			/*
			double posf;
			posf = cursector.NextLowestFloorAt(pos.x, pos.y, pos.z, 0, maxstepheight);
			Console.Printf("posf: %.4f", posf);

      FCheckPosition CurPos;
			Double Dbl;
			Sector Sec;
			F3DFloor Fl;

			CheckPosition(Pos.XY,False,CurPos);

			//[Dbl,Sec,Fl] = CurPos.CurSector.NextHighestCeilingAt(Pos.X,Pos.Y,Pos.Z,CurPos.CurSector.HighestCeilingAt(Pos.XY));
			//[Dbl,Sec,Fl] = CurPos.CurSector.NextLowestFloorAt(Pos.X,Pos.Y,Pos.Z,0,24);
			[Dbl,Sec] = CurSector.LowestFloorAt(Pos.XY);

			A_LogFloat(Dbl,False);
			*/
		}
		
		let player = self.player;
		UserCmd cmd = player.cmd;

		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.

		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel)
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
		}
	}
	
	override void FallAndSink(double grav, double oldfloorz)
	{
		if (dydudebug_playermove && WaterDepth > 0) Console.Printf("Current water depth: %.4f", WaterDepth);

		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let player = self.player;
		let PlayerWeapon = player.ReadyWeapon;
		UserCmd cmd = player.cmd;
		bool berserked;
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) berserked = true;
		CLWater = 0;
		
		if (dydudebug_playermove) Console.Printf("\c[orange](FallAndSink() Start)\c- Vel.Z: %.4f [oldfloorz: %.8f, grav: %.8f (level.gravity: %.8f)] [tic: %d]", Vel.Z, oldfloorz, grav, level.gravity, gametic);
		if (Pos.Z > floorz && !bNOGRAVITY)
		{
			if (dydudebug_playermove) Console.Printf("Waterlevel: %d (WaterDepth: %.4f), Pos.Z: %.8f, floorz: %.8f [tic: %d]", waterlevel, WaterDepth, pos.z, floorz, gametic);
			double startvelz = Vel.Z;
			
			if (waterlevel == 0 || 
					(player && !(cmd.forwardmove | cmd.sidemove)))
			{
				// [RH] Double gravity only if running off a ledge. Coming down from
				// an upward thrust (e.g. a jump) should not double it.
				if (Vel.Z == 0 && oldfloorz > floorz && Pos.Z == oldfloorz)
				{
					Vel.Z -= grav + grav;
				}
				else
				{
					Vel.Z -= grav;
				}
				if (dydudebug_playermove) Console.Printf("\c[orange](FallAndSink() waterlevel=0/(!forwardside/sidemove))\c- Vel.Z: %.4f [oldfloorz: %.8f, grav: %.8f] [tic: %d]", Vel.Z, oldfloorz, grav, gametic);
			}
			
			if (player == NULL)
			{
				if (waterlevel >= 1)
				{
					double sinkspeed;
	
					if (bSPECIAL && !bISMONSTER)
					{ // Pickup items don't sink if placed and drop slowly if dropped
						sinkspeed = bDROPPED ? -0.5 / 8 : 0;
					}
					else
					{
						sinkspeed = -0.5;
	
						// If it's not a player, scale sinkspeed by its mass, with
						// 100 being equivalent to a player.
						if (player == NULL)
						{
							sinkspeed = sinkspeed * clamp(Mass, 1, 4000) / 100;
						}
					}
					if (Vel.Z < sinkspeed)
					{ // Dropping too fast, so slow down toward sinkspeed.
						Vel.Z -= max(sinkspeed * 2, -8.);
						if (Vel.Z > sinkspeed)
						{
							Vel.Z = sinkspeed;
						}
					}
					else if (Vel.Z > sinkspeed)
					{ // Dropping too slow/going up, so trend toward sinkspeed.
						Vel.Z = startvelz + max(sinkspeed / 3, -8.);
						if (Vel.Z < sinkspeed)
						{
							Vel.Z = sinkspeed;
						}
					}
				}
			}
			else // Player
			{
				if (waterlevel > 1)
				{
					if (A_CheckUOHYM() && 
							level.mapname == "MAP01" &&
							cursector.Index() == 30479) CLWater = 1;
					if (CLWater)
					{
						if (PlayerWeapon is "WizardPike" &&
								CountInv("PikeAmmo") > 0)
						{
							CLWater = 2;
						}
					}
							
					double massfactor = (MiscItem.PreBuffMass * 0.01);
					if (massfactor > 40.00) massfactor = 40.00;
					double massfactor2 = 1.0 - (ActualLevel * 0.015);
					if (massfactor2 < 0.25) massfactor2 = 0.25;
					double sinkspeed = -0.5;
					sinkspeed *= massfactor;
					sinkspeed *= massfactor2;
					if (dydudebug_playermove) Console.Printf("\c[sapphire]massfactor: %.8f, massfactor2: %.8f, sinkspeed: %.8f, [tic: %d]", massfactor, massfactor2, sinkspeed, gametic);
					
					double armordiffmod = 1.00;
					if (MiscItem)
					{
						double ArmorEnc = (MiscItem.ArmorML * 1.25);
						if (dydudebug_playermove) Console.Printf("\c[gold](DDPlayPawn)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorML);
						if (A_CheckDDGame())
						{
							ArmorEnc *= 3;
							ArmorEnc *= exex_nrpggeneraleffect;
						}
						if (waterlevel >= 2)
						{
							if (A_CheckDDGame()) ArmorEnc *= 2.0;
															else ArmorEnc *= 1.5;
						}
						double lvlfact = 0.02;
						if (A_CheckDDGame()) 
						{
							if (TrueGameSkill <= SKILL_VERY_EASY)	lvlfact = 0.020;
							if (TrueGameSkill == SKILL_EASY)			lvlfact = 0.0175;
							if (TrueGameSkill == SKILL_NORMAL)		lvlfact = 0.015;
							if (TrueGameSkill == SKILL_HARD)			lvlfact = 0.0125;
							if (TrueGameSkill >= SKILL_VERY_HARD)	lvlfact = 0.01;
						}
						else
						{
							if (TrueGameSkill <= SKILL_VERY_EASY)	lvlfact = 0.04;
							if (TrueGameSkill == SKILL_EASY)			lvlfact = 0.035;
							if (TrueGameSkill == SKILL_NORMAL)		lvlfact = 0.03;
							if (TrueGameSkill == SKILL_HARD)			lvlfact = 0.025;
							if (TrueGameSkill >= SKILL_VERY_HARD)	lvlfact = 0.02;
						}
						if (waterlevel >= 2) 
						{
							if (A_CheckDDGame()) lvlfact *= 0.5;
															else lvlfact *= 0.75;
						}
						if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
						sinkspeed -= ArmorEnc;
						
						double weaponsinkfactor = 0.00;
						if (PlayerWeapon is "HandToHand") 
						{
							if (berserked) weaponsinkfactor -= frandom(0.75,0.875);
												else weaponsinkfactor -= frandom(0.50,0.75);
						}
						if (PlayerWeapon is "CricketBat") 
						{
							if (berserked) weaponsinkfactor -= 0.125;
												else weaponsinkfactor += 0.000;
						}
						if (PlayerWeapon is "BlunderAxe") 
						{
							if (berserked) weaponsinkfactor += 0.008125;
												else weaponsinkfactor += 0.03125;
						}
						if (PlayerWeapon is "AppleJack") 
						{
							if (berserked) weaponsinkfactor -= 0.05;
												else weaponsinkfactor -= 0.03125;
						}
						if (PlayerWeapon is "Scrambler")
						{
							if (berserked) weaponsinkfactor -= 0.1625;
												else weaponsinkfactor -= 0.125;
						}
						if (PlayerWeapon is "WizardPike")
						{
							if (CLWater)
							{
								if (CLWater == 2)
								{
									if (berserked) weaponsinkfactor -= 0.40625;
														else weaponsinkfactor -= 0.3125;
								}
								else
								{
									if (berserked) weaponsinkfactor -= 0.08125;
														else weaponsinkfactor -= 0.0625;
								}
							}
							else
							{
								if (berserked) weaponsinkfactor -= 0.08125;
													else weaponsinkfactor -= 0.0625;
							}
						}
						if (PlayerWeapon is "FosnianCandle") 
						{
							if (berserked) weaponsinkfactor += 0.008125;
												else weaponsinkfactor += 0.03125;
						}
						if (PlayerWeapon is "SuperVac")
						{
							double SuperVacAmmoFactor = MiscItem.SuperVacAmmoFactor;
							if (berserked) weaponsinkfactor += (0.015625 + SuperVacAmmoFactor);
												else weaponsinkfactor += (0.0625 + SuperVacAmmoFactor);
						}
						if (PlayerWeapon is "Grimophone") 
						{
							if (berserked) weaponsinkfactor += 0.03125;
												else weaponsinkfactor += 0.125;
						}
						if (PlayerWeapon is "CandleWhip")
						{
							if (berserked) weaponsinkfactor -= 0.08125;
												else weaponsinkfactor -= 0.0625;
						}
						If (PlayerWeapon is "EvilWarriorShield")
						{
							int HellWarriorShieldLevel = CountInv("HellWarriorShieldLevel");
							if (berserked)
							{
								if (CountInv("HWShieldBlockHold")) weaponsinkfactor += (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
																							else weaponsinkfactor += (0.05 * (1.0 + (HellWarriorShieldLevel * 0.003125)));
							}
							else
							{
								if (CountInv("HWShieldBlockHold")) weaponsinkfactor = (0.20 * (1.0 + (HellWarriorShieldLevel * 0.0125)));
																							else weaponsinkfactor = (0.10 * (1.0 + (HellWarriorShieldLevel * 0.00625)));
							}
						}
						if (PlayerWeapon is "HandToHand") weaponsinkfactor *= 1.0;
						else
						{
							if (A_CheckDDGame()) weaponsinkfactor *= 3.75;
							else weaponsinkfactor *= 1.875;
						}
						weaponsinkfactor *= exex_weaponencumbrance;
						weaponsinkfactor += 1.00;
						sinkspeed *= weaponsinkfactor;
						if (dydudebug_playermove) Console.Printf("\c[sapphire]weaponsinkfactor: %.8f, sinkspeed: %.8f [tic: %d]", weaponsinkfactor, sinkspeed, gametic);
						
						if (waterlevel == 2) 
						{
							if (CLWater)
							{
								if (CLWater == 2) sinkspeed *= 0.175;
														 else sinkspeed *= 0.875;
							}
							else sinkspeed *= 0.25;
						}
						if (dydudebug_playermove) Console.Printf("\c[sapphire]Vel.Z: %.8f, startvelz: %.8f, sinkspeed: %.8f, ArmorEnc: %.8f [tic: %d]", Vel.Z, startvelz, sinkspeed, ArmorEnc, gametic);
					}
					if (CLWater) 
					{
						if (player && (cmd.forwardmove | cmd.sidemove))
						{
							if (Vel.Z == 0 && oldfloorz > floorz && Pos.Z == oldfloorz)
							{
								if (CLWater == 2) Vel.Z -= grav;
														 else Vel.Z -= (grav * 2.5);
							}
							else
							{
								if (CLWater == 2) Vel.Z -= (grav * 0.5);
														 else Vel.Z -= (grav * 1.25);
							}
						}
						if (waterlevel >= 2)
						{
							if (waterlevel >= 3) sinkspeed *= 22.5;
															else sinkspeed *= 16.875;
						}
						else sinkspeed *= 11.25;
						if (TrueGameSkill <= SKILL_VERY_EASY)	sinkspeed *= 0.6;
						if (TrueGameSkill == SKILL_EASY)			sinkspeed *= 0.8;
						if (TrueGameSkill == SKILL_NORMAL)		sinkspeed *= 1.0;
						if (TrueGameSkill == SKILL_HARD)			sinkspeed *= 1.2;
						if (TrueGameSkill >= SKILL_VERY_HARD)	sinkspeed *= 1.4;
						if (CLWater == 2) 
						{
							if (TrueGameSkill <= SKILL_VERY_EASY)	sinkspeed *= 0.00;
							if (TrueGameSkill == SKILL_EASY)			sinkspeed *= 0.05;
							if (TrueGameSkill == SKILL_NORMAL)		sinkspeed *= 0.10;
							if (TrueGameSkill == SKILL_HARD)			sinkspeed *= 0.15;
							if (TrueGameSkill >= SKILL_VERY_HARD)	sinkspeed *= 0.20;
						}
						if (dydudebug_playermove) Console.Printf("\c[sapphire]Vel.Z: %.8f, startvelz: %.8f, sinkspeed: %.8f, CLWater: %d [tic: %d]", Vel.Z, startvelz, sinkspeed, CLWater, gametic);
					}
					
					if (Vel.Z < sinkspeed)
					{
						if (CLWater) 
						{
							double randmul;
							if (CLWater == 2) 
							{
								if (TrueGameSkill <= SKILL_VERY_EASY)	randmul = frandom(1.025,1.0625);
								if (TrueGameSkill == SKILL_EASY)			randmul = frandom(1.0375,1.09375);
								if (TrueGameSkill == SKILL_NORMAL)		randmul = frandom(1.05,1.125);
								if (TrueGameSkill == SKILL_HARD)			randmul = frandom(1.0625,1.15675);
								if (TrueGameSkill >= SKILL_VERY_HARD)	randmul = frandom(1.075,1.1875);
							}
							else
							{
								if (TrueGameSkill <= SKILL_VERY_EASY)	randmul = frandom(1.25,1.625);
								if (TrueGameSkill == SKILL_EASY)			randmul = frandom(1.375,1.9375);
								if (TrueGameSkill == SKILL_NORMAL)		randmul = frandom(1.5,2.25);
								if (TrueGameSkill == SKILL_HARD)			randmul = frandom(1.625,2.5675);
								if (TrueGameSkill >= SKILL_VERY_HARD)	randmul = frandom(1.75,2.875);
							}
							Vel.Z = (startvelz < (sinkspeed * randmul)) ? startvelz : (sinkspeed * randmul);
						}
						else 
						{
							Vel.Z = (startvelz < sinkspeed) ? startvelz : sinkspeed;
						}
					}
					else
					{
						double temp = ((Vel.Z - startvelz) * (waterlevel == 1 ? 0.25 : 0.125));
						if (CLWater) 
						{
							if (CLWater == 2) temp = ((Vel.Z - startvelz) * (waterlevel == 1 ? 0.4625 : 0.23125));
													 else temp = ((Vel.Z - startvelz) * (waterlevel == 1 ? 0.675 : 0.3375));
						}
						Vel.Z = startvelz + temp;
					}
				}
			}
		}
		if (dydudebug_playermove) Console.Printf("\c[orange](FallAndSink() End)\c- Vel.Z: %.4f [tic: %d]", Vel.Z, gametic);
	}
	
	Override void Tick()
	{
		TrueGameSkill = skill;
		deathtimerthres1 = (15 * 35);
		deathtimerthres2 = (30 * 35);
		deathtimerthres3 = (45 * 35);
		deathtimerthres4 = (10 * 35);
		deathfadetimebase = (10 * 35);
		
		// VOODOO Doll Protection
		if ((!player || !player.mo || player.mo != self)) 
		{
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			ActualLevel = A_CheckActualLevel(1);
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (dydudebug_showvoodoodoll) Console.Printf("Player [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem && exex_expenabled) 
			{
				TruePlayerLevel = MiscItem.TruePlayerLevel;
				TruePlayerATK = MiscItem.TruePlayerATK;
				TruePlayerDEF = MiscItem.TruePlayerDEF;
				TruePlayerSPD = MiscItem.TruePlayerSPD;
			}
			else
			{
				TruePlayerLevel = 0;
				TruePlayerATK = 0;
				TruePlayerDEF = 0;
				TruePlayerSPD = 0;
			}
			let globalvars = DDGlobalVariables.Get();
			if (dydudebug_mapinfo)
			{
				Console.Printf("Player Age [tics]: %d, levelnum: \cx%d\c-, cluster: \cx%d\c-, clusterflags: \cx%d\c-, NextMap: \cy%s\c-, NextSecretMap: \cy%s\c-,\ntime: \cx%d\c-, maptime: \cx%d\c-, totaltime: \cx%d\c-, starttime: \cx%d\c-, partime: \cx%d\c-, sucktime: \cx%d\c-,\nlevelname: \cy%s\c-, mapname: \cy%s\c-, \ngravity: \cx%.8f\c-, aircontrol: \cx%.8f\c-, airfriction: \cx%.8f\c-, \cxTranslation #:\c- %d, \cyMapCheckSum:\cx %s", 
												GetAge(),
												level.levelnum, level.cluster, level.clusterflags, level.NextMap, level.NextSecretMap,
												level.time, level.maptime, level.totaltime, level.starttime, level.partime, level.sucktime,
												level.levelname, level.mapname,
												level.gravity, level.aircontrol, level.airfriction,
												translation, level.GetChecksum());
			}
			
			// Check IP Buttons [general check for quick editing later across all definitions]
			
			if (ipmodecooldowntimer) ipmodecooldowntimer--;
			int IPbuttonspressed = 0;
			if (buttons & BT_USE) IPbuttonspressed++;
			if (buttons & BT_SPEED) IPbuttonspressed++;
			if (CheckIPEnabled())
			{
				if (exex_ikaripointtechpresstype == 0)
				{
					if (IPbuttonspressed >= 2) 
					{
						A_SetInventory("IPUseMode",1);
					}
					else
					{
						A_SetInventory("IPUseMode",0);
					}
				}
				else
				if (exex_ikaripointtechpresstype >= 1 && exex_ikaripointtechpresstype <= 2)
				{
					if (IPbuttonspressed >= 2) 
					{
						if (ipmodecooldowntimer <= 0)
						{
							ipmodecooldowntimer = random(9,12);
							if (CountInv("IPUseMode")) A_SetInventory("IPUseMode",0);
																		else A_SetInventory("IPUseMode",1);
						}
					}
				}
			}
			else
			{
				A_SetInventory("IPUseMode",0);
			}
			
			// The "Charge" sound[s] that plays in a loop while IP mode is active and the one that plays when it disperses [thanks to LilWhiteMouse for the sounds from Wolfen, wherever she herself had found them] :V
			
			double ipmodevol = 1.0;
			double basevollvl = 0.25;
			double ipmodepitch = 1.0;
			if (!A_CheckNoTimer())
			{
				if (health > 0)
				{
					if (MiscItem && globalvars && MiscItem.MaxItemPoints)
					{
						ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
						if (MiscItem.IPNoGainTimer) ipmodevol *= 0.001;
					}
					if (dydudebug_ipdisplays) Console.Printf("ipmodevol: %.4f, ipmodepitch: %.4f", ipmodevol, ipmodepitch);
					if (CountInv("IPUseMode"))
					{
						if (ipchargesoundtimer == 0)
						{
							if (MiscItem && globalvars)
							{
								ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
								if (MiscItem.IPNoGainTimer) ipmodevol *= 0.001;
							}
							A_StopSound(255);
							A_StartSound("ipmode/start",255,CHANF_NOSTOP,ipmodevol,ATTN_NORM,ipmodepitch);
						}
						ipchargesoundtimer++;
						if (ipchargesoundtimer >= 56)
						{
							int ipchargesoundtimer2 = ipchargesoundtimer % 56;
							if (ipchargesoundtimer2 == 0) 
							{
								A_StopSound(255);
								A_StartSound("ipmode/loop",255,CHANF_NOSTOP|CHANF_LOOPING,ipmodevol,ATTN_NORM,ipmodepitch);
							}
							if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer2: %d / 55", ipchargesoundtimer2);
						}
					}
					else
					{
						if (ipchargesoundtimer != 0)
						{
							ipchargesoundtimer = 0;
							A_StopSound(255);
							A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
						}
					}
				}
				else
				{
					if (ipchargesoundtimer != 0)
					{
						ipchargesoundtimer = 0;
						A_StopSound(255);
						A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
					}
					MiscItem.ItemPoints = 0;
					globalvars.ItemPoints = 0;
				}
				if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer: %d", ipchargesoundtimer);
			}
			
			// ??????
			double IPLevelGateInc = 1.0;
			if (!A_CheckNoTimer())
			{
				if (CheckIPEnabled() && CountInv("IPUseMode") && !ddafd_disableflowercrownip)
				{
					//Console.Printf("TrueIPLevelGate: %d, IP: %d (%d), Level: %d, TrueIPCooldownTimer: %d", MiscItem.TrueIPLevelGate, MiscItem.ItemPoints, globalvars.ItemPoints, ActualLevel, MiscItem.TrueIPCooldownTimer);
					if (buttons & BT_ZOOM && CountInv("FistPlayerBlockItem"))
					{
						bool wasnodmgthrust;
						bool wasforceradius;
						if (bNODAMAGETHRUST) wasnodmgthrust = true;
						if (bFORCERADIUSDMG) wasforceradius = true;
						double cost = A_GetIPCost(-1);
						if (MiscItem.TrueIPLevelGate <= 0 && MiscItem.ItemPoints >= cost && globalvars.ItemPoints >= cost && ActualLevel > 0 && MiscItem.TrueIPCooldownTimer <= 0)
						{
							globalvars.TrueIPTimesUsed += 1;
							int AngerLevelNInc = randompick(1,1,2,2,2,3,3,3,4,4,5);
							A_GiveInventory("AngerLevelEventN",AngerLevelNInc);
							A_GiveInventory("AngerLevelEventNMin",AngerLevelNInc);
							if (TrueGameSkill <= SKILL_VERY_EASY)	IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.625);
							if (TrueGameSkill == SKILL_EASY)			IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.75);
							if (TrueGameSkill == SKILL_NORMAL)		IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 0.875);
							if (TrueGameSkill == SKILL_HARD)			IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 1.0);
							if (TrueGameSkill >= SKILL_VERY_HARD)	IPLevelGateInc = int(globalvars.TrueIPTimesUsed * 1.125);
							if (IPLevelGateInc < 1) IPLevelGateInc = 1;
							MiscItem.TrueIPLevelGate += IPLevelGateInc;
							int truecost = MiscItem.ItemPoints;
							MiscItem.ItemPoints -= cost;
							globalvars.ItemPoints -= cost;
							A_IPUseHUD(truecost);
							
							if (MiscItem.IPDissipateTimer > 0) MiscItem.IPDissipateTimer = 0;
							if (MiscItem.HasHarmonicAnger)
							{
								MiscItem.IPNoGainTimer = 120 * TICRATE;
								MiscItem.TrueIPCooldownTimer = ((600 * TICRATE) * (1.0 - (ActualLevel * 0.016)));
								if (MiscItem.TrueIPCooldownTimer <= (120 * TICRATE)) MiscItem.TrueIPCooldownTimer = 120 * TICRATE;
								A_SetBlend("ff c0 00",1.00,(random(40,70)*2));
							}
							else
							{
								MiscItem.IPNoGainTimer = 60 * TICRATE;
								MiscItem.TrueIPCooldownTimer = ((300 * TICRATE) * (1.0 - (ActualLevel * 0.008)));
								if (MiscItem.TrueIPCooldownTimer <= (60 * TICRATE)) MiscItem.TrueIPCooldownTimer = 60 * TICRATE;
								A_SetBlend("ff c0 00",1.00,(random(40,70)*2));
							}
							double xp = pos.x;
							double yp = pos.y;
							double zp = pos.z;
							ThinkerIterator MonsterFinder = ThinkerIterator.Create("Actor");
							Actor mo;
							EECreature mo2;
							int numfound = 0;
							nm = "CCardGhostMarker";
							double cipradius = 131072;
							while (mo = Actor(MonsterFinder.Next()))
							{
								mo2 = EECreature(mo);
								if (mo.bISMONSTER && 
										mo.bSHOOTABLE && 
										(mo.bCOUNTKILL || mo.CountInv(nm)) && 
										mo.health > 0 &&
										!mo.bFRIENDLY && 
										!DDAFDNPC(mo) &&
										!EEProp(mo))
								{
									if (dydudebug_ipdisplays) Console.Printf("mo: %p, type: %s", mo, mo.GetClassName());
									double absx = abs(xp - mo.pos.x);
									double absy = abs(yp - mo.pos.y);
									double absz = abs(zp - mo.pos.z);
									if (dydudebug_ipdisplays)
									{
										string debug = "\c[green]absx: ";
										if (absx <= cipradius)	debug.AppendFormat("\c[gold]");
																			 else debug.AppendFormat("\c[red]");
										debug.AppendFormat("%.4f\c[green], ", absx);
										debug.AppendFormat("\c[green]absy: ");
										if (absy <= cipradius)	debug.AppendFormat("\c[gold]");
																			 else debug.AppendFormat("\c[red]");
										debug.AppendFormat("%.4f\c[green], ", absy);
										debug.AppendFormat("\c[green]absz: ");
										if (absz <= cipradius)	debug.AppendFormat("\c[gold]");
																			 else debug.AppendFormat("\c[red]");
										debug.AppendFormat("%.4f", absz);
										Console.Printf(debug);
									}
									if (absx <= cipradius && 
											absy <= cipradius &&
											absz <= cipradius)
									{
										numfound++;
										int dmginf;
										if (MiscItem.HasHarmonicAnger)
										{
											dmginf = (mo.health * frandompick(0.2,0.25,0.25,0.25,0.25,0.334));
											if (mo.CountInv(nm)) dmginf = ((mo.SpawnHealth() + mo.Stamina) * 2.0);
										}
										else
										{
											dmginf = (mo.health * frandompick(0.4,0.5,0.5,0.5,0.5,0.6667));
											if (mo.CountInv(nm)) dmginf = ((mo.SpawnHealth() + mo.Stamina) * 4.0);
										}
										mo.DamageMobj(self, self, dmginf, "TrueIP", DMG_NO_ARMOR|DMG_FORCED|DMG_NO_FACTOR|DMG_NO_PROTECT|DMG_NO_ENHANCE|DMG_EXPLOSION|DMG_THRUSTLESS, angle);
									}
								}
							}
							if (dydudebug_ipdisplays) Console.Printf("%d", numfound);
							if (numfound)
							{
								string sndname = "dinah/superdie";
								if (random(1,2) <= 1) sndname =  "dinah/YoullPayForThat";
								A_StopSound(CHAN_VOICE);
								A_StopSound(303);
								A_StopSound(304);
								A_StopSound(401);
								A_StopSound(402);
								A_StopSound(403);
								A_StartSound(sndname,CHAN_VOICE,CHANF_OVERLAP,0.8,ATTN_NONE,1.0);
								A_StartSound(sndname,303,CHANF_OVERLAP,0.7,ATTN_NONE,0.97);
								A_StartSound(sndname,304,CHANF_OVERLAP,0.7,ATTN_NONE,1.03);
								A_StartSound("DinahIP/IPBoom1",401,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
								A_StartSound("DinahIP/IPBoom2",402,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
								A_StartSound("DinahIP/IPBoom3",403,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							}
							
							A_StopSound(501);
							A_StopSound(502);
							A_StopSound(503);
							A_StopSound(504);
							A_StartSound("DinahIP/IPActivate1",501,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate2",502,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate3",503,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							A_StartSound("DinahIP/IPActivate4",504,CHANF_OVERLAP,1.0,ATTN_NONE,frandom(0.9,1.1));
							if (!CountInv("DinahTrueIPState")) 
							{
								A_SetInventory("DinahTrueIPState",1);
								let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
								if (TrueIPItem)
								{
									if (MiscItem.HasHarmonicAnger) TrueIPItem.EffectTics = ((120 * TICRATE) * (1.0 + ((ActualLevel - 1) * 0.01)));
																						else TrueIPItem.EffectTics = ((60 * TICRATE) * (1.0 + ((ActualLevel - 1) * 0.005)));
								}
							}
							else
							{
								let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
								if (TrueIPItem)
								{
									if (MiscItem.HasHarmonicAnger) TrueIPItem.EffectTics += ((120 * TICRATE) * (1.0 + ((ActualLevel - 1) * 0.01)));
																						else TrueIPItem.EffectTics += ((60 * TICRATE) * (1.0 + ((ActualLevel - 1) * 0.005)));
								}
							}
							A_SetInventory("HarmonicAnger",0);
							if (MiscItem) MiscItem.HasHarmonicAnger = false;
						}
					}
				}
			}
			
			int IPLoopInt;
			if (!A_CheckNoTimer())
			{
				if (CountInv("DinahTrueIPState"))
				{
					let TrueIPItem = DinahTrueIPState(FindInventory("DinahTrueIPState"));
					double raddmg = random(6,12) * 4;
					double radradius = (radius * 3.75);
					double radradius2 = (radius * 2.875);
					if (TrueIPItem)
					{
						raddmg = (random(6,12) * 4) * (frandom(0.475,0.525) + (TrueIPItem.EffectTics * 1.0 / (60 * TICRATE)));
						if (CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
						{
							raddmg *= randompick(12,16,20,24,32,36,40,48,60);
							radradius *= 2.0;
							radradius2 *= 2.0;
						}
					}
					bool wasnodmgthrust;
					bool wasforceradius;
					if (bNODAMAGETHRUST) wasnodmgthrust = true;
					if (bFORCERADIUSDMG) wasforceradius = true;
					if (!wasnodmgthrust) bNODAMAGETHRUST = true;
					if (!wasforceradius) bFORCERADIUSDMG = true;
					A_Explode(raddmg,radradius,0,0,radradius2,0,0,"","TrueIP");
					if (!wasforceradius) bFORCERADIUSDMG = false;
					if (!wasnodmgthrust) bNODAMAGETHRUST = false;
					double loopvol = frandom(0.45,0.55);
					double iptimeratio = (TrueIPItem.EffectTics * 1.0 / (60 * TICRATE));
					if (MiscItem) MiscItem.iptimeratio = iptimeratio;
					if (TrueIPItem) loopvol = (frandom(0.475,0.525) * iptimeratio);
					//Console.Printf("loopvol: %.2f, iptimeratio: %.2f", loopvol, iptimeratio);
					IPLoopTimer++;
					IPLoopInt = IPLoopTimer % 91;
					if (IPLoopInt == 0)
					{
						A_StopSound(701);
						A_StartSound("DinahIP/IPLoop3",701,CHANF_NOSTOP|CHANF_LOOPING,loopvol,ATTN_NORM,frandom(0.9,1.1));
					}
					int inter = 2;
					if (iptimeratio < 2.000) inter = 1;
					if (iptimeratio < 1.000) inter = 2;
					if (iptimeratio < 0.500) inter = 3;
					if (iptimeratio < 0.250) inter = 4;
					if (iptimeratio < 0.125) inter = 5;
					if (iptimeratio < 0.0625) inter = 6;
					if (iptimeratio < 0.03125) inter = 7;
					if (iptimeratio < 0.015625) inter = 8;
					if (level.time % inter == 0 && player.cheats & CF_CHASECAM)
					{
						//Console.Printf("gametic: %d", gametic);
						A_SpawnItemEx("DinahTIPAImage", frandom(-2,2),frandom(-2,2),frandom(-2,2), 0,0,0, 0, SXF_NOCHECKPOSITION|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA);
					}
					A_DynamicMusic(patktype:-1);
				}
				else
				{
					IPLoopTimer = 0;
					A_StopSound(701);
				}
			}
			
			// Dimming
			if (A_CheckUOHYM() && 
					level.mapname == "MAP01")
			{
				if (CountInv("UOHEnd4")) 
				{
					if (dimtimer < 175) dimtimer++;
					//Console.Printf("dimtimer: %d", dimtimer);
				}
				else dimtimer = 0;
			}
			else dimtimer = 0;
			
			// Death Stuff
			double fademax = 1.00;
			if (A_CheckUOHYM() && 
					level.mapname == "MAP01" &&
					!(CountInv("UOHInCL") || CountInv("UOHInBR")))
			{
			}
			else
			{
				if (health <= 0)
				{
					if (deadtimer <= 0) 
					{
						fadetime = int(TICRATE*frandom(2.1667,2.8334));
						A_SetBlend("00 00 00",0.00, fadetime, "00 00 00",fademax);
					}
					if (deadtimer > (fadetime-2)) A_SetInventory("BlackScreenHUD",1);
					if (!A_CheckDDGame())
					{
						if (exex_deathmusic == 13)
						{
							if (deadtimer == 108) A_StartSound("mortis",145,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
							if (deadtimer > 107) A_SetInventory("MortisScreenHUD",1);
															else A_SetInventory("MortisScreenHUD",0);
						}
						else A_SetInventory("MortisScreenHUD",0);
					}
					else A_SetInventory("MortisScreenHUD",0);
					
					deadtimer++;
					if (dydudebug_deathtimerdisplays) Console.Printf("deadtimer: %d", deadtimer);
					
					// Fading Heartbeats when dead
					A_CheckDeathHeartBeats(deadtimer);
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
				}
				else 
				{
					if (deadtimer > 0) 
					{
						fadetime *= 0.25;
						A_SetBlend("00 00 00",fademax, fadetime, "00 00 00",0.00);
						A_SetInventory("BlackScreenHUD",0);
						A_SetInventory("MortisScreenHUD",0);
						//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
					}
					deadtimer = 0;
				}
			}
			
			// Heartbeat [low health]
			if (exex_playerbpm)
			{
				double bmpbasevol = 1.00;
				double MaxHealthTrue = CountInv("PlayerMaxHP");
				if (MiscItem && MiscItem.IsMorphed == 1) MaxHealthTrue *= 0.3;
				if (CountInv("IsUnconscious")) bmpbasevol = frandom(0.25,0.334);
				if (health > 0)
				{
					beattimer++;
					if (health <= (MaxHealthTrue * 0.01))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(10,11);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.05))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(1.0,1.2)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(15,17);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.10))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.9,1.1)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(28,42);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.25))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.675,0.825)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					if (health <= (MaxHealthTrue * 0.5))
					{
						if (beattimer >= beatpulse)
						{
							A_StopSound(134);
							A_StartSound("heartb2",134,CHANF_DEFAULT,(frandom(0.45,0.55)*bmpbasevol),ATTN_NORM,frandom(0.9,1.1));
							beatpulse = random(66,74);
							hudbeatpulse = random(49,55);
							beattimer = 0;
						}
					}
					else
					{
						beatpulse = random(124,128);
						hudbeatpulse = random(49,55);
						beattimer = 0;
					}
				}
				else
				{
					beatpulse = 5000;
				}
			}
			
			// Armor
			armortier = 0;
			double SavePercent = 0.000000;
			int MaxAbsorb = 0;
			int MaxFullAbsorb = 0;
			
			name armorclasstype = "KGArmor";
			let armor = KGArmor(player.mo.FindInventory(armorclasstype));
			if (armor != null && armor.Amount > 0)
			{
				SavePercent = armor.SavePercent;
				MaxAbsorb = armor.MaxAbsorb;
				MaxFullAbsorb = armor.MaxFullAbsorb;
				if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
				if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
				if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
				if (savepercent >= 0.87500 && savepercent <= 0.93749) armortier = 3;
				if (savepercent >= 0.93750 && savepercent <= 0.99999) armortier = 4;
				if (savepercent >= 1.00000) armortier = 5;
				
				if (dydudebug_armordisplays) Console.Printf("\c[sapphire]Armor -\c- SavePercent: %.8f, Tier: %d, MaxAbsorb: %d, MaxFullAbsorb: %d", savepercent, armortier, MaxAbsorb, MaxFullAbsorb);
			}
			
			if (CountInv(armorclasstype) <= 0) A_SetInventory("NoKnightGownItem",1); else A_SetInventory("NoKnightGownItem",0);
			if (armortier == 1) A_SetInventory("KnightGownItem",1); else A_SetInventory("KnightGownItem",0);
			if (armortier == 2) A_SetInventory("KnightGownItem2",1); else A_SetInventory("KnightGownItem2",0);
			if (armortier == 3) A_SetInventory("KnightGownItem3",1); else A_SetInventory("KnightGownItem3",0);
			if (armortier == 4) A_SetInventory("KnightGownItem4",1); else A_SetInventory("KnightGownItem4",0);
			
			if (MiscItem) MiscItem.GetSpeedFactor();
			isvoodoodoll = false;
			
			if (A_CheckUOHYM())
			{
				double sizemult = 1.166666666666667; // 1.317073170731707;
				int newhei = (default.height * sizemult);
				if (newhei > 56) newhei = 56;
				int newrad = (default.radius * sizemult);
				if (newrad > 24) newrad = 24;
				A_SetSize(newrad,newhei,false);
				bINVISIBLEINMIRRORS = false;
				if (level.mapname == "MAP01")
				{
					bINVISIBLEINMIRRORS = true;
					if (deathtimer > 0 && deathtimer < deathtimerthres3)
					{
						++deathtimer;
						if (deathtimer > deathtimerthres2) 
						{
							if (deathtimer == (deathtimerthres2+2)) self.player.health = CountInv("PlayerMaxHP");
							++revivebeattimer;
							if (dydudebug_deathtimerdisplays) Console.Printf("[reviving] UOHYMTimer: %d, UOHYMTimer_b: %d, revivebeattimer: %d", deathTimer, deathTimer_b, revivebeattimer);
							A_CheckReviveHeartBeats(revivebeattimer);
						}
					}
					
					if (deathtimer >= deathtimerthres3)
					{
						if (deathtimer == (deathtimerthres3+175)) ACS_NamedExecute("revivedialouge",0,0,0,0);
						deathtimer_b -= randompick(1,2,2,2,2,3);
						if (deathtimer_b <= 0) 
						{
							deathtimer = 0;
							self.player.cheats &= ~(CF_TotallyFrozen);
						}
						else
						{
							++deathtimer;
						}
						if (dydudebug_deathtimerdisplays) Console.Printf("[recovering] UOHYMTimer: %d, UOHYMTimer_b: %d", deathTimer, deathTimer_b);
					}
					
					if (self.findInventory('AED_Token'))
					{
						if (!self.findInventory('FadeToken'))
						{
							SetMusicVolume(1.0);
						}
						
						self.takeInventory('AED_Token', 1);
						self.setOrigin(spot, false);
						self.angle = lastangle;
						
						whitehot = 1 * 15;
						
						for (int i; i < weapons.size(); ++i)
						{
							self.giveInventory(name(weapons[i]), 1);
						}
						
						for (int i; i < ammos.size(); ++i)
						{
							self.SetInventory(name(ammos[i]), ammosamt[i]);
						}
						
						for (int i; i < invitems.size(); ++i)
						{
							self.GiveInventory(name(invitems[i]), invitemsamt[i]);
						}
						
						let AED = Actor.spawn('Adrenaline');
						AED.touch(self);
						ACS_NamedExecute("resurrectdialouge",0,0,0,0);
						ACS_NamedTerminate("CheckHospital",0);
						
						hasDied = true;
					}
					
					if (whitehot > 0) --whitehot;
				}
				
				if (level.mapname == "MAP01" ||
						level.mapname == "20PAM" ||
						level.mapname == "MAP02")
				{
					nm = "SmoothFist";
					if (CountInv(nm))
					{
						SetInventory(nm,0);
						if (CountInv("HandToHand") <= 0) SetInventory("HandToHand",1);
					}
				}
			}
		}
		
		// Recall All
		if (recalledall)
		{
			if (dydudebug_recalldisplays) Console.Printf("Recall All Attempt");
			
			actor recalleetarg;
			recalleetarg = actor(AimTarget());
			
			int numberrecalled = 0;
			ActorIterator it = Level.CreateActorIterator(1000);
			Actor recallee;
			while (recallee = it.Next())
			{
				if (recallee.bISMONSTER && recallee.bFRIENDLY)
				{
					if (dydudebug_recalldisplays) Console.Printf("\cx(Recall All)\c- Name: %s (TID: %d)", recallee.GetClassName(), recallee.tid);
					Vector3 savedpos = (pos.x, pos.y, (pos.z + random(6.0,12.0)));
					recallee.SetOrigin(savedpos,false);
					recallee.angle += frandom(0.0,360.0);
					recallee.vel.x += frandom(-4.0,4.0);
					recallee.vel.y += frandom(-4.0,4.0);
					recallee.vel.z += frandom(4.0,8.0);
					numberrecalled++;
					if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) recallee.target = recalleetarg;
				}
			}
			
			if (numberrecalled > 0)
			{
				//A_StartSound("monstersummon", 161, CHANF_DEFAULT);
				A_SpawnItemEx("PlayerWhistle",0.0,0.0,32.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
				Vector3 savedpos2 = (pos.x, pos.y, pos.z+(height*0.25));
				Actor fog = Spawn("TeleportFogDD", savedpos2, ALLOW_REPLACE); 
				if (fog != null)
				{
					fog.scale.x *= frandom(0.375, 0.625);
					fog.scale.y *= frandom(0.375, 0.625);
					fog.A_SetRenderStyle(frandom(0.375, 0.625),STYLE_Add);
				}
				
				if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY)
				{
					A_DynamicMusic();
					A_PrintBold(String.Format("\cfRecalled all allies to your location and gave them a new target!"), frandom(0.685,0.8));
				}
				else
				{
					A_PrintBold(String.Format("\cfRecalled all allies to your location!"), frandom(0.685,0.8));
				}
			}
			else
			{
				A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
				A_PrintBold(String.Format("\cgRecall Failed: No creatures available to recall!"), frandom(0.685,0.8));
			}

			recalledall = false;
		}
		
		//****************************************************
		//*Flicker the Player when they survive a mortal hit *
		//****************************************************
		if (self.health == 1 && 
				(player.cheats & CF_BUDDHA || player.cheats & CF_BUDDHA2) 
				&& lasthealth > 1)
		{
			let SurviveItem = GiveTempMortalSurvive(FindInventory("GiveTempMortalSurvive"));
			if (SurviveItem) 
			{
				SurviveItem.times++;
				//Console.Printf("%d", SurviveItem.times);
			}
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.MercyInvulnOn = true;
				MiscItem.MercyInvulnTimer = 1210; // 1.5 Seconds
				MiscItem.MercyInvulnTimer += int(ActualLevel * 3.65);
				int AngerLevelNInc = randompick(1,1,2,2,2,3,3,3,4,4,5);
				A_GiveInventory("AngerLevelEventN",AngerLevelNInc);
				A_GiveInventory("AngerLevelEventNMin",AngerLevelNInc);
				if (Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1) A_GiveInventory("AngerLevelEvent",randompick(1,1,1,2,2,3));
				
				// IP Cost Reduction Bonuses do NOT occur for having Ultimate Buddha Mode [i.e. CF_BUDDHA2 flag] on by itself
				if (player.cheats & CF_BUDDHA)
				{
					if (ActualLevel >= (exex_mortalblowipcostlvlrequirement * 5))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer = 0;
						MiscItem.IPMortalBlowReduceTimer += 525;
						MiscItem.MortalBlowCritBoostTimer += 700; // 20s
					}
					else if (ActualLevel >= (exex_mortalblowipcostlvlrequirement * 4))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.2;
						MiscItem.IPMortalBlowReduceTimer += random(437,438);
						MiscItem.MortalBlowCritBoostTimer += 525; // 15s
					}
					else if (ActualLevel >= (exex_mortalblowipcostlvlrequirement * 3))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.4;
						MiscItem.IPMortalBlowReduceTimer += 350;
						MiscItem.MortalBlowCritBoostTimer += 385; // 11s
					}
					else if (ActualLevel >= (exex_mortalblowipcostlvlrequirement * 2))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.6;
						MiscItem.IPMortalBlowReduceTimer += random(262,263);
						MiscItem.MortalBlowCritBoostTimer += 280; // 8s
					}
					else if (ActualLevel >= (exex_mortalblowipcostlvlrequirement))
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.8;
						MiscItem.IPMortalBlowReduceTimer += 175;
						MiscItem.MortalBlowCritBoostTimer += 210; // 6s
					}
					else
					{
						if (MiscItem.IPNoGainTimer) MiscItem.IPNoGainTimer *= 0.98;
						MiscItem.IPMortalBlowReduceTimer += random(37,38);
						MiscItem.MortalBlowCritBoostTimer += 175; // 5s
					}
				}
				
				player.health = player.mo.health = 1;
			}
		}
		
		int basespeedvelsx;
		int basespeedvelsy;
		int basespeedvelsz;
		double basespeedvelsxd = 16.66666667;
		double basespeedvelsyd = 16.66666667;
		double basespeedvelszd = 16.66666667;

		basespeedvelsxd *= ForwardMove2;
		basespeedvelsyd *= SideMove2;
		basespeedvelszd *= 0;
		if (waterlevel >= 1) basespeedvelszd *= ForwardMove2;
		basespeedvelsx = (basespeedvelsxd * 65536);
		basespeedvelsy = (basespeedvelsyd * 65536);
		if (waterlevel >= 1) basespeedvelsz = (basespeedvelszd * 65536);

		double newspeedvelsxd = basespeedvelsxd * truespeed;
		double newspeedvelsyd = basespeedvelsyd * truespeed;
		double newspeedvelszd = 0;
		if (waterlevel >= 1) newspeedvelszd = basespeedvelszd * truespeed;
		int newspeedvelsx = newspeedvelsxd * 65536;
		int newspeedvelsy = newspeedvelsyd * 65536;
		int newspeedvelsz = 0;
		if (waterlevel >= 1) newspeedvelszd * 65536;
		if (dydudebug_playermove) Console.Printf("\cz WaterLevel: %d (WaterDepth: %.4f)\c-, \cz Angle: %.8f, Pitch: %.8f\c-, \czPosX: %d, PosY: %d, PosZ: %d\c-,\nVelX: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelY: %.8f/\cx%.8f\c- (%d/\cx%d\c-), VelZ: %.8f/\cx%.8f\c- (%d/\cx%d\c-)\c-", waterlevel, WaterDepth, (angle % 360), pitch, pos.x, pos.y, pos.z, vel.x, newspeedvelsxd, (vel.x * 65536), newspeedvelsx, vel.y, newspeedvelsyd, (vel.y * 65536), newspeedvelsy, vel.z, newspeedvelszd, (vel.z * 65536), newspeedvelsz);

		lasthealth = health;
		Super.Tick();
	}
	
	override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		if (cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		if (CanCrouch() && player.health > 0 && level.IsCrouchingAllowed())
		{
			if (dydudebug_crouchdisplays) Console.Printf("Can Crouch");
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;

				if (crouchdir == 0)
				{
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				}
				else if (cmd.buttons & BT_CROUCH)
				{
					player.crouching = 0;
				}
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(1);
					if (dydudebug_crouchdisplays) Console.Printf("CrouchMove(1)");
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-1);
					if (dydudebug_crouchdisplays) Console.Printf("CrouchMove(-1)");
				}
				if (dydudebug_crouchdisplays) Console.Printf("player.crouching: %d, player.crouchfactor: %.8f, crouchdir: %d", player.crouching, player.crouchfactor, crouchdir);
			}
		}
		else
		{
			player.Uncrouch();
			if (dydudebug_crouchdisplays) Console.Printf("Uncrouched");
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
		if (dydudebug_crouchdisplays) Console.Printf("player.crouching: %d, CanCrouch: %d, sv_allowcrouch: %d, IsCrouchingAllowed: %d", player.crouching, CanCrouch(), sv_allowcrouch, level.IsCrouchingAllowed());
	}

	override void CheckJump()
	{
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && player.onground && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (dydudebug_dospecialdmg) Console.Printf("DoSpecialDamage: DDPlayPawn, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	// Reset Breathing Scale
	void A_APPBreatheReset()
	{
		if (!isvoodoodoll) 
		{
			scaleymulti = 1.00;
			breathdirection = 0;
			breathframe = 0;
			A_SetScale(basexscale,baseyscale*scaleymulti);
		}
		if (dydudebug_playerbreathedisplays) Console.Printf("(A_APPBreatheReset)");
	}
	
	// Breathing Function
	void A_APPBreathe(double startpoint = 1.00625, double endpoint = 0.99375, double breathincrementbase = 0.0025, double basetics = 4)
	{
		if (!isvoodoodoll) 
		{
			double HealthBreathSpeed = 1.0;
			double HealthRatio; 
			int MaxHealthTrue = CountInv("PlayerMaxHP");
			if (dydudebug_playerbreathedisplays) Console.Printf("(breathe-check) MaxHealthTrue: %d", MaxHealthTrue);
			if (MaxHealthTrue > 0)
			{
				HealthRatio = (health * 1.00) / (MaxHealthTrue * 1.00);
				if (dydudebug_playerbreathedisplays) Console.Printf("(breathe-check) %.8f", HealthRatio);
				if (health > 0)
				{
					if (HealthRatio >= 1.75001) HealthBreathSpeed = 0.01;
					if (HealthRatio >= 1.62501 && HealthRatio <= 1.75000) HealthBreathSpeed = 0.175;
					if (HealthRatio >= 1.50001 && HealthRatio <= 1.62500) HealthBreathSpeed = 0.34;
					if (HealthRatio >= 1.37501 && HealthRatio <= 1.50000) HealthBreathSpeed = 0.505;
					if (HealthRatio >= 1.25001 && HealthRatio <= 1.37500) HealthBreathSpeed = 0.67;
					if (HealthRatio >= 1.12501 && HealthRatio <= 1.25000) HealthBreathSpeed = 0.835;
					if (HealthRatio >= 0.87501 && HealthRatio <= 1.12500) HealthBreathSpeed = 1.00;
					if (HealthRatio >= 0.75001 && HealthRatio <= 0.87500) HealthBreathSpeed = 1.165;
					if (HealthRatio >= 0.62501 && HealthRatio <= 0.75000) HealthBreathSpeed = 1.33;
					if (HealthRatio >= 0.50001 && HealthRatio <= 0.62500) HealthBreathSpeed = 1.495;
					if (HealthRatio >= 0.37501 && HealthRatio <= 0.50000) HealthBreathSpeed = 1.66;
					if (HealthRatio >= 0.25001 && HealthRatio <= 0.37500) HealthBreathSpeed = 1.825;
					if (HealthRatio >= 0.12501 && HealthRatio <= 0.25000) HealthBreathSpeed = 1.99;
					if (HealthRatio >= 0.00001 && HealthRatio <= 0.12500) HealthBreathSpeed = 2.155;
					if (Health == 1) HealthBreathSpeed = 2.485;
				}
				breathincrementbase *= HealthBreathSpeed;
				if (dydudebug_playerbreathedisplays) Console.Printf("(breathe-check) breathincrementbase: %d", breathincrementbase);
				
				double ticmulti = 1.00 * (tics / basetics);
				breathincrementbase *= ticmulti;
				if (dydudebug_playerbreathedisplays) Console.Printf("(breathe-check) breathincrementbase: %d", breathincrementbase);

				if (breathdirection == 0)
				{
					breathframe++;
					scaleymulti -= breathincrementbase;
					if (scaleymulti <= endpoint) { scaleymulti = endpoint; breathdirection = 1; breathframe = 0; }
				}
				else
				{
					breathframe++;
					scaleymulti += breathincrementbase;
					if (scaleymulti >= startpoint) { scaleymulti = startpoint; breathdirection = 0; breathframe = 0; }
				}
				if (dydudebug_playerbreathedisplays) Console.Printf("(breathe-check) breathdirection: %d", breathdirection);

				if (dydudebug_playerbreathedisplays)
				{
					Console.Printf("scaleymulti = %.8f, breathincrementbase = %.8f, breathdirection = %d, breathframe = %d, HealthBreathSpeed = %.8f, ticmulti = %.8f, actualtics = %d, basetics = %d [gametic: %d]", 
													scaleymulti, 
													breathincrementbase, 
													breathdirection, 
													breathframe, 
													HealthBreathSpeed, 
													ticmulti, 
													tics, 
													basetics,
													gametic);
				}
			}
			else
			{
				scaleymulti = 1.00;
				breathdirection = 0;
				breathframe = 0;
			}
			double sizemult = 1.0;
			if (A_CheckUOHYM()) sizemult = 1.166666666666667;
			A_SetScale((basexscale*sizemult),((baseyscale*sizemult)*scaleymulti));
		}
		if (dydudebug_playerbreathedisplays) Console.Printf("(A_APPBreathe)");
	}
	
	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = false;
				if (bNOBLOODDECALS) bNOBLOODDECALS = false;
			}
		}
		else
		{
			if (flags & DMG_EXPLOSION)
			{
			}
			else
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = true;
					bNOBLOODDECALS = true;
				}
			}
		}
		if (dydudebug_playerdamagemobj) Console.Printf("(A_CheckNeverBleed [player], type: %d, damage: %d)", type, damage);
	}
	
	bool CheckFallDamageDMobj()
	{
		bool takefalldamage = true;
		if (bFLY || bNOGRAVITY || waterlevel >= 1) 
		{
			takefalldamage = false;
			if (dydudebug_playerdamagemobj) Console.Printf("bFLY: %d, bNOGRAVITY: %d, waterlevel: %d (WaterDepth: %.4f)", bFLY, bNOGRAVITY, waterlevel, WaterDepth);
		}
		else
		{
			bool onground2 = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);
			if (wasongroundprevtic == onground2)
			{
				takefalldamage = false;
				if (dydudebug_playerdamagemobj) Console.Printf("wasongroundprevtic: %d, onground2: %d", wasongroundprevtic, onground2);
			}
		}
		if (dydudebug_playerdamagemobj) Console.Printf("takefalldamage: %d", takefalldamage);
		
		return takefalldamage;
	}
	
	double A_DefenseIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, bool bellefishzap, bool isbarrierbeam)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		string infl, sour, vict;
		vict = GetClassName();
		string nm, nn, no, np, nq, nr;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = 0.00;
		if (damage > 0)
		{
			if (inflictor == null && source == null)
			{
			}
			else
			{
				if (mod == 'Dashing') PlayerDefenseIgnoreFactor += (0.2 * (1.00 - PlayerDefenseIgnoreFactor));
				if (mod == 'DashingBG') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));
				if (mod == 'DashingSD') PlayerDefenseIgnoreFactor += (0.375 * (1.00 - PlayerDefenseIgnoreFactor));
				
				if (A_CheckUOHYM())
				{
					nm = "SkinStealer";
					nn = "IllusGhost";
					if ((inflictor && 
							(inflictor.GetClassName() == nm || 
								inflictor.GetClassName() == nn)) ||
							(source && 
							(source.GetClassName() == nm || 
								source.GetClassName() == nn)))
					{
						if (!CountInv("MysteryItem2"))
						{
							PlayerDefenseIgnoreFactor += (0.875 * (1.00 - PlayerDefenseIgnoreFactor));
						}
					}
				}
				
				if (!CountInv("DinahTrueIPState")) // The Flower Crown IP Mode Negates most Defense Ignoring attacks :V
				{
					if ((inflictor && inflictor.CountInv("LDLegendaryMonsterTransformed")) || 
							(source && source.CountInv("LDLegendaryMonsterTransformed"))) 
					{
						double LegendaryIgnoreDefenseFactor = 0.50;
						PlayerDefenseIgnoreFactor += (LegendaryIgnoreDefenseFactor * (1.00 - PlayerDefenseIgnoreFactor));
					}
					
					double PikeFactor = 0.0;
					if (mod == 'Zap') 
					{
						if ((inflictor && inflictor.CountInv("SpellDiaryEE")) || 
								(source && source.CountInv("SpellDiaryEE"))) PikeFactor += (frandom(0.25,0.334) * (1.00 - PikeFactor));   
						if (CountInv("SpellDiaryEE")) PikeFactor -= (frandom(0.25,0.334) * (1.00 - PikeFactor));
						PlayerDefenseIgnoreFactor += (PikeFactor * (1.00 - PlayerDefenseIgnoreFactor));
					}

					double PikeAOEFactor = 0.334;
					if (mod == 'Zap') 
					{
						if ((inflictor && inflictor.CountInv("SpellDiaryEE")) || 
								(source && source.CountInv("SpellDiaryEE"))) PikeAOEFactor += (frandom(0.25,0.334) * (1.00 - PikeAOEFactor));   
						if (CountInv("SpellDiaryEE")) PikeAOEFactor -= (frandom(0.25,0.334) * (1.00 - PikeAOEFactor));
						PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
						if (flags & DMG_EXPLOSION) PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
						if (flags & DMG_INFLICTOR_IS_PUFF && (PikePuff(inflictor) || PikePuff(source))) PlayerDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					}
					
					double LeadFactor = 0.000;
					
					double temp = (1.00 - LeadFactor);
					if (CountInv("PowerWineBuffIPMaximum")) LeadFactor += (temp * frandom(0.5,0.75));
					else if (CountInv("PowerWineBuffIPStrongestEven")) LeadFactor += (temp * frandom(0.375,0.5));
					else if (CountInv("PowerWineBuffStrongestEven")) LeadFactor += (temp * frandom(0.225,0.3));
					else if (CountInv("PowerWineBuffIPStrongest")) LeadFactor += (temp * frandom(0.25,0.375));
					else if (CountInv("PowerWineBuffStrongest")) LeadFactor += (temp * frandom(0.15,0.225));
					else if (CountInv("PowerWineBuffIPStrong")) LeadFactor += (temp * frandom(0.125,0.25));
					else if (CountInv("PowerWineBuffStrong")) LeadFactor += (temp * frandom(0.075,0.15));
					else if (CountInv("PowerWineBuffIPWeak")) LeadFactor += (temp * frandom(0.0,0.125));
					else if (CountInv("PowerWineBuffWeak")) LeadFactor += (temp * frandom(0.0,0.075));
					if (mod == 'Lead') PlayerDefenseIgnoreFactor += (LeadFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
					if (mod == 'Beats') PlayerDefenseIgnoreFactor += (BeatsFactor * (1.00 - PlayerDefenseIgnoreFactor));
					double BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
					if (mod == 'Beats' && flags & DMG_EXPLOSION) PlayerDefenseIgnoreFactor += (BeatsAOEFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double BarrelFactor = 0.50;
					if (TrueGameSkill <= SKILL_VERY_EASY)	BarrelFactor = 0.0;
					if (TrueGameSkill == SKILL_EASY)			BarrelFactor = 0.25;
					if (TrueGameSkill == SKILL_NORMAL)		BarrelFactor = 0.5;
					if (TrueGameSkill == SKILL_HARD)			BarrelFactor = 0.75;
					if (TrueGameSkill >= SKILL_VERY_HARD)	BarrelFactor = 1.0;
					if ((ExplosiveBarrel(inflictor) || 
							 ExplosiveBarrel(source) || 
							 Pod(inflictor) || 
							 Pod(source)) && 
							(flags & DMG_EXPLOSION || 
							 mod == 'Explosive' || 
							 mod == 'ExplosiveImpact' || 
							 mod == 'CC_Firecracker')) PlayerDefenseIgnoreFactor += (BarrelFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double SuckFactor = 0.334;
					if (mod == 'Suck') PlayerDefenseIgnoreFactor += (SuckFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double PuddingFactor = 0.667;
					if (PuddingDog(inflictor) || PuddingPup(inflictor) || PupGrenade(inflictor) || PuddingDog(source) || PuddingPup(source) || PupGrenade(source)) PlayerDefenseIgnoreFactor += (PuddingFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					if (bellefishzap)
					{
						if (CountInv("PowerNoDrown"))
						{
							if (waterlevel >= 2) PlayerDefenseIgnoreFactor += (0.025 * (1.00 - PlayerDefenseIgnoreFactor));
															else PlayerDefenseIgnoreFactor += (0.450 * (1.00 - PlayerDefenseIgnoreFactor));
						}
						else PlayerDefenseIgnoreFactor += (0.5 * (1.00 - PlayerDefenseIgnoreFactor));
					}

					double RailFactor = frandom(0.3,0.334);
					if (mod == 'Railgun') PlayerDefenseIgnoreFactor += (RailFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					double HWShieldFactor = 0.125;
					if (EvilWarriorShieldBall(inflictor) || EvilWarriorShieldBall(source) ||
							HellWarriorBall2(inflictor) || HellWarriorBall2(source)) PlayerDefenseIgnoreFactor += (HWShieldFactor * (1.00 - PlayerDefenseIgnoreFactor));
					
					if ((source && PushyArchAngel(source)) || (inflictor && PushyArchAngel(inflictor)))
					{
						PlayerDefenseIgnoreFactor += (frandom(0.000,0.250) * (1.00 - PlayerDefenseIgnoreFactor));
					}
				}
				
				if (isbarrierbeam) PlayerDefenseIgnoreFactor += (frandom(0.9,1.0) * (1.00 - PlayerDefenseIgnoreFactor));
			}
			
			double EggFactor = 0.00;
			if ((EvilEggShot(inflictor) || EvilEggShot(source))) EggFactor = 0.125;
			if ((ChookEggShot(inflictor) || ChookEggShot(source))) EggFactor = 0.125;
			if ((BigChookGrenade(inflictor) || BigChookGrenade(source))) EggFactor = 0.125;
			if ((EvilEggGrenade(inflictor) || EvilEggGrenade(source))) EggFactor = 0.334;
			if ((ChookEggGrenade(inflictor) || ChookEggGrenade(source))) EggFactor = 0.334;
			if ((ChookGrenade(inflictor) || ChookGrenade(source))) EggFactor = 0.334;
			if ((EvilEggMini(inflictor) || EvilEggMini(source))) EggFactor = 0.75;
			if ((ChookEggMini(inflictor) || ChookEggMini(source))) EggFactor = 0.75;
			if (EggFactor > 0.00) PlayerDefenseIgnoreFactor += (EggFactor * (1.00 - PlayerDefenseIgnoreFactor));
			
			double BuffFactor = 0.00;
			if (CountInv("PowerGuard")) BuffFactor += 0.75; // Guard Sphere
			if (CountInv("PowerWeaken")) BuffFactor -= 0.375;
			if (BuffFactor > 0.00) PlayerDefenseIgnoreFactor = (PlayerDefenseIgnoreFactor * (1.00 - BuffFactor));
			
			double FoodFactor = 0.00;
			if (CountInv("PowerRoastBuff")) FoodFactor += 0.0625; // Pig Roast
			if (CountInv("PowerMealBuff")) FoodFactor += 0.25; // Gourmet Meal
			if (CountInv("PowerMeal2Buff")) FoodFactor += 0.0625; // Turkey Dinner
			if (FoodFactor > 0.00) PlayerDefenseIgnoreFactor = (PlayerDefenseIgnoreFactor * (1.00 - FoodFactor));
		}
		
		double CricketFactor = 0.00;
		if ((inflictor && Hammerduck(inflictor)) ||
				(source && Hammerduck(source)))
		{
			double temp = (CountInv("MonsterLevel") * 0.0025);
			if (temp > 0.50) temp = 0.50;
			CricketFactor += (temp * (1.00 - CricketFactor));
		}
		else
		if ((inflictor && GameMother(inflictor)) ||
				(source && GameMother(source)))
		{
			double temp = (CountInv("MonsterLevel") * 0.005);
			if (temp > 1.00) temp = 1.00;
			CricketFactor += (temp * (1.00 - CricketFactor));
		}
		PlayerDefenseIgnoreFactor += (CricketFactor * (1.00 - PlayerDefenseIgnoreFactor));
		
		if (mod == 'PSI') 
		{
			if (!CountInv("DinahTrueIPState"))
			{
				double PSIFactor = 0.5;
				PlayerDefenseIgnoreFactor += (PSIFactor * (1.00 - PlayerDefenseIgnoreFactor));
			}
		}

		if (PlayerDefenseIgnoreFactor <= 0.0) PlayerDefenseIgnoreFactor = 0.0;
		if (PlayerDefenseIgnoreFactor > 1.00) PlayerDefenseIgnoreFactor = 1.00;
		if (dydudebug_playerdamagemobj) Console.Printf("\c[orange]PlayerDefenseIgnoreFactor: %.8f", PlayerDefenseIgnoreFactor);

		return PlayerDefenseIgnoreFactor;
	}
	
	double A_ArmorIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, bool bellefishzap, bool isbarrierbeam)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		string infl, sour, vict;
		string nm, nn, no, np, nq, nr;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		// Intended to ignore aspects of armor items
		PlayerArmorIgnoreFactor = 0.00;
		if (isbarrierbeam) PlayerArmorIgnoreFactor += (frandom(0.75,1.00) * (1.00 - PlayerArmorIgnoreFactor));
		
		if (source && exex_enemyarmorignorefactor >= 0.001)
		{
			int ignoretier = 0;
			if (dydudebug_playerdamagemobj) Console.Printf("\c[orange]Enemy Bypasses armor [attempt]");
			EECreature EESource;
			EESource = EECreature(source);
			if (EESource)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("\c[sapphire]EESource found [armor bypass]");
				int rand1;
				double randarmign;
				
				bool specset;
				if (A_CheckUOHYM())
				{
					nm = "SkinStealer";
					nn = "IllusGhost";
					if (source.GetClassName() == nm || source.GetClassName() == nn)
					{
						if (!CountInv("MysteryItem2"))
						{
							ignoretier = 3;
							rand1 += 10 + ((source.CountInv("MonsterLevel")) * 1.0);
							randarmign += (frandompick(0.030,0.035,0.04,0.045,0.05) * exex_enemyarmorignorefactor);
						}
						else
						{
							ignoretier = -3;
							rand1 += randompick(0,0,0,0,0,1,1,1) + ((source.CountInv("MonsterLevel")) * 0.015625);
							randarmign += ((frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * 0.125) * exex_enemyarmorignorefactor);
						}
						specset = true;
					}
				}
				
				if (!specset)
				{
					// Tier 3 Enemies [i.e. extremely-high armor bypass, usually very powerful/ancient/eldritch named bosses [ol' Nyarly]
					if (sour == "Nyarlathotep" ||
							mewantsacrifice(EESource) ||
							(EvilDinahEE(EESource) && EESource.TID == 447 && Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1))
					{
						ignoretier = 3;
						rand1 += 10 + ((source.CountInv("MonsterLevel")) * 1.0);
						randarmign += (frandompick(0.030,0.035,0.04,0.045,0.05) * exex_enemyarmorignorefactor);
					}
					else // Tier 2 Enemies [i.e. very-high armor bypass, usually named bosses [Serpent Riders, Pennywise in HTC2, and the Dinah Doppelgangers] V:]
					if (sour == "PennywiseBoss" ||
							sour == "ThamuzNew" ||
							sour == "TchernobogNew" ||
							sour == "Tchernobog" ||
							sour == "TchernoDemon" ||
							sour == "CyberBog" ||
							sour == "NyarlathotepLesser" ||
							sour == "StarSpawn" ||
							sour == "SpiderGod" ||
							Delila_Boss(EESource) ||
							Delila_BossClone(EESource) ||
							EvilDinah(EESource) || 
							EvilDinahEE(EESource) || 
							DSparilUnmountedNew(EESource) || 
							KoraxNew(EESource))
					{
						ignoretier = 2;
						rand1 += 5 + ((source.CountInv("MonsterLevel")) * 0.5);
						randarmign += (frandompick(0.015,0.0175,0.02,0.0225,0.025) * exex_enemyarmorignorefactor);
					}
					else // Tier 1 Enemies [i.e. medium-high armor bypass, usually standard boss/mini-bosses, and BlackBears V:]
					if (sour == "BlackBearNew" ||
							sour == "Dhole" ||
							(sour == "ShadowBeast" && Wads.CheckNumForName("EE-STAEONS", Wads.ns_global, -1, true) != -1) ||
							sour == "SpiderGodling" ||
							RailArachnotron(EESource) ||
							ArchvileNew(EESource) ||
							Diabloist(EESource) ||
							FlyingBalrogDVDS(EESource) ||
							BruiserDemon(EESource) ||
							CyBruiser(EESource) ||
							ArchonOfHell(EESource) ||
							PyroDemon(EESource) ||
							FighterBossNew(EESource) ||
							ClericBossNew(EESource) ||
							MageBossNew(EESource) ||
							Minotaur(EESource) ||
							MinotaurFriend(EESource) ||
							CyberdemonNew(EESource) ||
							Annihilator(EESource) ||
							SpiderMastermindNew(EESource) ||
							Demolisher(EESource) ||
							HandMotherVac(EESource) ||
							HandMotherPhaseA(EESource) ||
							HandMotherPhaseB(EESource) ||
							HandMotherPhaseC(EESource) ||
							GlobeMother(EESource) ||
							MossMother(EESource) ||
							SphinxMother(EESource) ||
							RoseMother(EESource) ||
							GameMother(EESource) ||
							Teacher_Krag(EESource) ||
							Teacher_Lauritz(EESource) ||
							Teacher_Quis(EESource) ||
							Teacher_Jorg(EESource) ||
							JorgSphereCannon(EESource) ||
							Teacher_Vokter(EESource) ||
							Tempest_Boss(EESource) ||
							Tempest_BossClone(EESource) ||
							DSparilMountedNew(EESource))
					{
						ignoretier = 1;
						rand1 += randompick(2,3) + ((source.CountInv("MonsterLevel")) * 0.25);
						randarmign += (frandompick(0.0075,0.00875,0.01,0.01125,0.0125) * exex_enemyarmorignorefactor);
					}
					else // Tier -1 Enemies (enemies with WEAKER armor bypass on average versus even Tier 0s :V)
					if (sour == "EvilDeadHandNew" ||
							sour == "JumpingSkullNew" ||
							sour == "TinyBingoNew" ||
							sour == "BabyClownNew" ||
							sour == "BabyClown2New" ||
							sour == "LengSpiderling" ||
							sour == "PossessedBalloonNew")
					{
						ignoretier = -1;
						rand1 += randompick(0,0,0,0,0,1,1,1) + ((source.CountInv("MonsterLevel")) * 0.0625);
						randarmign += ((frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * 0.5) * exex_enemyarmorignorefactor);
					}
					else // Tier 0 Enemies [i.e. average armor bypass]
					{
						ignoretier = 0;
						rand1 += randompick(1,1,1,2) + ((source.CountInv("MonsterLevel")) * 0.125);
						randarmign += (frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * exex_enemyarmorignorefactor);
					}
				}
				
				if (source.bBOSS)
				{
					rand1 *= int(frandom(1.75,2.25));
					randarmign *= frandom(1.75,2.25);
				}
				
				double finalsourceignore = (random(0,rand1) * randarmign);
				if (finalsourceignore > 0.75) finalsourceignore = 0.75;
				PlayerArmorIgnoreFactor += (finalsourceignore * (1.00 - PlayerArmorIgnoreFactor));
				if (dydudebug_playerdamagemobj) Console.Printf("Tier %d Armor Ignoring Type: [Level: %d], rand1: %d, randarmign: %.8f, PlayerArmorIgnoreFactor: %.8f", ignoretier, source.CountInv("MonsterLevel"), rand1, randarmign, PlayerArmorIgnoreFactor);
			}
		}
		
		if (inflictor)
		{
			bool specset;
			double randarmign;
			int rand1;
			int ignoretier = 0;
			if (A_CheckUOHYM())
			{
				nm = "SkinStealer";
				nn = "IllusGhost";
				if (inflictor.GetClassName() == nm || inflictor.GetClassName() == nn)
				{
					if (!CountInv("MysteryItem2"))
					{
						ignoretier = 3;
						rand1 += 10 + ((source.CountInv("MonsterLevel")) * 1.0);
						randarmign += (frandompick(0.030,0.035,0.04,0.045,0.05) * exex_enemyarmorignorefactor);
					}
					else
					{
						ignoretier = -3;
						rand1 += randompick(0,0,0,0,0,1,1,1) + ((source.CountInv("MonsterLevel")) * 0.015625);
						randarmign += ((frandompick(0.00375,0.004375,0.005,0.0056125,0.00625) * 0.125) * exex_enemyarmorignorefactor);
					}
					specset = true;
				}
				
				double finalsourceignore = (random(0,rand1) * randarmign);
				if (finalsourceignore > 0.75) finalsourceignore = 0.75;
				PlayerArmorIgnoreFactor += (finalsourceignore * (1.00 - PlayerArmorIgnoreFactor));
				if (dydudebug_playerdamagemobj) Console.Printf("Tier %d Armor Ignoring Type: [Level: %d], rand1: %d, randarmign: %.8f, PlayerArmorIgnoreFactor: %.8f", ignoretier, source.CountInv("MonsterLevel"), rand1, randarmign, PlayerArmorIgnoreFactor);
			}
			
			if (infl == 'RecordShot' || infl == 'BadRecordShot') PlayerArmorIgnoreFactor += (frandom(0.225,0.275) * (1.00 - PlayerArmorIgnoreFactor));
			if (infl == 'HellWarriorBall2') PlayerArmorIgnoreFactor += (frandom(0.1125,0.1375) * (1.00 - PlayerArmorIgnoreFactor));
		}
		
		if (mod == 'Deadlight') 
		{
			if ((inflictor && infl == "PennywiseBoss") || 
					(source && sour == "PennywiseBoss")) PlayerArmorIgnoreFactor += (frandom(0.45,0.55) * (1.00 - PlayerArmorIgnoreFactor));

			if ((inflictor && infl == "BeefyNew") || 
					(source && sour == "BeefyNew")) PlayerArmorIgnoreFactor += (frandom(0.225,0.275) * (1.00 - PlayerArmorIgnoreFactor));
		}

		if (PlayerArmorIgnoreFactor <= 0.0) PlayerArmorIgnoreFactor = 0.0;
		if (PlayerArmorIgnoreFactor > 1.0) PlayerArmorIgnoreFactor = 1.0;
		if (dydudebug_playerdamagemobj) Console.Printf("\c[darkgreen]PlayerArmorIgnoreFactor: %.8f", PlayerArmorIgnoreFactor);
		
		if (CountInv("PowerGuard")) PlayerArmorIgnoreFactor *= 0.25;
		if (CountInv("PowerWeaken")) PlayerArmorIgnoreFactor *= 4;
		
		if (CountInv("KnightGownIP1Buff")) PlayerArmorIgnoreFactor *= 0.5;
		if (CountInv("KnightGownIP2Buff")) PlayerArmorIgnoreFactor *= 0.25;
		if (CountInv("KnightGownIP3Buff")) PlayerArmorIgnoreFactor *= 0.125;
		if (CountInv("KnightGownIP4Buff")) PlayerArmorIgnoreFactor *= 0.0625;
		
		if (MiscItem)
		{
			if (MiscItem.WineDefTier == 1) PlayerArmorIgnoreFactor *= 0.995;
			else if (MiscItem.WineDefTier == 2) PlayerArmorIgnoreFactor *= 0.985;
			else if (MiscItem.WineDefTier == 3) PlayerArmorIgnoreFactor *= 0.970;
			else if (MiscItem.WineDefTier == 4) PlayerArmorIgnoreFactor *= 0.950;
			else if (MiscItem.WineDefTier == 5) PlayerArmorIgnoreFactor *= 0.925;
			else if (MiscItem.WineDefTier == -1) PlayerArmorIgnoreFactor *= 0.975;
			else if (MiscItem.WineDefTier == -2) PlayerArmorIgnoreFactor *= 0.925;
			else if (MiscItem.WineDefTier == -3) PlayerArmorIgnoreFactor *= 0.850;
			else if (MiscItem.WineDefTier == -4) PlayerArmorIgnoreFactor *= 0.750;
			else if (MiscItem.WineDefTier == -5) PlayerArmorIgnoreFactor *= 0.625;
		}
		
		if (MiscItem)
		{
			if (MiscItem.armoritemdifficulty == 1) PlayerArmorIgnoreFactor *= 0.8;
			if (MiscItem.armoritemdifficulty == 2) PlayerArmorIgnoreFactor *= 0.75;
			if (MiscItem.armoritemdifficulty >= 3) PlayerArmorIgnoreFactor *= 0.5;
		}

		return PlayerArmorIgnoreFactor;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int origdmg = damage;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let weapon = player.ReadyWeapon;
		if (inflictor && MorphProjectile(inflictor) || source && MorphProjectile(source)) A_GiveInventory("HitByMorphProj",1);
		
		if (mod == 'Drowning')
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
		}
		if (mod == 'HeelJackpotExplosion') return 0;
		if (mod == 'Zap')
		{
			if((inflictor && inflictor.CountInv("SpellDiaryEE")) || 
				 (source && source.CountInv("SpellDiaryEE"))) damage *= frandom(1.25,1.334);
			if (CountInv("SpellDiaryEE")) damage *= frandom(0.667,0.75);
		}
		
		if ((mod == 'Explosive' ||
				 mod == 'ExplosiveImpact' || 
				 mod == 'CC_Firecracker' ||
				 mod == 'HeelExplosion' ||
				 mod == 'CherryBomb' ||
				 mod == 'Spinner' ||
				 mod == 'BRocket' ||
				 mod == 'Popper') ||
				flags & DMG_EXPLOSION)
		{
			if (MiscItem)
			{
				int HellWarriorShieldLevel = MiscItem.HellWarriorShieldLevel;
				double randvar1;
				double randvar2;
				if (CountInv("EWShieldDefendMode"))
				{
					if (CountInv("EWShieldDefendModeExtra"))
					{
						randvar1 = (0.125 - (HellWarriorShieldLevel * 0.00625));
						randvar2 = (0.1667 - (HellWarriorShieldLevel * 0.008334));
						damage *= frandom(randvar1,randvar2);
						if (random(1,2) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,4) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,8) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					}
					else
					{
						randvar1 = (0.25 - (HellWarriorShieldLevel * 0.0125));
						randvar2 = (0.3334 - (HellWarriorShieldLevel * 0.01667));
						damage *= frandom(randvar1,randvar2);
						if (random(1,2) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,4) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,8) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					}
				}
				else
				{
					if (CountInv("EWShieldIdleMode"))
					{
						randvar1 = (0.50 - (HellWarriorShieldLevel * 0.025));
						randvar2 = (0.6667 - (HellWarriorShieldLevel * 0.03334));
						damage *= frandom(randvar1,randvar2);
						if (random(1,2) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,4) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
						if (random(1,8) <= int(1 + (HellWarriorShieldLevel * 0.1))) damage *= frandom(randvar1,randvar2);
					}
				}
			}
		}
		
		if (Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1)
		{
			if (mod == 'StunningHead')
			{
				if (source) { }
				else
				{
					damage *= frandom(0.025,0.0334);
				}
			}
			if (mod == 'ZBloodBullet') mod = "Hitscan";
			if (mod == 'Axe') mod = "Chop";
			if (mod == 'SpecialFire') mod = 'Fire';
			if (CountInv("PlayingCCards") && mod == 'BaneMelee') 
			{
				mod = 'Melee';
				damage *= 1.5;
			}
			if (mod == 'Flare') 
			{
				mod = "Fire";
				damage *= 3.0;
			}
			if (mod == 'Blast' ||
					mod == 'CultistTNT' ||
					((source && source.GetClassName() == "CCards_Actor_DeathExplosion") ||
					(inflictor && inflictor.GetClassName() == "CCards_Actor_DeathExplosion")) ||
					((source && source.GetClassName() == "CCards_NukeExplosion") ||
					(inflictor && inflictor.GetClassName() == "CCards_NukeExplosion")))
			{
				mod = "Explosive";
			}
			if ((source && source.CountInv("lolewatdisdo")) || 
					(inflictor && inflictor.CountInv("lolewatdisdo"))) damage *= frandompick(1.1875,1.375,1.375,1.375,1.375,1.375,1.375,1.375,1.375,1.75);
			if ((source && source.CountInv("gimmesacrificelule")) || 
					(inflictor && inflictor.CountInv("gimmesacrificelule"))) damage *= frandompick(1.25,1.5,1.5,1.5,1.5,1.5,1.5,1.5,1.5,2.0);
		}
		
		let NoU = D_NoUCard(FindInventory("D_NoUCard"));
		if (NoU)
		{
			A_StopSound(104);
			A_StartSound("ReflectDmg1",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
			flags |= DMG_NO_ARMOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_THRUSTLESS;
			//Console.Printf("NoU Found!");
			if (source && source != self)
			{
				//Console.Printf("NoU Found! [source]");
				source.A_StopSound(104);
				source.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
				source.DamageMobj(self, self, damage, mod, flags, angle);
			}
			else
			{
				if (inflictor && inflictor != self)
				{
					//Console.Printf("NoU Found! [inflictor]");
					inflictor.A_StopSound(104);
					inflictor.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
					inflictor.DamageMobj(self, self, damage, mod, flags, angle);
				}
			}
			damage = 0;
			return 0;
		}

		bool isbarrierbeam = false;
		if (BarrierBeam(inflictor) || BarrierBeam(source)) isbarrierbeam = true;
		if (mod == 'Falling')
		{
			if (CheckFallDamageDMobj()) 
			{
				double landdmgfactor = (1.0 - player.crouchfactor);
				landdmgfactor *= frandompick(0.1,0.2,0.2,0.25,0.25,0.25,0.3334,0.3334,0.3334,0.3334,0.3334,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.6667,0.6667,0.6667,0.6667,0.6667,0.75,0.75,0.75,0.8,0.8,0.9);
				landdmgfactor = (1.0 - landdmgfactor);
				int olddmg = damage;
				damage = floor(damage * landdmgfactor);
				if (A_CheckDDGame())
				{
					double PerkFactor2 = 0.00;
					if (MiscItem.DD_RoseMother) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_GameMother) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_MossMother) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_GlobeMother) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_SphinxMother) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_HandMother1) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_HandMother2) PerkFactor2 -= 0.01875;
					if (MiscItem.DD_TrueHandMother) PerkFactor2 -= 0.01875;
					if (MiscItem.AFD_Krag) PerkFactor2 -= 0.025;
					if (MiscItem.AFD_Quisling) PerkFactor2 -= 0.025;
					if (MiscItem.AFD_Lauritz) PerkFactor2 -= 0.025;
					if (MiscItem.AFD_Jorgensen1) PerkFactor2 -= 0.025;
					if (MiscItem.AFD_Jorgensen2) PerkFactor2 -= 0.025;
					if (MiscItem.AFD_JorgCannon) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_Fafnir) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_FractalHens) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_HandMothers) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_ForsakenJorg) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_EvilDinah) PerkFactor2 -= 0.025;
					if (MiscItem.CoS_Tempest) PerkFactor2 -= 0.025;
					PerkFactor2 *= 2.5;
					if (TrueGameSkill <= SKILL_VERY_EASY)	PerkFactor2 *= 1.5;
					if (TrueGameSkill == SKILL_EASY)			PerkFactor2 *= 1.25;
					if (TrueGameSkill == SKILL_NORMAL)		PerkFactor2 *= 1.0;
					if (TrueGameSkill == SKILL_HARD)			PerkFactor2 *= 0.75;
					if (TrueGameSkill >= SKILL_VERY_HARD)	PerkFactor2 *= 0.5;
					if (PerkFactor2 <= 0.125) PerkFactor2 = 0.125;
					PerkFactor2 *= exex_nrpggeneraleffect;
					if (PerkFactor2 < 0.00) PerkFactor2 = 0.00;
					PerkFactor2 += 1.0;
					damage = floor(damage * PerkFactor2);
				}
				flags |= DMG_NO_FACTOR;
				flags |= DMG_NO_PROTECT;
				flags |= DMG_NO_ENHANCE;
				flags |= DMG_THRUSTLESS;
				if (dydudebug_playerdamagemobj) Console.Printf("Fall Damage [Crouching]: %d [prev: %d] (Factor: %.8f)", damage, olddmg, landdmgfactor);
			}
			else
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Fall Damage Nullified");
				return -1;
			}
		}
		
		if (CountInv("EvadeAnAttack"))
		{
			if (flags & DMG_NO_DODGE)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Evasion - DMG_NO_DODGE");
			}
			else
			{
				if (EggShot(inflictor) ||
						EggGrenade(inflictor) ||
						EggMini(inflictor))
				{
					if (dydudebug_playerdamagemobj) Console.Printf("Evasion (Eggs) - no damage");
					return 0;
				}
				else 
				if (isbarrierbeam) 
				{
					flags |= DMG_NO_DODGE;
					A_SetInventory("EvadeAnAttack",0);
				}
				else
				{
					if (!(((source == null && inflictor == null) &&
							(mod == 'Slime' || 
							 mod == 'Lava' || 
							 mod == 'Magma' || 
							 mod == 'IceWater' || 
							 mod == 'ShockFloor' || 
							 mod == 'Crush' || 
							 mod == 'Drowning' || 
							 mod == 'SigilDrain' || 
							 mod == 'Falling')) || mod == 'SigilDrain'))
					{
						A_StartSound("player/dodge",305,CHANF_OVERLAP|CHANF_LOCAL,frandom(0.75,1.25),ATTN_NORM,frandom(0.75,1.25));
						if (exex_playerdmglog)
						{
							if (mod == 'NONE') mod = 'Typeless';
							string combatlogmsg = "\c[sapphire]*\c- Dodged";
							if (source) // Has a source
							{
								combatlogmsg.AppendFormat(" \c[purple]%s\c-", source.GetTag());
								if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
							}
							else
							if (inflictor) // No source, but has an inflictor
							{
								combatlogmsg.AppendFormat(" \c[brick]%s!", inflictor.GetTag());
							}
							else // If no source OR inflictor
							{
								if (mod == 'Slime') combatlogmsg.AppendFormat(" a damaging surface");
								else if (mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'ShockFloor') combatlogmsg.AppendFormat(" a damaging surface");
								else if (mod == 'Crush') combatlogmsg.AppendFormat(" a crushing ceiling");
								combatlogmsg.AppendFormat("!");
							}
							combatlogmsg.AppendFormat(" [%s]", mod);
							if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
							if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
							Console.Printf(combatlogmsg);
						}
						if (dydudebug_playerdamagemobj) Console.Printf("Evasion - no damage");
						return 0;
					}
					else
					{
						int prevdmg = damage;
						damage *= (frandompick(0.2,0.2,0.2,0.25,0.25,0.25,0.25,0.25,0.25,0.334) * randompick(1,1,1,2,2,2,2,2,2,3));
						if (damage > prevdmg) damage = prevdmg;
					}
				}
			}
		}

		class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
		string nm, nn, no, np;
		
		int firstdmg = damage;
		if (flags & DMG_FIXEDDMG) firstdmg = origdmg;
		let globalvars = DDGlobalVariables.Get();
		
		Actor AttackingActor;
		Actor UniqueProjectile;
		FastProjectile UniqueProjectileFast;
		Actor ailmentproj;
		FastProjectile ailmentprojfast;
		Actor singleripproj;
		FastProjectile singlefastripproj;
		
		if (dydudebug_playerdamagemobj)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
			if (flags & DMG_NO_PAIN) Console.Printf("    (\cyPainless?: yes)");
			if (flags & DMG_NO_DODGE) Console.Printf("    (\cyCannotDodge?: yes)");
			if (flags & DMG_CANTKILL) Console.Printf("    (\cyCannotKill?: yes)");
			if (flags & DMG_NODASHAVOID) Console.Printf("    (\cyDashDoesntAvoid?: yes)");
			if (flags & DMG_IGNOREDEF) Console.Printf("    (\cyIgnoresDefense?: yes)");
			if (flags & DMG_NO_SARMOR) Console.Printf("    (\cyIgnoresPermArmor?: yes)");
			if (flags & DMG_FIXEDDMG) Console.Printf("    (\cyDealsFixedDmg?: yes)");
		}
		if (dydudebug_playerdamagemobj) Console.Printf("DamageType: %s", mod);
		
		if (source) AttackingActor = Actor(source);
		if (inflictor) 
		{
			UniqueProjectile = Actor(inflictor);
			UniqueProjectileFast = FastProjectile(inflictor);
			ailmentproj = Actor(inflictor);
			ailmentprojfast = FastProjectile(inflictor);
			singleripproj = Actor(inflictor);
			singlefastripproj = FastProjectile(inflictor);
		}
		
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		A_CheckNeverBleed(0, damage, flags);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		if (sour == "BlackBearNew" || infl == "BlackBearNew")
		{
			mod = 'Melee';
			flags |= DMG_THRUSTLESS;
			flags &= ~DMG_EXPLOSION;
			if (dydudebug_playerdamagemobj) Console.Printf("BlackBear 'Explosion'");
		}
		
		if (sour == "JSkull_Image1" || sour == "JSkull_Image2" || sour == "JSkull_Image3" ||
				infl == "JSkull_Image1" || infl == "JSkull_Image2" || infl == "JSkull_Image3")
		{
			flags &= ~DMG_NO_ARMOR;
			flags &= ~DMG_NO_PROTECT;
			if (dydudebug_playerdamagemobj) Console.Printf("Jumping Skull Afterimage");
		}
		
		if (mod == 'PSI') 
		{
			bool weapcheck = false;
			flags |= DMG_NO_ARMOR;
			if (weapon is "HandToHand" && CountInv("FistPlayerBlockItem")) 
			{
				damage *= frandompick(0.001,0.001,0.01,0.01,0.01,0.01,0.1,0.1);
				weapcheck = true;
			}
			if (weapon is "CricketBat") 
			{
				if (CountInv("CricketBatGuard")) damage *= 0.98;
				else if (CountInv("CricketBatGuard2")) damage *= 0.95;
				else if (CountInv("CricketBatGuard3")) damage *= 0.91;
			}
			if (weapon is "AppleJack") 
			{
				if (CountInv("AppleJackGuard")) damage *= 0.99;
				else if (CountInv("AppleJackGuard2")) damage *= 0.975;
				else if (CountInv("AppleJackGuard3")) damage *= 0.955;
			}
			if (weapon is "Scrambler") 
			{
				if (CountInv("ScramblerGuard")) damage *= 0.96;
				else if (CountInv("ScramblerGuard2")) damage *= 0.90;
				else if (CountInv("ScramblerGuard3")) damage *= 0.82;
			}
			if (weapon is "SigilDD") 
			{
				damage *= frandompick(0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.1667);
				weapcheck = true;
			}
			if (weapon is "WizardPike") 
			{
				damage *= frandompick(0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.25);
				weapcheck = true;
			}
			if (weapon is "Grimophone") 
			{
				damage *= frandompick(0.667,0.667,0.667,0.667,0.667,0.667,0.667,0.667,0.667,0.334);
				weapcheck = true;
			}
			if (weapon is "SuperVac") 
			{
				damage *= frandompick(0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.0625);
				weapcheck = true;
			}
			if (weapcheck && damage >= health)
			{
				if (player.cheats & CF_BUDDHA) { } else player.cheats |= CF_BUDDHA;
			}
		}
		bool bellefishzap;
		nm = 'HellFish';
		if ((mod == 'Melee' && flags & DMG_EXPLOSION && 
				(BelleFish(Source) || BelleFish(Inflictor))) ||
				(mod == 'HeFiShock' && (sour == nm || infl == nm)))
		{
			int prevdmg = damage;
			if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
			if (flags & DMG_EXPLOSION) flags &= ~DMG_EXPLOSION;
			bellefishzap = true;
			if (CountInv("PowerNoDrown")) 
			{
				if (waterlevel >= 2) damage *= 0.4;
												else damage *= 0.94;
			}
			if (waterlevel >= 1) damage *= frandom(1.5,2.5);
			if (dydudebug_playerdamagemobj) Console.Printf("Bellefish Zap Melee: damage: %d [%d]", damage, prevdmg);
		}
		if (mod == 'Beats' && flags & DMG_EXPLOSION) flags &= ~DMG_EXPLOSION;
		
		if (isbarrierbeam)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
		}

		int olddmg;
		armortier = 0;
		double SavePercent = 0.000000;
		int MaxAbsorb = 0;
		int MaxFullAbsorb = 0;
		
		int flatdefense;
		int baseflatdefense;
		bool useflatdefense;
		name armorclasstype = "KGArmor";
		let armor = KGArmor(FindInventory(armorclasstype));
		int armoramt;
		
		if (armor != null && CountInv(armorclasstype) > 0)
		{
			armoramt = armor.Amount;
			SavePercent = armor.SavePercent;
			MaxAbsorb = armor.MaxAbsorb;
			MaxFullAbsorb = armor.MaxFullAbsorb;
			if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
			if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
			if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
			if (savepercent >= 0.87500 && savepercent <= 0.93749) armortier = 3;
			if (savepercent >= 0.93750 && savepercent <= 0.99999) armortier = 4;
			if (savepercent >= 1.00000) armortier = 5;
			
			if (dydudebug_playerdamagemobj) Console.Printf("Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
		}
		
		bool SigilDrain;
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1] - Base: %d", damage);
		if (mod == 'Drowning' && source == null && inflictor == null)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_NO_ARMOR;
			if (dydudebug_playerdamagemobj) Console.Printf("Drowning", damage);
		}
		if (mod == 'SigilDrain' && source == null && inflictor == self && flags & DMG_NO_ARMOR)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
			flags |= DMG_NO_PAIN;
			SigilDrain = true;
			if (dydudebug_playerdamagemobj) Console.Printf("SigilDrain"); 
		}
		if (mod == 'Crush' && source == null && inflictor == null)
		{
			if (random(1,8) <= 7) flags |= DMG_NO_ARMOR;
			if (random(1,8) <= 1) flags |= DMG_NO_FACTOR;
			if (random(1,32) <= 1) flags |= DMG_NO_PROTECT;
			if (dydudebug_playerdamagemobj) Console.Printf("Crush"); 
		}
		
		if (mod != 'Slime' || 
				mod != 'Magma' || 
				mod != 'Crush' || 
				mod != 'Falling' || 
				mod != 'Poison' || 
				mod != 'CardPoison' || 
				mod != 'CCardsPoison' || 
				mod != 'PoisonCloud' || 
				mod != 'Magic' || 
				mod != 'Eldritch' || 
				mod != 'Sigil' || 
				mod != 'SigilDrain' || 
				mod != 'SpectralLow')
		{
			if (mod == 'Beats' && AttackingActor == self)
			{
				flags |= DMG_NO_ARMOR;
				flags |= DMG_THRUSTLESS;
				damage = ceil(damage * frandompick(1.0,1.0,1.0,1.125,1.125));
				if (dydudebug_playerdamagemobj) Console.Printf("Grimophone Alt-Fire (%d)", damage);
				if (damage >= health) return 0;
			}
			else
			{
				if (SigilDrain || flags & DMG_FIXEDDMG) { } 
				else damage = ceil(damage * 1.125);
			}
			if (SigilDrain) { } else if (CountInv("DoingSpinAttack")) damage *= 0.1667;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1ba]: %d", damage);
		}
		else
		if (mod == 'Magic' || 
				mod == 'Poison' || 
				mod == 'CardPoison' || 
				mod == 'CCardsPoison' || 
				mod == 'PoisonCloud' || 
				mod == 'Eldritch' || 
				mod == 'Sigil' ||
				mod == 'SigilDrain' ||
				mod == 'SpectralLow')
		{
			if (SigilDrain) { } else damage = ceil(damage * 0.875);
			if (SigilDrain) { } else if (CountInv("DoingSpinAttack")) damage *= 0.1667;
			if (Wads.CheckNumForName("EE-STAEONS", Wads.ns_global, -1, true) != -1)
			{
				if (mod == 'Eldritch') 
				{
					damage *= 0.25;
					if (CountInv("DoingSpinAttack")) damage *= 0.25;
				}
			}
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (non-normal base) [Step 1bb]: %d", damage);
		}
		else
		if (mod == 'Slime' || 
				mod == 'Lava' || 
				mod == 'Magma' || 
				mod == 'IceWater' || 
				mod == 'ShockFloor' || 
				mod == 'Crush' || 
				mod == 'Falling')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.125,1.125,1.25));
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (misc base) [Step 1bc]: %d", damage);
		}
		
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)  
		{
			if (dydudebug_playerdamagemobj) Console.Printf("\cyIS A VOODOO DOLL\c-)", damage);
			//*********************************************************************
			return super.DamageMobj(inflictor, source, damage, mod, flags, angle); 
			//*********************************************************************
		}
		
		// (Partial) Defense Ignoring Attacks
		PlayerDefenseIgnoreFactor = A_DefenseIgnoreFactor(inflictor, source, damage, mod, flags, angle, bellefishzap, isbarrierbeam);

		// (Partial) Armor Ignoring Attacks
		PlayerArmorIgnoreFactor = A_ArmorIgnoreFactor(inflictor, source, damage, mod, flags, angle, bellefishzap, isbarrierbeam);

		// Direct Damage Changes
		if (flags & DMG_INFLICTOR_IS_PUFF)
		{
			if (AttackingActor != self)
			{
				if (BulletPuff(self))
				{
					olddmg = damage;
					if (dydudebug_playerdamagemobj) Console.Printf("Hit by Doom Bullet");
					if (armortier == 0) damage = ceil(damage * 0.9375);
					if (armortier == 1) damage = ceil(damage * 0.875);
					if (armortier == 2) damage = ceil(damage * 0.75);
					if (armortier == 3) damage = ceil(damage * 0.625);
					if (armortier == 4) damage = ceil(damage * 0.5);
					if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334));
					if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334) * 0.25));
					if (CountInv("CricketBatGuard3")) damage = ceil(damage * (frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334) * 0.0625));
					if (CountInv("AppleJackGuard")) damage = ceil(damage * frandompick(0.8334,0.875,0.875,0.875,0.875,0.875,0.9167));
					if (CountInv("AppleJackGuard2")) damage = ceil(damage * (frandompick(0.8334,0.875,0.875,0.875,0.875,0.875,0.9167) * 0.25));
					if (CountInv("AppleJackGuard3")) damage = ceil(damage * (frandompick(0.8334,0.875,0.875,0.875,0.875,0.875,0.9167) * 0.0625));
					if (CountInv("ScramblerGuard")) damage = ceil(damage * frandompick(0.3334,0.375,0.375,0.375,0.375,0.375,0.4167));
					if (CountInv("ScramblerGuard2")) damage = ceil(damage * (frandompick(0.3334,0.375,0.375,0.375,0.375,0.375,0.4167) * 0.25));
					if (CountInv("ScramblerGuard3")) damage = ceil(damage * (frandompick(0.3334,0.375,0.375,0.375,0.375,0.375,0.4167) * 0.0625));
					if (CountInv("DoingSpinAttack")) damage *= 0.1667; // Cricket Bat Spin Attack almost entirely negates bullet damage

					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Bullet Buff]: %d (%d)", damage, olddmg);
				}
				useflatdefense = true;
			}
		}
		
		olddmg = damage;
		if (flags & DMG_EXPLOSION || 
				mod == 'Explosive' || 
				mod == 'ExplosiveImpact' || 
				mod == 'CC_Firecracker')
		{
			if (AttackingActor == self)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Own AOE");
				
				if (mod == 'Beats')
				{
					damage = ceil(damage * (0.10 - (ActualLevel * 0.002)));
					if (ActualLevel <= 250 && damage < 1) damage = 1;
					if (armortier == 1) damage = ceil(damage * 0.9875);
					if (armortier == 2) damage = ceil(damage * 0.98125);
					if (armortier == 3) damage = ceil(damage * 0.975);
					if (armortier == 4) damage = ceil(damage * 0.9625);
				}
				else
				{
					damage = ceil(damage * (0.25 - (ActualLevel * 0.005)));
					if (ActualLevel <= 100 && damage < 1) damage = 1;
					if (armortier == 1) damage = ceil(damage * 0.975);
					if (armortier == 2) damage = ceil(damage * 0.9625);
					if (armortier == 3) damage = ceil(damage * 0.95);
					if (armortier == 4) damage = ceil(damage * 0.925);
				}
				useflatdefense = false;
			}
			else
			{
				double set1, set2, set3;
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Not Own AOE");
				set1 = (0.750 - (ActualLevel * 0.0150));
				set2 = (0.875 - (ActualLevel * 0.0175));
				set3 = (1.000 - (ActualLevel * 0.0200));
				if (set1 <= 0.175) set1 = 0.175;
				if (set2 <= 0.21875) set2 = 0.21875;
				if (set3 <= 0.25) set3 = 0.25;
				if (AttackingActor != null)
				{
					if (Cyberdemon(source) || CyberdemonNew(source) || Annihilator(source)) 
					{
						if (RocketMonster(inflictor) || Rocket2(inflictor) || HomRocket1(inflictor))
						{
							set1 = (0.875 - (ActualLevel * 0.0175));
							set2 = (0.9375 - (ActualLevel * 0.01875));
							set3 = (1.0 - (ActualLevel * 0.02));
							if (set1 <= 0.21875) set1 = 0.21875;
							if (set2 <= 0.234375) set2 = 0.234375;
							if (set3 <= 0.25) set3 = 0.25;
						}
						else
						{
							set1 = (0.750 - (ActualLevel * 0.0150));
							set2 = (0.875 - (ActualLevel * 0.0175));
							set3 = (1.000 - (ActualLevel * 0.0200));
							if (set1 <= 0.175) set1 = 0.175;
							if (set2 <= 0.21875) set2 = 0.21875;
							if (set3 <= 0.25) set3 = 0.25;
						}
					}
					else 
					if (Archvile(source) || ArchvileNew(source) || Diabloist(source)) 
					{
						set1 = (0.50 - (ActualLevel * 0.01));
						set2 = (0.625 - (ActualLevel * 0.0125));
						set3 = (0.75 - (ActualLevel * 0.015));
						if (set1 <= 0.125) set1 = 0.125;
						if (set2 <= 0.15625) set2 = 0.15625;
						if (set3 <= 0.1875) set3 = 0.1875;
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("set1: %.8f, set2: %.8f, set3: %.8f", set1, set2, set3);
				damage = ceil(damage * frandompick(set1,set1,set2,set2,set2,set2,set2,set2,set3,set3));
				if (ActualLevel <= 100 && damage < 1) damage = 1;
				if (armortier == 1) damage = ceil(damage * 0.9875);
				if (armortier == 2) damage = ceil(damage * 0.975);
				if (armortier == 3) damage = ceil(damage * 0.9625);
				if (armortier == 4) damage = ceil(damage * 0.95);
				useflatdefense = true;
			}

			// Prevents AOE from IP Attacks that somehow still manage to deal you damage from being able to kill you
			EEProjectile IPAtkSource;
			if (inflictor)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire](IP ATTACK W/ AOE [INFLICTOR] ATTEMPT)");
				IPAtkSource = EEProjectile(inflictor);
				if (dydudebug_playerdamagemobj && IPAtkSource) Console.Printf("\c[fire](IP ATTACK W/ AOE [INFLICTOR] ATTEMPT [2])");
				if (IPAtkSource && IPAtkSource.IPattack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK W/ AOE [INFLICTOR])");
					return 0;
				}
			}
			if (!IPAtkSource && source)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire](IP ATTACK W/ AOE [SOURCE] ATTEMPT)");
				IPAtkSource = EEProjectile(source);
				if (dydudebug_playerdamagemobj && IPAtkSource) Console.Printf("\c[fire](IP ATTACK W/ AOE [SOURCE] ATTEMPT [2])");
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK W/ AOE [SOURCE])");
					return 0;
				}
			}
			
			if (EggShot(inflictor) ||
			    EggGrenade(inflictor) ||
			    EggMini(inflictor))
			{
				flags |= DMG_THRUSTLESS;
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG [AOE])");
				return 0;
			}
			if (EggShot(source) ||
			    EggGrenade(source) ||
			    EggMini(source))
			{
				flags |= DMG_THRUSTLESS;
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG [AOE])");
				return 0;
			}

			if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.3334,0.5,0.5,0.5,0.5,0.5,0.6667));
			if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.3334,0.5,0.5,0.5,0.5,0.5,0.6667) * 0.25));
			if (CountInv("CricketBatGuard3")) damage = ceil(damage * (frandompick(0.3334,0.5,0.5,0.5,0.5,0.5,0.6667) * 0.0625));
			if (CountInv("AppleJackGuard")) damage = ceil(damage * frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334));
			if (CountInv("AppleJackGuard2")) damage = ceil(damage * (frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334) * 0.25));
			if (CountInv("AppleJackGuard3")) damage = ceil(damage * (frandompick(0.6667,0.75,0.75,0.75,0.75,0.75,0.8334) * 0.0625));
			if (CountInv("ScramblerGuard")) damage = ceil(damage * frandompick(0.1667,0.25,0.25,0.25,0.25,0.25,0.3334));
			if (CountInv("ScramblerGuard2")) damage = ceil(damage * (frandompick(0.1667,0.25,0.25,0.25,0.25,0.25,0.3334) * 0.25));
			if (CountInv("ScramblerGuard3")) damage = ceil(damage * (frandompick(0.1667,0.25,0.25,0.25,0.25,0.25,0.3334) * 0.0625));
			if (CountInv("DoingSpinAttack")) damage *= 0.0334; // Cricket Bat Spin Attack almost entirely negates AOE damage
			
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [AOE]: %d (%d)", damage, olddmg);
		}
		else
		{
			// Prevents IP Attacks that somehow still manage to deal you damage from being able to kill you
			EEProjectile IPAtkSource;
			if (inflictor)
			{
				IPAtkSource = EEProjectile(inflictor);
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK [INFLICTOR])");
					return 0;
				}
			}
			if (!IPAtkSource && source)
			{
				IPAtkSource = EEProjectile(source);
				if (IPAtkSource && IPAtkSource.IPAttack)
				{
					damage = 0;
					if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (IP ATTACK [SOURCE])");
					return 0;
				}
			}
			
			if (EggShot(inflictor) ||
			    EggGrenade(inflictor) ||
			    EggMini(inflictor))
			{
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG)");
				return 0;
			}
			if (EggShot(source) ||
			    EggGrenade(source) ||
			    EggMini(source))
			{
				damage = 0;
				if (dydudebug_playerdamagemobj) Console.Printf("\c[fire]END DAMAGE ATTEMPT (FRACTAL EGG)");
				return 0;
			}
			if (AttackingActor != self) useflatdefense = true;
		}
		
		olddmg = damage;
		if (source != null)
		{
			if (Crusader(source))
			{
				if (flags & DMG_EXPLOSION || 
						mod == 'Explosive' ||
						mod == 'ExplosiveImpact' || 
						mod == 'CC_Firecracker') // The Crusader's death AOE does very little damage to Dinah (37.5% and dropping)
				{
					damage = ceil(damage * frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
					if (armortier == 1) damage *= 0.90;
					if (armortier == 2) damage *= 0.80;
					if (armortier == 3) damage *= 0.60;
					if (armortier == 4) damage *= 0.20;
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderAOE]: %d (%d)", damage, olddmg);
				}
				if (inflictor != null)
				{
					if (CrusaderMissile(inflictor) || FastFlameMissile(inflictor)) // The Crusader's attacks are very wanting against Dinah overall (37.5% and dropping)
					{
						damage = ceil(damage * frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
						if (armortier == 1) damage *= 0.90;
						if (armortier == 2) damage *= 0.80;
						if (armortier == 3) damage *= 0.60;
						if (armortier == 4) damage *= 0.20;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderProj]: %d (%d)", damage, olddmg);
					}
				}
			}
			
			if (Revenant(source) || RevenantNew(source))
			{
				if (inflictor != null)
				{
					if (RevenantTracer(inflictor) || RevenantTracerNew(inflictor))
					{
						damage = ceil(damage * frandompick(0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.875,0.875,1.0) - 0.25);
						if (armortier == 1) damage *= 0.95;
						if (armortier == 2) damage *= 0.90;
						if (armortier == 3) damage *= 0.80;
						if (armortier == 4) damage *= 0.60;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [RevMissile]: %d (%d)", damage, olddmg);
					}
				}
			}
		}
		
		olddmg = damage;
		if (mod == 'Zap' && weapon is "WizardPike")
		{
			if (!(ddafd_disablepikegiveszapres && 
					(CountInv("IsDynDuchess") || 
					 CountInv("IsAppetite") || 
					 CountInv("IsCarnOfSouls") || 
					 CountInv("IsWeddingCake"))))
			{
				if (!(DDPlayerPawn(source) || EvilDinah(source))) damage *= frandompick(0.1667,0.20,0.20,0.20,0.25,0.25,0.25,0.25,0.25,0.25,0.334,0.334,0.334,0.40);
																										 else damage *= frandompick(0.3334,0.40,0.40,0.40,0.5,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.667,0.80);
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [ZapShot w/ Pike Equipped]: %d (%d)", damage, olddmg);
			}
		}

		// Check FRIGHTENED/FRIENDLY flags
		if (damage > 0)
		{
			if (AttackingActor)
			{
				if (AttackingActor != self)
				{
					if (AttackingActor.bFRIENDLY)
					{
						damage = 0;
						if (dydudebug_playerdamagemobj) Console.Printf("END DAMAGE ATTEMPT (FRIENDLY)");
						return 0;
					}
					else
					{
						if (AttackingActor.CountInv("ScramblerConfusion")) // If the attacker is under the effect of the Confusion debuff from the Scrambler
						{
							damage = ceil(damage * frandompick(0,0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1.0));
							if (damage == 0) return 0;
						}
						else
						{
							if (AttackingActor.bFRIGHTENED) // Attacker is frightened, AND the Player is the one that is doing the frightening
							{
								if (player.cheats & CF_FRIGHTENING || bFRIGHTENING) damage = ceil(damage * frandompick(0.625,0.6875,0.75)); else damage = ceil(damage * frandompick(0.9375,0.95,0.9625));
							}
						}
					}
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Friendly/Frighten Check]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		// Armor/Defense Checks
		int basearmorflat;
		int basearmormax = 1;
		if (flags & DMG_IGNOREDEF)
		{
			if (dydudebug_playerdamagemobj) Console.Printf("useflatdefense: DMG_IGNOREDEF");
		}
		else
		{
			if (MiscItem)
			{
				if (armortier == 1) basearmormax = MiscItem.ArmorItemMax1;
				if (armortier == 2) basearmormax = MiscItem.ArmorItemMax2;
				if (armortier == 3) basearmormax = MiscItem.ArmorItemMax3;
				if (armortier == 4) basearmormax = MiscItem.ArmorItemMax4;
			}
			if (dydudebug_playerdamagemobj) Console.Printf("useflatdefense: %d", useflatdefense);
			if (!(mod == 'Slime' || 
						mod == 'Lava' || 
						mod == 'Magma' || 
						mod == 'IceWater' ||
						mod == 'ShockFloor' || 
						mod == 'Drowning' || 
						mod == 'Falling'))
			{
				olddmg = damage;
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (mod == 'Crush')
				{
					double basecrushdmgfact;
					if (PowerStrength(FindInventory("PowerStrength")) || PowerStrengthDD(FindInventory("PowerStrengthDD")))
					{
						basecrushdmgfact = frandompick(25,33.4,33.4,50,50,50,50,50,50,66.7,66.7,75);
					}
					else
					{
						basecrushdmgfact = frandompick(75,87.5,87.5,100,100,100,100,100,100,112.5,112.5,125);
					}
					damage *= double(basecrushdmgfact / (mass * frandompick(0.25,0.334,0.334,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.75)));
					damage *= (basecrushdmgfact * 0.01);
					if (damage <= (olddmg * 0.334)) damage = (olddmg * 0.334);
					if (damage >= (olddmg * 3)) damage = (olddmg * 3);

					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueCrush;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValueCrush;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (dydudebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (dydudebug_playerdamagemobj) Console.Printf("Flat Defense Calc [Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,32) > 1) damage = 1;
						if (armortier == 3 && random(1,32) > 2) damage = 1;
						if (armortier >= 4 && random(1,32) > 4) damage = 1;
					}
				}
				else
				{
					if (mod == 'Drowning') useflatdefense = false;
					if (mod == 'SigilDrain') useflatdefense = false;
					if (useflatdefense)
					{
						if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValue;
						flatdefense = random((baseflatdefense*0.5),baseflatdefense);
						if (flags & !DMG_NO_ARMOR)
						{
							basearmorflat = 0;
							if (MiscItem) basearmorflat = MiscItem.ArmorDefValue;
							
							if (basearmormax > 0) 
							{
								basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
								double armfactor = double(armoramt * 1.0 / basearmormax);

								flatdefense += (basearmorflat * armfactor);
								if (dydudebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
							}
						}
						flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
						damage -= flatdefense;
						if (dydudebug_playerdamagemobj) Console.Printf("Flat Defense Calc [Non-Crush Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,8) > 1) damage = 1;
						if (armortier == 3 && random(1,8) > 2) damage = 1;
						if (armortier >= 4 && random(1,8) > 4) damage = 1;
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Raw Armor Def]: %d", damage, olddmg);
			}
			else // Slime Damage
			{
				if (mod == 'Drowning') useflatdefense = false;
				if (mod == 'SigilDrain') useflatdefense = false;
				if (useflatdefense)
				{
					if (MiscItem) baseflatdefense += MiscItem.BaseFlatDefValueDmgFlr;
					flatdefense = random((baseflatdefense*0.5),baseflatdefense);
					if (flags & !DMG_NO_ARMOR)
					{
						basearmorflat = 0;
						if (MiscItem) basearmorflat = MiscItem.ArmorDefValueDmgFlr;
						
						if (basearmormax > 0) 
						{
							basearmorflat *= (1.0 - PlayerArmorIgnoreFactor);
							double armfactor = double(armoramt * 1.0 / basearmormax);

							flatdefense += (basearmorflat * armfactor);
							if (dydudebug_playerdamagemobj) Console.Printf("BaseArmorFlat: %d, Amt: %d / %d, armfactor: %.8f", basearmorflat, armoramt, basearmormax, armfactor);
						}
					}
					flatdefense *= (1.00 - PlayerDefenseIgnoreFactor);
					damage -= flatdefense;
					if (dydudebug_playerdamagemobj) Console.Printf("Flat Defense Calc [DmgFloor Damage]: %d (damage: %d vs %d)", flatdefense, damage, olddmg);
				}
			}
		}
		
		if (CountInv("PowerRatMorph") && mod == 'Falling') damage = floor(damage * frandom(0.15625,0.1875));
		
		// Berserk Effects
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD") && !SigilDrain)
		{
			olddmg = damage;
			if (mod == 'Falling') damage = ceil(damage * frandom(0.625,0.75));
			if (mod == 'Crush') 
			{
				damage = ceil(damage * frandom(0.75,0.875));
				if (damage < 1) damage = 1;
			}
			if (mod == 'Drowning') 
			{
				damage = ceil(damage * frandom(0.625,1.000));
				if (damage < 1) damage = 1;
			}
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Berserk Effects]: %d", damage, olddmg);
		}
		else
		{
			if (mod == 'Drowning' && damage < 1) damage = 1;
		}
		

		if (CountInv("PlayerDashing") && !SigilDrain)
		{
			if (BarrierBeam(inflictor) || 
					BarrierBeam(source) || 
					flags & DMG_NODASHAVOID)
			{
			}
			else
			{
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Dashing Avoids Damage]");
				return 0;
			}
		}
		
		if (CountInv("PowerTimeFreezer") || 
				CountInv("DDMiscTimeFreezer") || 
				(CountInv("DebugTimeFreezer") && dydudebug_timeslowinterval > 1) || 
				CountInv("TimePotionTimeFreezer") || 
				CountInv("DashTimeFreezer"))
		{
			if (mod == 'Slime' || 
					mod == 'Lava' || 
					mod == 'Magma' || 
					mod == 'IceWater' || 
					mod == 'ShockFloor')
			{
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [TimeFreeze on Slime abort]");
				return 0;
			}
		}
		
		olddmg = damage;
		if (mod == "CardPoison" ||
				mod == "CCardsPoison")
		{
			double dmg1base = 0.00;
			if (armortier == 1) 
			{
				damage *= frandom(0.875,1.000);
				dmg1base = 6.25;
			}
			if (armortier == 2) 
			{
				damage *= frandom(0.625,0.875);
				dmg1base = 12.5;
			}
			if (armortier == 3) 
			{
				damage *= frandom(0.25,0.625);
				dmg1base = 43.75;
			}
			if (armortier == 4) 
			{
				damage *= frandom(0.0,0.25);
				dmg1base = 87.5;
			}
			if (frandom(0.1,100.0) > dmg1base && damage < 1) damage = 1;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CCards Acid w/ Armor]: %d (%d)", damage, olddmg);
		}
		
		bool isinvuln = false;
		// If Invulnerable
		{
			if (bINVULNERABLE || player.cheats & CF_GODMODE2 || player.cheats & CF_GODMODE || CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
			{ 
				if (SigilDrain) damage = 0;
				A_StartSound("Player/TookNoDamageInvuln",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				isinvuln = true;
			}
		}
		
		if (dydudebug_playerdamagemobj)
		{
			olddmg = damage;
			int projdam;
			double endmgmultS = 1.0;
			double endmgmultI = 1.0;
			if (source) endmgmultS = source.DamageMultiply;
			if (!source && inflictor) endmgmultI = inflictor.DamageMultiply;
			projdam = damage * endmgmultS * endmgmultI;
			Console.Printf("Projected Dmg: %d vs (%d), Source's DamageMultiply: %.8f, Inflictor's DamageMultiply: %.8f", projdam, olddmg, endmgmultS, endmgmultI);
		}
		
		olddmg = damage;
		damage *= exex_pdmgtakenfactor;
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Damage Cheat]: %d [%d]", damage, olddmg);
		
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Final] - Final Damage: %d", damage);
		
		if (dydudebug_playerdamagemobj && armoramt) Console.Printf("Armor Amount: %d", armoramt);
		DmgSource = source;
		DmgInflictor = inflictor;
		DmgFlags = flags;
		mobjdmg = damage;
		if (dydudebug_playerdamagemobj) Console.Printf("damage [pre-ssa]: %d", damage);
		if (mod != 'SigilDrain') 
		{
			if (flags & DMG_NO_SARMOR)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("damage [post-ssa]: DMG_NO_SARMOR");
			}
			else
			{
				double ssa = 1.00;
				if (mod == 'Slime' || 
						mod == 'Lava' || 
						mod == 'Magma' || 
						mod == 'IceWater' || 
						mod == 'ShockFloor')
				{
					if (CountInv("ExpeditionHat")) ssa -= frandompick(0.03,0.04,0.05);
					if (CountInv("ClassyRibbon")) ssa -= frandompick(0.015,0.02,0.025);
				}
				else
				{
					if (CountInv("ExpeditionHat")) ssa -= frandompick(0.15,0.20,0.25);
					if (CountInv("ClassyRibbon")) ssa -= frandompick(0.075,0.100,0.125);
				}
				damage = int(damage * ssa);
				if (dydudebug_playerdamagemobj) Console.Printf("damage [post-ssa]: %d, ssa: %.8f", damage, ssa);
			}
		}
		
		if (A_CheckUOHYM())
		{
			nm = "SkinStealer";
			nn = "IllusGhost";
			if ((inflictor && 
					 (inflictor.GetClassName() == nm || 
					  inflictor.GetClassName() == nn)) ||
					(source && 
					 (source.GetClassName() == nm || 
					  source.GetClassName() == nn)))
			{
				if (CountInv("MysteryItem2"))
				{
					damage = 1;
					flags |= DMG_NO_FACTOR;
					flags |= DMG_NO_PROTECT;
					flags |= DMG_NO_ENHANCE;
					flags |= DMG_THRUSTLESS;
					flags |= DMG_IGNOREDEF;
				}
				else
				{
					damage *= frandompick(1.0,1.375,1.375,1.75,1.75,1.75,1.75,1.75,1.75,2.125,2.125,2.5);
					flags |= DMG_NO_PROTECT;
					flags |= DMG_NO_FACTOR;
				}
			}
		}
		if (mod == 'Slime' || 
				mod == 'Lava' || 
				mod == 'Magma' || 
				mod == 'IceWater' || 
				mod == 'ShockFloor') tookflrdmg = true;
		if (mod == 'IceWater') mod = 'Ice';
		if (mod == 'ShockFloor') mod = 'Shock';
		if (flags & DMG_FIXEDDMG) damage = origdmg;
		//******************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//******************************
		if (flags & DMG_FIXEDDMG) ret = origdmg;
		if (Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1)
		{
			if (mod == 'StunningHead')
			{
				if (source) { }
				else
				{
					if (ret >= health) ret = (health - 1);
				}
			}
		}
		if (flags & DMG_CANTKILL)
		{
			if (ret >= health) ret = (health - 1);
			if (dydudebug_playerdamagemobj) Console.Printf("Attack has CANTKILL flag");
			if (health < (ret + 1)) 
			{
				health = (ret + 1);
				return ret;
			}
		}
		if (dydudebug_playerdamagemobj) Console.Printf("ret [PDM]: %d", ret);
		ret = PostDamageMobj(inflictor, source, damage, mod, flags, angle, 
												 ret, armoramt, firstdmg, isinvuln, oldhealth, oldhealthratio, SigilDrain,
												 infl, sour, vict);
		if (dydudebug_playerdamagemobj) Console.Printf("ret [final]: %d", ret);
		
		tookflrdmg = false;
		return ret;
	}
	
	int PostDamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, int ret, int armoramt, int firstdmg, bool isinvuln, int oldhealth, int oldhealthratio, bool SigilDrain, string infl, string sour, string vict)
	{
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		bool isCCardsIllusion = false;

		if (source)
		{
			if (source.bNOBLOOD == true && 
					source.bNOPAIN == true &&
					source.bNOTARGETSWITCH == true &&
					source.bNOINFIGHTING == true &&
					source.bFULLVOLACTIVE == false && 
					source.bFULLVOLDEATH == false &&
					source.bBOSS == false) isCCardsIllusion = true;
			if (source.bISMONSTER &&
					!source.bFRIENDLY &&
					!isCCardsIllusion &&
					!(ExplosiveBarrel(source) ||
						ExplosiveBarrelNew(source) ||
						Pod(source))) A_DynamicMusic(forcedplay:true);
		}
		else
		if (inflictor)
		{
			if (inflictor.bNOBLOOD == true && 
					inflictor.bNOPAIN == true &&
					inflictor.bNOTARGETSWITCH == true &&
					inflictor.bNOINFIGHTING == true &&
					inflictor.bFULLVOLACTIVE == false && 
					inflictor.bFULLVOLDEATH == false &&
					inflictor.bBOSS == false) isCCardsIllusion = true;
			if (inflictor.bISMONSTER && 
					!inflictor.bFRIENDLY && 
					!isCCardsIllusion &&
					!(ExplosiveBarrel(inflictor) ||
						ExplosiveBarrelNew(inflictor) ||
						Pod(inflictor))) A_DynamicMusic(forcedplay:true);
		}
		
		string combatlogmsg = "\c[sapphire]*\c- ";
		name armorclasstype = "KGArmor";
		int armdmg = (armoramt - CountInv(armorclasstype));
		if (armdmg <= 0) armdmg = 0;
		if (dydudebug_playerdamagemobj && armdmg) Console.Printf("Armor Damage: %d", armdmg);
		if (armdmg && exex_armordmgsounds && !isCCardsIllusion)
		{
			A_StopSound(213);
			if (CountInv(armorclasstype)) A_StartSound("armordamaged",213,CHANF_DEFAULT,1.0,ATTN_NORM);
															 else A_StartSound("armorbroken",213,CHANF_DEFAULT,1.0,ATTN_NORM);
		}
		if (exex_playerdmglog)
		{
			if (!isCCardsIllusion)
			{
				if (ret || armdmg)
				{
					if (armdmg && !ret) combatlogmsg.AppendFormat("\c[darkgreen]%d AP\c- ", armdmg);
					else if (armdmg && ret) combatlogmsg.AppendFormat("\c[darkred]%d HP\c- & \c[darkgreen]%d AP\c- ", ret, armdmg);
					else combatlogmsg.AppendFormat("\c[darkred]%d HP\c- ", ret);
					if (dydudebug_dmgdiffdebug)
					{
						int dmgdiff = ((ret + armdmg) - firstdmg);
						if (dmgdiff)
						{
							//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
							if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2)
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
								if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
								if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
								if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
								if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
							}
							else
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
							}
							if (dydudebug_dmgdiffdebug >= 2 && dydudebug_dmgdiffdebug <= 3 && MiscItem)
							{
								double dmgdiffper;
								if (firstdmg) 
								{
									dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
									if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
									if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
									if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
									if (dydudebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																							else combatlogmsg.AppendFormat(")", dmgdiff);
								}
							}
							if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
						}
					}
					if (mod == 'SigilDrain') combatlogmsg.AppendFormat("of damage drained");
															else combatlogmsg.AppendFormat("of damage taken");
				}
				else
				{
					if (isinvuln) 
					{
						combatlogmsg.AppendFormat("\c[green]Invulnerable!\c- No Damage \c-");
					}
					else
					{
						A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
						combatlogmsg.AppendFormat("\c[white]No Damage \c-");
					}
					if (dydudebug_dmgdiffdebug)
					{
						int dmgdiff = ((ret + armdmg) - firstdmg);
						if (dmgdiff)
						{
							//Console.Printf("Dmgdiff: %d, FinalDmg: %d, OrigDmg: %d", dmgdiff, (ret + armdmg), firstdmg);
							if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2)
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
								if (dmgdiff < 0) combatlogmsg.AppendFormat("\c[lightblue]%d\c-", dmgdiff);
								if (dmgdiff == 0) combatlogmsg.AppendFormat("0", dmgdiff);
								if (dmgdiff > 0) combatlogmsg.AppendFormat("\c[brick]+%d\c-", dmgdiff);
								if (firstdmg) combatlogmsg.AppendFormat(" (", dmgdiff);
							}
							else
							{
								combatlogmsg.AppendFormat("[", dmgdiff);
							}
							if (dydudebug_dmgdiffdebug >= 2 && dydudebug_dmgdiffdebug <= 3 && MiscItem)
							{
								double dmgdiffper;
								if (firstdmg) 
								{
									dmgdiffper = ((((ret + armdmg) * 100.0 / firstdmg)) - 100.0);
									if (dmgdiffper < 0) combatlogmsg.AppendFormat("\c[lightblue]%.2f%%\c-", dmgdiffper);
									if (dmgdiffper == 0) combatlogmsg.AppendFormat("0%%", dmgdiffper);
									if (dmgdiffper > 0) combatlogmsg.AppendFormat("\c[brick]+%.2f%%\c-", dmgdiffper);
									if (dydudebug_dmgdiffdebug >= 3) combatlogmsg.AppendFormat("] ", dmgdiff);
																							else combatlogmsg.AppendFormat(")", dmgdiff);
								}
							}
							if (dydudebug_dmgdiffdebug >= 1 && dydudebug_dmgdiffdebug <= 2) combatlogmsg.AppendFormat("] ", dmgdiff);
						}
					}
					combatlogmsg.AppendFormat("\c[white]taken\c-");
				}
				if (source) // Has a source
				{
					combatlogmsg.AppendFormat(" from \c[purple]%s\c-", source.GetTag());
					if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
				}
				else
				if (inflictor) // No source, but has an inflictor
				{
					if (mod == 'SigilDrain') combatlogmsg.AppendFormat(" by the Sigil!");
															else combatlogmsg.AppendFormat(" from \c[brick]%s!", inflictor.GetTag());
				}
				else // If no source OR inflictor
				{
					if (mod == 'Slime') combatlogmsg.AppendFormat(" from a damaging surface");
					else if (mod == 'Lava' || mod == 'Magma' || mod == 'IceWater' || mod == 'ShockFloor' || tookflrdmg) combatlogmsg.AppendFormat(" from a damaging surface");
					else if (mod == 'Crush') combatlogmsg.AppendFormat(" from a crushing ceiling");
					else if (mod == 'Falling') combatlogmsg.AppendFormat(" from falling");
					else if (mod == 'Drowning') combatlogmsg.AppendFormat(" from drowning");
					combatlogmsg.AppendFormat("!");
				}
				combatlogmsg.AppendFormat(" [%s]", mod);
				//Console.Printf("armoramt: %d, PlayerArmorIgnoreFactor: %.8f", armoramt, PlayerArmorIgnoreFactor);
				if ((ret || armdmg) && armoramt && PlayerArmorIgnoreFactor)
				{
					double temp = (PlayerArmorIgnoreFactor * 100.0);
					combatlogmsg.AppendFormat(" \c[orange](");
					if (flags & DMG_NO_ARMOR)
					{
						combatlogmsg.AppendFormat("FULL", temp);
					}
					else
					{
						combatlogmsg.AppendFormat("%.2f%%", temp);
					}
					combatlogmsg.AppendFormat("  armor bypass)\c-");
				}
				if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-");
				if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
				Console.Printf(combatlogmsg);
			}
		}
		
		// Interrupt HP Regen For a Bit
		if (MiscItem && ret > 0)
		{
			double regenintfactor = 1.0;
			if (A_CheckDDGame())
			{
				if (TrueGameSkill <= SKILL_VERY_EASY)	regenintfactor = 2.0;
				if (TrueGameSkill == SKILL_EASY)			regenintfactor = 2.25;
				if (TrueGameSkill == SKILL_NORMAL)		regenintfactor = 2.5;
				if (TrueGameSkill == SKILL_HARD)			regenintfactor = 2.75;
				if (TrueGameSkill >= SKILL_VERY_HARD)	regenintfactor = 3.0;
			}
			else
			{
				if (TrueGameSkill <= SKILL_VERY_EASY)	regenintfactor = 1.0;
				if (TrueGameSkill == SKILL_EASY)			regenintfactor = 1.125;
				if (TrueGameSkill == SKILL_NORMAL)		regenintfactor = 1.25;
				if (TrueGameSkill == SKILL_HARD)			regenintfactor = 1.375;
				if (TrueGameSkill >= SKILL_VERY_HARD)	regenintfactor = 1.5;
			}
			if (mod == 'Ice' || 
					mod == 'IceWater' || 
					mod == 'Chill' || 
					mod == 'Frost') 
			{
				if (tookflrdmg) regenintfactor *= frandompick(1.375,1.5,1.5,1.5,1.5,1.5,1.625);
									 else regenintfactor *= frandompick(1.1875,1.25,1.25,1.25,1.25,1.25,1.3125);
			}
			if (mod == 'Fire' || 
					mod == 'CCFire' || 
					mod == 'Flames' || 
					mod == 'CCardsEyeFire' || 
					mod == 'Burn' || 
					mod == 'Inferno' || 
					mod == 'Flare' || 
					mod == 'Solar' || 
					mod == 'Boiling' || 
					mod == 'Lava' || 
					mod == 'Magma' ||
					mod == 'SpecialFire')
			{
				if (tookflrdmg) regenintfactor *= frandompick(0.6875,0.75,0.75,0.75,0.75,0.75,0.8125);
									 else regenintfactor *= frandompick(0.375,0.5,0.5,0.5,0.5,0.5,0.625);
			}
			int regendmg = (randompick(9,10,10,11,11,12,13) * ((ret * frandompick(0.875,1.0625)) * regenintfactor));
			MiscItem.HPRegenBoostTimer -= regendmg;
			if (MiscItem.HPRegenBoostTimer < (-350 * regenintfactor)) MiscItem.HPRegenBoostTimer = (-350 * regenintfactor);
			if (dydudebug_playerdamagemobj) Console.Printf("MiscItem.HPRegenBoostTimer: %d, regendmg: %d, regenintfactor: %.8f, dmgfactor: %s, tookflrdmg: %d", MiscItem.HPRegenBoostTimer, regendmg, regenintfactor, mod, tookflrdmg);
		}
		
		// Item/Ikari Point Gains
		if (CheckIPEnabled() && ret && MiscItem && globalvars && health > 0 && !isCCardsIllusion)
		{
			int gain = 0;
			double factor = 1.00;
			if ((source && source != self) && (inflictor && inflictor != self)) gain += 1;
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || tookflrdmg || mod == 'Drowning' || mod == 'Falling' || mod == 'Crush')) gain += 1;
			if ((mod == 'Slime' || mod == 'Lava' || mod == 'Magma' || tookflrdmg || mod == 'Drowning' || mod == 'Falling' || mod == 'Crush') && !inflictor && !source) 
			{
				if (MiscItem)
				{
					int armortype = 0;
					if (CountInv("ExpeditionHat")) armortype++;
					if (CountInv("ClassyRibbon")) armortype++;
					
					double basechance = 3.000;
					if (armortype >= 2) basechance = 1.500;
					if (armortype == 1) basechance = 2.250;
					if (armortype <= 0) basechance = 3.000;
					if (frandom(0.001,3.000) <= (1.0000 + (MiscItem.TruePlayerLevel * 0.025)))
					{
						gain += 2;
						int type = random(1,10);
						if (armortype >= 2) type = random(1,3);
						if (armortype == 1) type = random(1,6);
						if (armortype <= 0) type = random(1,10);
						if (type <= 1)
						{
							factor = (0.10 + (MiscItem.TruePlayerLevel * 0.04));
							if (armortype >= 2) { if (factor > 2.0) factor = 2.0; }
							else if (armortype == 1) { if (factor > 1.5) factor = 1.5; }
							else if (armortype <= 0) { if (factor >= 1.25) factor = 1.25; }
						}
						else
						if (type >= 2 && type <= 3)
						{
							factor = (0.05 + (MiscItem.TruePlayerLevel * 0.02));
							if (armortype >= 2) { if (factor > 1.5) factor = 1.5; }
							else if (armortype == 1) { if (factor > 1.25) factor = 1.25; }
							else if (armortype <= 0) { if (factor >= 1.00) factor = 1.00; }
							if (factor > 1.00) factor = 1.00;
						}
						else
						if (type >= 4 && type <= 6)
						{
							factor = (0.025 + (MiscItem.TruePlayerLevel * 0.01));
							if (armortype >= 2) { if (factor > 1.25) factor = 1.25; }
							else if (armortype == 1) { if (factor > 1.0) factor = 1.0; }
							else if (armortype <= 0) { if (factor >= 0.5) factor = 0.5; }
						}
						else
						{
							factor = (0.0125 + (MiscItem.TruePlayerLevel * 0.005));
							if (armortype >= 2) { if (factor > 1.0) factor = 1.0; }
							else if (armortype == 1) { if (factor > 0.5) factor = 0.5; }
							else if (armortype <= 0) { if (factor >= 0.25) factor = 0.25; }
						}
					}
					else
					{
						gain -= 1;
					}
				}
				else gain -= 1;
			}
			//Console.Printf("IP Gain: %d", gain);
			if (gain > 0 && MiscItem.IPNoGainTimer <= 0 && !MiscItem.HasHarmonicAnger)
			{
				double base;
				// The mod's first and original formula
				if (exex_ikaripointscalctype <= 0)
				{
					base = ret * 100.0 / MiscItem.MaxHealthTrue;
					if (oldhealthratio == 0) base *= 1.0;
					if (oldhealthratio == 1) base *= 1.125;
					if (oldhealthratio == 2) base *= 1.25;
					if (oldhealthratio == 3) base *= 1.5;
					if (oldhealthratio == 4) base *= 2.25;
					if (oldhealth > 1 && health == 1) base *= 3.25;
					if (MiscItem.PlayerLUCK) base *= (0.125 + (ActualLevel * 0.00125) + (random(1,MiscItem.PlayerLUCK) * frandompick(0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.001,0.001,0.001,0.001,0.001,0.001,0.002,0.002,0.002,0.002,0.003,0.003)));
															else base *= (0.125 + (ActualLevel * 0.00125));
					
				}
				// The more Lufia II equse formula
				if (exex_ikaripointscalctype >= 0)
				{
					base = ret * 100.0 / oldhealth; // % of remaining HP removed
					if (base >= 0.001)
					{
						if (base >= 0.001 && base <= 50.000) base *= 0.50; // <= 50% equals half of the percent in IP points given [up to 25%]
						if (base >= 50.001 && base <= 65.000) base *= 0.558077; 
						if (base >= 65.001 && base <= 75.000) base *= 0.646154;
						if (base >= 75.001 && base <= 85.000) base *= 0.76; 
						if (base >= 85.001 && base <= 90.000) base *= 0.90; 
						if (base >= 90.001 && base <= 100.000) base *= 1.00; 
						if (base >= 100.001) base *= 1.25;
						if (oldhealth > 1 && health == 1) base += MiscItem.MaxItemPoints;
					}
				}
				nm = "CCards_Actor_AcidBlood"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.375,1.5,1.5,1.5,1.5,1.5,1.625);
				nm = "CCards_Actor_HighVoltageZapp"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.5625,1.75,1.75,1.75,1.75,1.75,1.9375);
				nm = "CCards_Actor_ThrownCorpseHitbox"; extracheck = nm;
				if (infl == extracheck || sour == extracheck) base *= frandompick(1.1875,1.25,1.25,1.25,1.25,1.25,1.3125);
				if (mod == 'SigilDrain')
				{
					base *= frandompick(0.2,0.25,0.25,0.25,0.25,0.25,0.334);
				}
				if (DDOrigCreature(source) || DDOrigCreature(inflictor))
				{
					base *= frandompick(1.667,2.0,2.0,2.0,2.0,2.5,2.5,2.5,2.5,3);
				}
				if (DDOrigBoss(source) || DDOrigBoss(inflictor))
				{
					base *= (frandompick(1.667,2.0,2.0,2.0,2.0,2.5,2.5,2.5,2.5,3) * frandompick(1.5,2.0));
				}
				double basef = base;
				if (SigilDrain)
				{
					base *= (1.0 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
					basef *= (0.334 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
				}
				if (flags & DMG_CANTKILL) 
				{
					base *= 0.03125;
					basef *= 0;
				}
				if (gain >= 2) 
				{
					base *= factor;
					basef *= factor;
				}
				A_AddIP(base, basef, true, true, 0);
			}
		}
		
		if (ret)
		{
			int damagetakefactor = ret * 100 / MiscItem.MaxHealthTrue;
			if (damagetakefactor < 1) damagetakefactor = 1;
			if (MiscItem)
			{
				MiscItem.HPHUDShakeType = 1;
				if (damagetakefactor >= 10) MiscItem.HPHUDShakeType = 2;
				if (damagetakefactor >= 50) MiscItem.HPHUDShakeType = 3;
				if (damagetakefactor >= 100) MiscItem.HPHUDShakeType = 4;
			}
			player.damagecount -= ret;
			if (player.damagecount < 0) player.damagecount = 0;
			player.damagecount += damagetakefactor;
			if (player.damagecount > 100) player.damagecount = 100;
			if (dydudebug_countdisplays) Console.Printf("player.damagecount: %d, damagetakefactor: %d, dmg: %d / %d", player.damagecount, damagetakefactor, ret, MiscItem.MaxHealthTrue);
		}
		
		if (armdmg && armortier)
		{
			int armmax;
			if (MiscItem)
			{
				if (armortier == 1) armmax = MiscItem.ArmorItemMax1;
				if (armortier == 2) armmax = MiscItem.ArmorItemMax2;
				if (armortier == 3) armmax = MiscItem.ArmorItemMax3;
				if (armortier == 4) armmax = MiscItem.ArmorItemMax4;
			}
			if (armmax > 0)
			{
				int damagetakefactor = armdmg * 100 / armmax;
				if (MiscItem)
				{
					MiscItem.APHUDShakeType = 1;
					if (damagetakefactor >= 10) MiscItem.APHUDShakeType = 2;
					if (damagetakefactor >= 50) MiscItem.APHUDShakeType = 3;
					if (damagetakefactor >= 100) MiscItem.APHUDShakeType = 4;
				}
			}
		}
		
		A_LossHUD(ret, 0, true);
		A_LossHUD(armdmg, 1, true);
		
		PlayerArmorIgnoreFactor = 0.00;
		PlayerDefenseIgnoreFactor = 0.00;
		return ret;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (!player || !player.mo || player.mo != self)
		{
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PPawnVoodoo] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return true;
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PPawnVoodoo] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}
		else
		{
			// Non-passive means the one moving into the other is performing the checks.
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PlayerPawn] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [PlayerPawn] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
					return false;
				}
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PlayerPawn] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}

		// We don't really care about others making the check.
		return true;
	}
	
	void A_DDPain()
	{
		if (GetClassName() == "DinahPlayer")
		{
			double MaxHealthTrue = CountInv("PlayerMaxHP");
			if ((!player || !player.mo || player.mo != self) || !MaxHealthTrue) MaxHealthTrue = SpawnHealth();
			double HealthRatio = health / MaxHealthTrue;
			// Console.Printf("%.8f", HealthRatio);
			if (health > 0)
			{
				string painsnd = "";
				if (HealthRatio >= 0.751) painsnd = "Dinah/Pain1A";
				else if (HealthRatio >= 0.501 && HealthRatio < 0.750) painsnd = "Dinah/Pain2A";
				else if (HealthRatio >= 0.251 && HealthRatio <= 0.500) painsnd = "Dinah/Pain3A";
				else if (HealthRatio < 0.251) painsnd = "Dinah/Pain4A";
				A_StopSound(CHAN_VOICE);
				A_StartSound(painsnd,CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
			}
		}
	}
	
	int HasBuddha()
	{
		if (player.playerstate == PST_DEAD) return 0;
		if (player.cheats & CF_BUDDHA2) return 2;
		
		if ((player.cheats & CF_BUDDHA) ||
				(player.mo.bBUDDHA) ||
				 player.mo.FindInventory("PowerBuddha") != null) return 1;
		
		return 0;
	}
	
	const PPD_ALLOWPOWERFACTORS = 1;
	const PPD_ALLOWDAMAGEFACTORS = 2;
	const PPD_ALLOWSKILLDAMAGEFACTORS = 4;
	const PPD_POISONCANKILL = 8;
	const PPD_ALLOWAUTOHEALTH = 16;
	const PPD_ALLOWSTRIFEAUTOHEALTH = 32;
	
	void PlayerPoisonDamage(actor source, int damage, bool playPainSound, int PoisonFlags = 63, int PainInterval = 63)
	{
		bool allowpowerups, allowdmgfactors, allowskilldmgfactor, cankill, allowautohealth, allowstrifeautohealth;
		
		if (PoisonFlags & PPD_ALLOWPOWERFACTORS) allowpowerups = true;
		if (PoisonFlags & PPD_ALLOWDAMAGEFACTORS) allowdmgfactors = true;
		if (PoisonFlags & PPD_ALLOWSKILLDAMAGEFACTORS) allowskilldmgfactor = true;
		if (PoisonFlags & PPD_POISONCANKILL) cankill = true;
		if (PoisonFlags & PPD_ALLOWAUTOHEALTH) allowautohealth = true;
		if (PoisonFlags & PPD_ALLOWSTRIFEAUTOHEALTH) allowstrifeautohealth = true;
		
		actor target;
		
		if (player == null)
		{
			return;
		}
		target = player.mo;
		if (target.health <= 0)
		{
			return;
		}
		
		// This must be checked before any modifications. Otherwise, power amplifiers
		// may result in doing too much damage that cannot be negated by regular buddha,
		// which is inconsistent. The raw damage must be the only determining factor for
		// determining if telefrag is actually desired.
		bool telefragDamage = (damage >= TELEFRAG_DAMAGE && !(target.bLAXTELEFRAGDMG));
		
		if ((player.cheats & CF_GODMODE2) || (target.bNODAMAGE) || //These two are never subjected to telefrag thresholds.
			(!telefragDamage && ((target.bINVULNERABLE) || (player.cheats & CF_GODMODE))))
		{ // target is invulnerable
			return;
		}
		
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage (pre-factor): %d", damage);
		if (allowskilldmgfactor)
		{
			// Take half damage in trainer mode
			damage = int(damage * SKILLP_DamageFactor * sv_damagefactorplayer);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowskilldmgfactor - damage: %d", damage);
		}
		if (allowpowerups)
		{
			// Handle passive damage modifiers (e.g. PowerProtection)
			damage = target.GetModifiedDamage(player.poisontype, damage, true, null, source);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowpowerups - damage: %d", damage);
		}
		if (allowdmgfactors)
		{
			// Modify with damage factors
			damage = target.ApplyDamageFactor(player.poisontype, damage);
			if (dydudebug_playerpoisondisplays) Console.Printf("allowdmgfactors - damage: %d", damage);
		}
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage (post-factor): %d", damage);
		
		if (damage <= 0)
		{ // Damage was reduced to 0, so don't bother further.
			return;
		}
		
		if (allowautohealth)
		{
			if (damage >= player.health
				&& (SKILLP_AutoUseHealth || deathmatch)
				&& !player.morphTics)
			{ // Try to use some inventory health
				AutoUseHealth(damage - player.health+1);
			}
		}
		player.health -= damage; // mirror mobj health here for Dave
		if (allowstrifeautohealth)
		{
			int threshold = 50;
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem) threshold = (MiscItem.MaxHealthTrue * 0.5);
			if (player.health < threshold && !deathmatch)
			{
				AutoUseStrifeHealth();
			}
		}
		
		int healthfloor;
		if (cankill) healthfloor = 0; else healthfloor = 1;
		
		if (player.health < healthfloor) player.health = healthfloor;
		
		player.attacker = source;
		
		//*****************
		//* do the damage *
		//*****************
		if (dydudebug_playerpoisondisplays) Console.Printf("poison - damage: %d", damage);
		target.health -= damage;
		if (target.health < healthfloor) target.health = healthfloor;
		if (target.health <= 0)
		{ // Death
			int buddha = HasBuddha();
			if (telefragDamage && buddha == 1) buddha = 0;
			if (buddha)
			{ // [SP] Save the player... 
				player.health = target.health = 1;
			}
			else
			{
				target.special1 = damage;
				if (player && !player.morphTics)
				{ // Check for flame death
					if ((player.poisontype == 'Fire' ||
							 player.poisontype == 'CCFire' ||
							 player.poisontype == 'Flames' ||
							 player.poisontype == 'Burn' ||
							 player.poisontype == 'Inferno' ||
							 player.poisontype == 'Flare' ||
							 player.poisontype == 'SpecialFire') && (target.health > -50) && (damage > 25))
					{
						target.DamageType = 'Fire';
					}
					else
					{
						target.DamageType = player.poisontype;
					}
				}
				target.Die(source, source);
				return;
			}
		}
		if (PainInterval <= 0) PainInterval = 63;
		int PoisonTargInv = randompick(4,5,5,5,5,5,6);
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) PoisonTargInv -= randompick(0,1,1,1,1,1,1,1,1,1,1,1,1,2);
		int targtime = target.level.time & 63; // target.level.time % PainInterval;
		if (playPainSound)
		{
			bool PainSnd = false;
			if (!(targtime & 63))
			{
				PainSnd = true;
			}
			else
			{
				PoisonDmgPainInt++;
			}
			if (PoisonDmgPainInt >= PoisonTargInv) 
			{
				PainSnd = true;
				PoisonDmgPainInt = 0;
			}
			
			if (PainSnd)
			{
				state painstate = target.FindState("Pain", player.poisonpaintype);
				if (painstate != null) target.SetState(painstate);
			}
			if (dydudebug_playerpoisondisplays) Console.Printf("targtime: %d / %d, PoisonDmgPainInt: %d / %d", targtime, PainInterval, PoisonDmgPainInt, PoisonTargInv);
		}
	}
	
	override void CheckPoison()
	{
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;
		
		int countdec = randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7);
		int countint = randompick(14,15,15,15,15,15,15,15,15,15);
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD"))
		{
			countdec = (randompick(3,4,4,4,5,5,5,5,5,5,5,6,6,6,7) - randompick(0,1,1,1,1,1,1,1,1,2));
			countint = randompick(13,13,13,14,14,14,14,14,14,15);
		}
		if (CountInv("ExpeditionHat"))
		{
			countdec += (randompick(0,1,1,1,1,1,1,1,1,2) + 1);
			countint += randompick(0,2);
		}
		let player = self.player;
		let MiscItem = PlayerStatItem(player.mo.FindInventory("PlayerStatItem"));
		if (player.poisoncount && !(Level.maptime & countint))
		{
			player.poisoncount -= countdec;
			if (player.poisoncount < 0) player.poisoncount = 0;
			if (player.poisoncount > 0) A_SetInventory("IsPoisoned",1);
														 else A_SetInventory("IsPoisoned",0);
			if (dydudebug_playerpoisondisplays) Console.Printf("poisoncount: %d [\c[green]-%d\c-]", player.poisoncount, countdec);

			if (!(bINVULNERABLE ||
						CountInv("PowerInvulnerable") ||
						CountInv("PowerInvulnDD") ||
						player.cheats & CF_GODMODE2 ||
						player.cheats & CF_GODMODE))
			{
				int poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) 
				{
					poisdmg = randompick(1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3);
					poisdmg *= frandompick(1.25,1.375,1.375,1.5,1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
				}
				if (MiscItem) 
				{
					poisdmg = ((randompick(1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,3) * 0.01) * MiscItem.MaxHealthTrue);
					if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) 
					{
						poisdmg = ((randompick(1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3) * 0.01) * MiscItem.MaxHealthTrue);;
						poisdmg *= frandompick(1.25,1.375,1.375,1.5,1.5,1.5,1.5,1.5,1.5,1.625,1.625,1.75);
					}
					if (poisdmg < 1) poisdmg = 1;
					poisdmg *= exex_pdmgtakenfactor;
				}
				if (poisdmg > 0 && health > poisdmg)
				{
					int PainInterval = (63 - (player.poisoncount / randompick(4,5,5,5,5,6)));
					if (PainInterval < 15) PainInterval = 15;
					if (random(1,4) <= 1) 
					{
						if (random(1,8) <= 1) PainInterval *= 0.25;
														 else PainInterval *= 0.5;
					}
					PlayerPoisonDamage(player.poisoner, poisdmg, true, PPD_ALLOWAUTOHEALTH|PPD_ALLOWSTRIFEAUTOHEALTH, PainInterval);
					//player.PoisonDamage(player.poisoner, poisdmg, true);
					
					A_LossHUD(poisdmg, 0, true);
					if (exex_playerdmglog)
					{
						string combatlogmsg = "\c[sapphire]*\c- Took";
						combatlogmsg.AppendFormat(" \c[darkred]%d damage\c-", poisdmg);
						combatlogmsg.AppendFormat(" from poisoning!");
						if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
						Console.Printf(combatlogmsg);
					}

					let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
					let globalvars = DDGlobalVariables.Get();
					// Item/Ikari Point Gains
					if (CheckIPEnabled() && poisdmg && MiscItem && globalvars && health > 0)
					{
						if (MiscItem.IPNoGainTimer <= 0 && !MiscItem.HasHarmonicAnger)
						{
							double base;
							// The mod's first and original formula
							if (exex_ikaripointscalctype <= 0)
							{
								base = poisdmg * 100.0 / MiscItem.MaxHealthTrue;
								if (oldhealthratio == 0) base *= 1.0;
								if (oldhealthratio == 1) base *= 1.125;
								if (oldhealthratio == 2) base *= 1.25;
								if (oldhealthratio == 3) base *= 1.5;
								if (oldhealthratio == 4) base *= 2.25;
								if (oldhealth > 1 && health == 1) base *= 3.25;
								if (MiscItem.PlayerLUCK) base *= (0.125 + (ActualLevel * 0.00125) + (random(1,MiscItem.PlayerLUCK) * frandompick(0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.001,0.001,0.001,0.001,0.001,0.001,0.002,0.002,0.002,0.002,0.003,0.003)));
																		else base *= (0.125 + (ActualLevel * 0.00125));
								
							}
							// The more Lufia II equse formula
							if (exex_ikaripointscalctype >= 0)
							{
								base = poisdmg * 100.0 / oldhealth; // % of remaining HP removed
								if (base >= 0.001)
								{
									if (base >= 0.001 && base <= 50.000) base *= 0.50; // <= 50% equals half of the percent in IP points given [up to 25%]
									if (base >= 50.001 && base <= 65.000) base *= 0.558077; 
									if (base >= 65.001 && base <= 75.000) base *= 0.646154;
									if (base >= 75.001 && base <= 85.000) base *= 0.76; 
									if (base >= 85.001 && base <= 90.000) base *= 0.90; 
									if (base >= 90.001 && base <= 100.000) base *= 1.00; 
									if (base >= 100.001) base *= 1.25;
									if (oldhealth > 1 && health == 1) base += MiscItem.MaxItemPoints;
								}
							}
							base *= (frandompick(3.0,4.0,4.0,4.0,5.0,5.0,5.0,5.0,5.0,5.0,5.0,6.0,6.0,6.0,7.0) * 0.5);
							double basef = base;
							A_AddIP(base, basef, true, true, 0);
						}
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("poisoncount: %d (maptime: %d)", player.poisoncount, Level.maptime);
			}
		}
	}
}

class DinahPlayer : DDPlayerPawn // HereticPlayer
{
	int breathtic;
	int stepCounter;
	default
	{
		Health 80; // 100
		Player.MaxHealth 80;
		Player.MugShotMaxHealth -1; // 100
		Radius 12; // Dinah is actually SLIGHTLY thinner than even Flora is in Aetherius [24 wide]
		Height 48; // Slightly Shorter than Flora in Aetherius
		Mass 60;
		Player.DisplayName "Dinah Wyck";
		Player.SoundClass "DinahPlayer";
		Player.StartItem "ClassID", 1;
		Player.StartItem "PlayerStatItem";
		Player.StartItem "PlayerDashJump";
		Player.StartItem "ResetInventory";
		Player.StartItem "CricketBat";
		Player.StartItem "HandToHand";
		Player.StartItem "MalletAmmo", 10;
		Player.Weaponslot 1, "HandToHand";
		Player.Weaponslot 2, "CricketBat";
		Player.Weaponslot 3, "Blundaxe", "Scrambler";
		Player.Weaponslot 4, "AppleJack";
		Player.Weaponslot 5, "WizardPike";
		Player.Weaponslot 6, "SuperVac";
		Player.Weaponslot 7, "Grimophone";
		Player.WeaponSlot 8, "SigilDD", "CandleWhip";
		Player.WeaponSlot 9, "CrazyBallDD";
		Player.WeaponSlot 0, "FosnianCandle";
		Player.ForwardMove 0.75, 0.75; // 0.75
		Player.SideMove 0.65, 0.65; // 0.65
		Player.ViewBob 0.5;
		Player.AttackZOffset 8;
		Player.AirCapacity 1;
		Player.JumpZ 9;
		//Player.GruntSpeed 12;
		Player.ViewHeight 36;
		Player.InvulnerabilityMode "Reflective";
		Species "Players";
		XScale 1.0; //0.8572;
		YScale 0.95; //0.8572;
		Tag "Dinah Wyck";
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}
	
	override void Tick()
	{
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
		
		if (InStateSequence(curstate,ResolveState("Death")) ||
				InStateSequence(curstate,ResolveState("XDeath")) ||
				InStateSequence(curstate,ResolveState("Burn")) ||
				InStateSequence(curstate,ResolveState("Ice")))
		{
			A_APPBreatheReset();
		}
		else
		{
			breathtic++;
			if (breathtic >= 4)
			{
				A_APPBreathe();
				breathtic = 0;
			}
		}
	}
	
	int A_DinahChase()
	{
		tics = 4;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			if (MiscItem.HUDSpeed >= 4.0) tics = ceil(tics *= 0.875);
			if (MiscItem.HUDSpeed >= 3.0) tics = ceil(tics *= 0.9375);
			if (MiscItem.HUDSpeed >= 2.0) tics = ceil(tics *= 0.96875);
			if (MiscItem.HUDSpeed <= 0.75) tics = ceil(tics *= 1.25);
			if (MiscItem.HUDSpeed <= 0.50) tics = ceil(tics *= 1.5);
			if (MiscItem.HUDSpeed <= 0.25) tics = ceil(tics *= 1.75);
			if (MiscItem.HUDSpeed <= 0.0625) tics = ceil(tics *= 2.0);
		}
		if (CountInv("PowerWineBuffIPWeak")) tics = ceil(tics *= 1.032258064516129);
		if (CountInv("PowerWineBuffIPStrong")) tics = ceil(tics *= 1.066666666666667);
		if (CountInv("PowerWineBuffIPStrongest")) tics = ceil(tics *= 1.103448275862069);
		if (CountInv("PowerWineBuffIPStrongestEven")) tics = ceil(tics *= 1.142857142857143);
		if (CountInv("PowerWineBuffIPMaximum")) tics = ceil(tics *= 1.230769230769231);
		if (CountInv("PowerWineBuffWeak")) tics = ceil(tics *= 1.142857142857143);
		if (CountInv("PowerWineBuffStrong")) tics = ceil(tics *= 1.333333333333333);
		if (CountInv("PowerWineBuffStrongest")) tics = ceil(tics *= 1.6);
		if (CountInv("PowerWineBuffStrongestEven")) tics = ceil(tics *= 2.0);
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tics = ceil(tics *= 0.875);
		if (CountInv("OverFullHealth3")) tics = ceil(tics *= 0.85);
		if (CountInv("OverFullHealth2")) tics = ceil(tics *= 0.9);
		if (CountInv("OverFullHealth1")) tics = ceil(tics *= 0.95);
		if (CountInv("NormalHealth")) tics = ceil(tics *= 1);
		if (CountInv("DecentHealth")) tics = ceil(tics *= 1.125);
		if (CountInv("LowHealth")) tics = ceil(tics *= 1.25);
		if (CountInv("CriticalHealth")) tics = ceil(tics *= 1.375);
		
		if (dydudebug_playerwalkdisplays) Console.Printf("Tics (See): %d", tics);
		if (tics < 1) tics = 1;
		A_SetTics(tics);
		return tics;
	}
	
	States
	{
		Spawn:
			DINA A 4
			{
			}
			Loop;
		See:
			DINA B 4
			{
				A_DinahChase();
				A_SetInventory("IsStepping",(A_DinahChase()*2));
			}
			DINA C 4
			{
				A_DinahChase();
			}
			DINA D 4
			{
				A_DinahChase();
				A_SetInventory("IsStepping",(A_DinahChase()*2));
			}
			DINA E 4
			{
				A_DinahChase();
			}
			Loop;
		Pain:
			DINA H 6 
			{
				A_DDPain();
				A_SetInventory("IsStepping",0);
			}
			Goto Spawn;
		Missile:
			DINA F 2;
			DINA F 2 A_DynamicMusic(patktype:0);
			DINA FGGG 2
			{
			}
			Goto Spawn;
		Melee:
			DINA F 0 A_DynamicMusic(patktype:1);
			DINA FGF 4
			{
			}
			Goto Spawn;
		BatGuard:
			DINA LL 1
			{
			}
			DINA L 0
			{
			}
			Goto Spawn;
		ShieldGuard:
			DINA LL 2
			{
			}
			DINA L 0
			{
			}
			Goto Spawn;
		SpinAttackBatPre:
			DINA F 0 A_DynamicMusic(patktype:1);
			DINA FF 1
			{
			}
			DINA F 0
			{
			}
			Goto Spawn;
		SpinAttackBat:
			DINS A 0 A_DynamicMusic(patktype:1);
			DINS AA 1
			{
			}
			DINS A 0
			{
			}
			Goto Spawn;
		PrePunch:
			DINA A 0 A_DynamicMusic(patktype:2);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		Punch1:
			DINX FFFFFF 1 A_SetInventory("PPunching",1);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		Punch2:
			DINX FFFFFF 1 A_SetInventory("PPunching",1);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		Punch3:
			DINX GGGGGGGG 1 A_SetInventory("PPunching",1);
			DINX G 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		Punch4:
			DINX FFFFFF 1 A_SetInventory("PPunching",1);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		Punch5:
			DINX FFFFFFFF 1 A_SetInventory("PPunching",1);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		PunchOra1:
			DINX FFFF 1 A_SetInventory("PPunching",1);
			DINX F 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		PunchOra2:
			DINX GGGG 1 A_SetInventory("PPunching",1);
			DINX G 0 A_SetInventory("PPunching",0);
			Goto Spawn;
		PreKick:
			DINA A 0 A_DynamicMusic(patktype:2);
			DINK A 0
			{
				A_SetInventory("PKicking",0);
			}
			Goto Spawn;
		Kick:
			DINK AA 1
			{
				A_SetInventory("PKicking",1);
			}
			DINK A 0
			{
				A_SetInventory("PKicking",0);
			}
			Goto Spawn;
		Kick2:
			DINK BB 1
			{
				A_SetInventory("PKicking",1);
			}
			DINK B 0
			{
				A_SetInventory("PKicking",0);
			}
			Goto Spawn;
		Death:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 
			{
				A_PlayerScream();
				if (exex_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			DINA I 9 A_NoBlocking();
			DINA JK 9;
			DINA K -1;
			Stop;
		XDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 
			{
				A_PlayerScream();
				if (exex_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			DINA I 9 A_NoBlocking();
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 
			{
				A_PlayerScream();
				if (exex_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			DINA I 9 A_NoBlocking();
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinXDeath:
			DINA H 0 A_APPBreatheReset();
			DINA H 9 
			{
				A_PlayerScream();
				if (exex_deathmusic == 13 && !A_CheckUOHYM()) A_StartSound("FTDTHSN",144,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
			DINA I 9 A_NoBlocking();
			DINA JK 9;
			DINA K -1;
			Stop;
		Burn:
			goto Death;
		Ice:
			goto Death;
	}
}

class DinahTIPAImage : EEVisualAImage
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 1.00;
		+NOGRAVITY
		+THRUACTORS
		RenderStyle "AddStencil";
		StencilColor "Orange";
		-VISIBILITYPULSE
		+NOTIMEFREEZE
	}
	
	States
	{
		Spawn:
			"####" "#" 0 Bright;
			"####" "#" 0 Bright A_FadeTo(alpha * 0.75, 0.75, false);
			"####" "#" 0 Bright ThrustThingZ(0, 2, 0, 0);
			"####" "#" 0 A_Jump (256, "SpawnLoop");
			Goto SpawnLoop;
		SpawnLoop:
			"####" "#" 0 Bright A_FadeTo(0, 0.25, true);
			"####" "#" 1 Bright //Light("KTAIMAGE1")
			{
				if (GetAge() <= 0) A_SetScale(1.08334,1.08334);
				if (GetAge() == 1) A_SetScale(1.16667,1.16667);
				if (GetAge() == 2) A_SetScale(1.25,1.25);
				if (GetAge() >= 3) A_SetScale(1.33334,1.33334);
			}
			Goto SpawnLoop;
	}
}

class RavenPlayer : DDPlayerPawn
{
	default
	{
		Player.DisplayName "Dinah Wyck [Raven Form]";
		Tag "Dinah Wyck [Raven Form]";
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 16;
		Height 32;
		Speed 0.5;
		+NoSkin
		-PickUp
		+NoTarget
		Player.Viewheight 32;
		Player.DisplayName "Raven";
		Player.MorphWeapon "RavenWeapon";
	}
	States
	{
		Spawn:
			RVPL A 0;
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		See:
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		Pain:
			RVPL C 4 A_Pain();
			Goto Spawn;
		Death:
			TNT1 A -1;
			Stop;
	}
}

class EggFXEE : MorphProjectile replaces EggFX
{
	Default
	{
		Radius 8;
		Height 8;
		Speed 18;
		MorphProjectile.PlayerClass "ChickenPlayerDD";
		MorphProjectile.MonsterClass "Chicken";
		MorphProjectile.MorphStyle MRF_UNDOBYTOMEOFPOWER;
	}
	States
	{
		Spawn:
			EGGM ABCDE 4;
			Loop;
		Death:
			FX01 FFGH 3 Bright;
			Stop;
	}
}


class ChickenPlayerDD : DDPlayerPawn
{
	Default
	{
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 16;
		Height 24;
		Speed 1;
		Gravity 0.125;
		+NOSKIN
		+PLAYERPAWN.CANSUPERMORPH
		PainSound "chicken/pain";
		DeathSound "chicken/death";
		Player.JumpZ 1;
		Player.Viewheight 21;
		Player.ForwardMove 1.22, 1.22;
		Player.SideMove 1.22, 1.22;
		Player.SpawnClass "Chicken";
		Player.SoundClass "Chicken";
		Player.DisplayName "Chicken";
		Player.MorphWeapon "Beak";
		-PICKUP
	}

	States
	{
		Spawn:
			CHKN A -1;
			Stop;
		See:
			CHKN ABAB 3;
			Loop;
		Melee:
		Missile:
			CHKN C 12;
			Goto Spawn;
		Pain:
			CHKN D 4 A_Feathers;
			CHKN C 4 A_Pain;
			Goto Spawn;
		Death:
			CHKN E 6 A_Scream;
			CHKN F 6 A_Feathers;
			CHKN G 6;
			CHKN H 6 A_NoBlocking;
			CHKN IJK 6;
			CHKN L -1;
			Stop;
	}
	
	//---------------------------------------------------------------------------
	//
	// PROC P_UpdateBeak
	//
	//---------------------------------------------------------------------------

	override void MorphPlayerThink ()
	{
		if (health > 0)
		{ // Handle beak movement
			PSprite pspr;
			if (player != null && (pspr = player.FindPSprite(PSP_WEAPON)) != null)
			{
				pspr.y = WEAPONTOP + player.chickenPeck / 2;
			}
		}
		if (player.morphTics & 15)
		{
			return;
		}
		if (Vel.X == 0 && Vel.Y == 0 && random[ChickenPlayerThink]() < 160)
		{ // Twitch view ang
			angle += Random2[ChickenPlayerThink]() * (360. / 256. / 32.);
		}
		if ((pos.z <= floorz) && (random[ChickenPlayerThink]() < 32))
		{ // Jump and noise
			Vel.Z += JumpZ;

			State painstate = FindState('Pain');
			if (painstate != null) SetState (painstate);
		}
		if (random[ChickenPlayerThink]() < 48)
		{ // Just noise
			A_StartSound ("chicken/active", CHAN_VOICE);
		}
	}
}

class PorkFXEE : MorphProjectile replaces PorkFX
{
	Default
	{
		Radius 8;
		Height 8;
		Speed 18;
		MorphProjectile.PlayerClass "PigPlayerDD";
		MorphProjectile.MonsterClass "Pig";
		MorphProjectile.MorphStyle MRF_UNDOBYTOMEOFPOWER|MRF_UNDOBYCHAOSDEVICE;
	}
	States
	{
		Spawn:
			PRKM ABCDE 4;
			Loop;
		Death:
			FHFX IJKL 3 Bright;
			Stop;
	}
}
class PigPlayerDD : DDPlayerPawn
{
	Default
	{
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 16;
		Height 24;
		Speed 1;
		+WINDTHRUST
		+NOSKIN
		-PICKUP
		PainSound "PigPain";
		DeathSound "PigDeath";
		Player.JumpZ 6;
		Player.Viewheight 28;
		Player.ForwardMove 0.96, 0.98;
		Player.SideMove 0.95833333, 0.975;
		Player.SpawnClass "Pig";
		Player.SoundClass "Pig";
		Player.DisplayName "Pig";
		Player.MorphWeapon "Snout";
	}

	States
	{
		Spawn:
			PIGY A -1;
			Stop;
		See:
			PIGY ABCD 3;
			Loop;
		Pain:
			PIGY D 4 A_PigPain();
			Goto Spawn;
		Melee:
		Missile:
			PIGY A 12;
			Goto Spawn;
		Death:
			PIGY E 4 A_Scream();
			PIGY F 3 A_NoBlocking();
			PIGY G 4;
			PIGY H 3;
			PIGY IJK 4;
			PIGY L -1;
			Stop;
		Ice:
			PIGY M 5 A_FreezeDeath();
			PIGY M 1 A_FreezeDeathChunks();
			Wait;
	}
	

	override void MorphPlayerThink ()
	{
		if (player.morphTics & 15)
		{
			return;
		}
		if(Vel.X == 0 && Vel.Y == 0 && random[PigPlayerThink]() < 64)
		{ // Snout sniff
			if (player.ReadyWeapon != null)
			{
				player.SetPsprite(PSP_WEAPON, player.ReadyWeapon.FindState('Grunt'));
			}
			A_StartSound ("PigActive1", CHAN_VOICE); // snort
			return;
		}
		if (random[PigPlayerThink]() < 48)
		{
			A_StartSound ("PigActive", CHAN_VOICE); // snort
		}
	}
}

class RatPlayer : DDPlayerPawn
{
	default
	{
		Player.DisplayName "Dinah Wyck [Rat Form]";
		Tag "Dinah Wyck [Rat Form]";
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 10;
		Height 16;
		Speed 1;
		+NOSKIN
		-PICKUP
		PainSound "Rat/Pain";
		DeathSound "Rat/Death";
		Player.JumpZ 3;
		Player.Viewheight 14;
		Player.ForwardMove 0.75, 0.75;
		Player.SideMove 0.65, 0.65;
		Player.SpawnClass "Rat";
		Player.SoundClass "Rat";
		Player.DisplayName "Rat";
		Player.MorphWeapon "RatNose";
	}
	
	States
	{
		Spawn:
			RATS A 0 A_StopSound(5);
			RATS A -1;
			Stop;
		See:
			RATS ABC 3;
			Loop;
		Melee:
		Missile:
			RATS B 8;
			RATS A 8;
			Goto Spawn;
		Pain:
			RATS C 4 A_Pain();
			Goto Spawn;
		Death:
			RATS D 6 A_Scream();
			RATS E 6 A_NoBlocking();
			RATS F 6;
			TNT1 A 1 A_CheckPlayerDone();
			Wait;
	}
}

class EVP_Footsteps : Actor
{
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	int TrueGameSkill;

	PlayerPawn plr;

	int tickCounter;
	double truecrouchfactor, fstpitch, fstvolume;

	array<int> fs_textures;
	array<string> fs_sndinfo;
	string defaultSndinfo;

	void Init(PlayerPawn toAttach)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		plr = toAttach;
		tickCounter = 2;
		
		array<string> allSF;
		StringTable.Localize("$STEP_FLATS").Split(allSF,":");
		Console.Printf("Default Footsteps TXT Loaded");
		StringTable.Localize("$STEP_FLATSOTEX").Split(allSF,":");
		Console.Printf("OTex Footsteps TXT Loaded");
		// Trilogy-Specific
		StringTable.Localize("$STEP_FLATSDDT").Split(allSF,":");
		Console.Printf("DDT Footsteps TXT Loaded");
		// Other CompatPacks
		if (Wads.CheckNumForName("EE-AUGZEN", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSAUGZEN").Split(allSF,":");
			Console.Printf("AUGER;ZENITH Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSBLOOM").Split(allSF,":");
			Console.Printf("BlooM Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-CIRCUS2", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSCIRCUS2").Split(allSF,":");
			Console.Printf("Circus2 Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-KDIZD", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSKDIZD").Split(allSF,":");
			Console.Printf("KDIZD Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-TCOTDA", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSTCOTDA").Split(allSF,":");
			Console.Printf("TCOTDA Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-TUTNT", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSTUTNT").Split(allSF,":");
			Console.Printf("Ultimate Torment and Torture Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-UNFAM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSUNFAM").Split(allSF,":");
			Console.Printf("Unfamiliar Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-STAEONS", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSSTAEONS").Split(allSF,":");
			Console.Printf("Strange Aeons Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-EPIC2", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSEPIC2").Split(allSF,":");
			Console.Printf("Epic2 Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-EXDAY", Wads.ns_global, -1, true) != -1)
		{
			StringTable.Localize("$STEP_FLATSEXTDAY").Split(allSF,":");
			Console.Printf("Extermination Day Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-HELLG", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSHELLG").Split(allSF,":");
			Console.Printf("Hell Ground Footsteps TXT Loaded");
		}
		if (Wads.CheckNumForName("EE-UOHYM", Wads.ns_global, -1, true) != -1) 
		{
			StringTable.Localize("$STEP_FLATSUOHYM").Split(allSF,":");
			Console.Printf("UOHYM TXT Loaded");
		}
		
		for (int j = allSF.Size() - 1; j >= 0; j -= 1)
		{
			string s = StringTable.Localize(String.Format("$STEP_%s", allSF[j]));
			//Console.Printf("j: %d, %s, string: %s [Length: %d]", j, allSF[j], s, s.Length());
			
			if (s.Length() != 0)
			{
				textureid t = TexMan.CheckForTexture(allSF[j], TexMan.TYPE_ANY);
				if (t.Exists())
				{
					//Console.Printf("[2] j: %d, %s", j, allSF[j]);
					fs_textures.Push(int(t));
					
					fs_sndinfo.Push(s);
				}
			}
		}
		defaultSndinfo = StringTable.Localize("$STEP_DEFAULT");
	}
	
	bool A_CheckDDGame()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || 
				player.CountInv("IsAppetite") || 
				player.CountInv("IsCarnOfSouls") || 
				player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	int A_CheckActualLevel(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_CheckActualLevel - DDPlayerPawn)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void HandleFootsteps(int type = 0, bool isrunning = false)
	{
		let DDPawn = DDPlayerPawn(plr);
		let MiscItem = PlayerStatItem(plr.FindInventory("PlayerStatItem"));
		let DashItem = PlayerDashJump(plr.FindInventory("PlayerDashJump"));
		if (MiscItem)
		{
			bool berserked;
			if (plr.CountInv("PowerStrength") || plr.CountInv("PowerStrengthDD")) berserked = true;

			int ActualLevel = A_CheckActualLevel(1);
			let PlayerWeapon = plr.player.ReadyWeapon;
			truecrouchfactor = 1.0 - ((1.0 - plr.player.crouchfactor) * 1.5);
			
			int sndchanshift = 0;
			if (type == 1) sndchanshift = 10;
			fstpitch = frandom(1.125,1.225);
			fstvolume = CVar.GetCvar("exex_footstepvolume", players[0]).GetFloat();
			fstvolume *= truecrouchfactor;
			if (type == 1) 
			{
				double landtemp = frandom(0.5,0.667);
				fstpitch *= landtemp; // Landing
				fstvolume *= (1.0 / landtemp);
			}
			else
			{
				if (!isrunning) 
				{
					fstvolume *= frandom(0.50,0.667);
					fstpitch *= frandom(1.05,1.125);
				}
			}

			double WeaponFactor = 1.0;
			double WeaponFactorEx = 0.0;
			if (PlayerWeapon is "HandToHand") 
			{
				if (berserked) WeaponFactorEx += 0.25;
									else WeaponFactorEx += 0.125;
				fstpitch *= (1.0 + (WeaponFactorEx * frandom(0.875,1.125)));
			}
			if (PlayerWeapon is "CricketBat")
			{
				if (berserked) WeaponFactorEx += 0.1875;
									else WeaponFactorEx += 0.00;
				
				if (plr.CountInv("CricketBatGuard3")) WeaponFactorEx *= frandom(0.825,0.90);
				if (plr.CountInv("CricketBatGuard2")) WeaponFactorEx *= frandom(0.90,0.95);
				if (plr.CountInv("CricketBatGuard")) WeaponFactorEx *= frandom(0.95,1.0);
			}
			if (PlayerWeapon is "BlunderAxe")
			{
				if (berserked) WeaponFactorEx -= 0.025;
									else WeaponFactorEx -= 0.05;
			}
			if (PlayerWeapon is "AppleJack")
			{
				if (berserked) WeaponFactorEx += 0.075;
									else WeaponFactorEx += 0.05;
				
				if (plr.CountInv("AppleJackGuard3")) WeaponFactorEx *= frandom(0.9125,0.95);
				if (plr.CountInv("AppleJackGuard2")) WeaponFactorEx *= frandom(0.95,0.975);
				if (plr.CountInv("AppleJackGuard")) WeaponFactorEx *= frandom(0.975,1.0);
			}
			if (PlayerWeapon is "Scrambler")
			{
				if (berserked) WeaponFactorEx += 0.1875;
									else WeaponFactorEx += 0.125;
				
				if (plr.CountInv("ScramblerGuard3")) WeaponFactorEx *= frandom(0.65,0.80);
				if (plr.CountInv("ScramblerGuard2")) WeaponFactorEx *= frandom(0.80,0.90);
				if (plr.CountInv("ScramblerGuard")) WeaponFactorEx *= frandom(0.90,1.0);
			}
			if (PlayerWeapon is "WizardPike")
			{
				if (berserked) WeaponFactorEx += 0.1875;
									else WeaponFactorEx += 0.125;
			}
			if (PlayerWeapon is "SuperVac") 
			{
				double SuperVacAmmoFactor = MiscItem.SuperVacAmmoFactor;
				if (berserked) WeaponFactorEx -= (0.0625 + SuperVacAmmoFactor);
									else WeaponFactorEx -= (0.125 + SuperVacAmmoFactor);
			}
			if (PlayerWeapon is "Grimophone") 
			{
				if (berserked) WeaponFactorEx -= 0.09375;
									else WeaponFactorEx -= 0.1875;
			}
			if (PlayerWeapon is "CandleWhip") 
			{
				if (berserked) WeaponFactorEx += 0.125;
									else WeaponFactorEx += 0.0625;
			}
			if (PlayerWeapon is "FosnianCandle") 
			{
				if (berserked) WeaponFactorEx += 0.075;
									else WeaponFactorEx += 0.05;
			}
			if (PlayerWeapon is "EvilWarriorShield")
			{
				int HellWarriorShieldLevel = plr.CountInv("HellWarriorShieldLevel");
				if (berserked)
				{
					if (plr.CountInv("HWShieldBlockHold")) WeaponFactorEx -= (0.15 * (1.0 + (HellWarriorShieldLevel * 0.009375)));
																						else WeaponFactorEx -= (0.075 * (1.0 + (HellWarriorShieldLevel * 0.0046875)));
				}
				else
				{
					if (plr.CountInv("HWShieldBlockHold")) WeaponFactorEx -= (0.30 * (1.0 + (HellWarriorShieldLevel * 0.01875)));
																						else WeaponFactorEx -= (0.15 * (1.0 + (HellWarriorShieldLevel * 0.009375)));
				}
			}
			if (PlayerWeapon is "CrazyBallDD")
			{
			}
			if (PlayerWeapon is "SigilDD") 
			{
			}
			WeaponFactorEx *= 0.25;
			WeaponFactorEx += 1.0;
			WeaponFactorEx *= frandom(0.875,1.125);
			double oldfstpitch = fstpitch;
			fstpitch *= WeaponFactorEx;
			if (dydudebug_footsteps) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [WeaponFactorEx: %.8f]", fstpitch, oldfstpitch, WeaponFactorEx);
			if (DDPawn)
			{
				oldfstpitch = fstpitch;
				double ArmorEnc = (MiscItem.ArmorML * (0.0625 * random(randompick(11,12,12,12,12),randompick(14,14,14,14,15))));
				if (dydudebug_footsteps) Console.Printf("\c[gold](EVP_Footsteps)\c- ArmorEnc: %.8f (%.8f)", ArmorEnc, MiscItem.ArmorML, WeaponFactorEx);
				double lvlfact = 0.02;
				if (A_CheckDDGame()) 
				{
					ArmorEnc *= 1.5;
					ArmorEnc *= exex_nrpggeneraleffect;

					if (TrueGameSkill <= SKILL_VERY_EASY)	lvlfact = 0.020;
					if (TrueGameSkill == SKILL_EASY)			lvlfact = 0.0175;
					if (TrueGameSkill == SKILL_NORMAL)		lvlfact = 0.015;
					if (TrueGameSkill == SKILL_HARD)			lvlfact = 0.0125;
					if (TrueGameSkill >= SKILL_VERY_HARD)	lvlfact = 0.01;
				}
				else
				{
					if (TrueGameSkill <= SKILL_VERY_EASY)	lvlfact = 0.04;
					if (TrueGameSkill == SKILL_EASY)			lvlfact = 0.035;
					if (TrueGameSkill == SKILL_NORMAL)		lvlfact = 0.03;
					if (TrueGameSkill == SKILL_HARD)			lvlfact = 0.025;
					if (TrueGameSkill >= SKILL_VERY_HARD)	lvlfact = 0.02;
				}
				if (plr.waterlevel >= 3) 
				{
					if (A_CheckDDGame()) ArmorEnc *= 1.5;
													else ArmorEnc *= 1.25;
					if (A_CheckDDGame()) lvlfact *= 0.5;
													else lvlfact *= 0.75;
				}
				if (ArmorEnc > 0.0) ArmorEnc *= (1.0 - (ActualLevel * lvlfact));
				if (ArmorEnc < 0.0) ArmorEnc = 0.0;
				double ArmorFactor = (1.0 - ArmorEnc);
				if (ArmorFactor > 1.00) ArmorFactor = 1.00;
				fstpitch *= ArmorFactor;
				
				if (dydudebug_footsteps) Console.Printf("\c[gold](EVP_Footsteps)\c- fstpitch: %.8f (oldfstpitch: %.8f), [ArmorFactor: %.8f]", fstpitch, oldfstpitch, ArmorFactor);
			}
			
			int idx = fs_textures.Find(int(plr.floorpic));
			string texname = texman.GetName(plr.floorpic);
			
			string sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo;
			string sndnamed = "step/squeaky1";
			bool nulltext;
			if (texname == "" ||
					texname == "-NOFLAT-") 
			{
				sndnamed = "null";
				nulltext = true;
			}
			if (texname == "DOPE2 R")
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "GRNROCK")
			{
				sndnamed = "step/rock";
				if (Wads.CheckNumForName("EE-HELLG", Wads.ns_global, -1, true) != -1) sndnamed = "step/wood";
				if (Wads.CheckNumForName("EE-AUGZEN", Wads.ns_global, -1, true) != -1) sndnamed = "step/grass";
				if (Wads.CheckNumForName("EE-UNFAM", Wads.ns_global, -1, true) != -1) sndnamed = "step/rock";
				nulltext = true;
			}
			if (texname == "STEP1" ||
					texname == "STEP2" ||
					texname == "STEP3" ||
					texname == "A-DAN1" ||
					texname == "A-DAN2" ||
					texname == "A-DAN3" ||
					texname == "A-DAN4" ||
					texname == "A-DAN5") 
			{
				sndnamed = "step/metal/a";
				nulltext = true;
			}
			if (texname == "A-BRICK2" ||
					texname == "A-BROCK1" ||
					texname == "A-BROCK2" ||
					texname == "A-CAMO3A" ||
					texname == "A-DBRI1") 
			{
				sndnamed = "step/hard";
				nulltext = true;
			}
			if (texname == "A-CAMO1" ||
					texname == "A-CAMO1A" ||
					texname == "A-CAMO2A" ||
					texname == "A-CAMO2C")
			{
				sndnamed = "step/grass";
				nulltext = true;
			}
			if (dydudebug_footsteps || dydudebug_footsteps2) sndname = idx != fs_textures.Size() ? fs_sndinfo[idx] : sndnamed;
			int dupe1chance = 6;
			int dupe2chance = 4;
			int dupe3chance = 0;
			int dupe4chance = 0;
			if (type == 1)
			{
				dupe1chance *= 1.667;
				dupe2chance *= 1.500;
				dupe3chance = int(5 * 1.334);
				dupe4chance = int(5 * 1.25);
			}
			plr.A_StartSound(sndname,
											 (801 + sndchanshift), CHANF_DEFAULT,
											 (fstvolume * 1.0),
											 ATTN_NORM,
											 fstpitch);
			if (random(1,10) <= dupe1chance)
			{
				plr.A_StartSound(sndname,
												(802 + sndchanshift), CHANF_DEFAULT,
												type != 1 ? (fstvolume * 0.8) : (fstvolume * 0.9),
												ATTN_NORM,
												fstpitch);
				if (random(1,10) <= dupe2chance)
				{
					plr.A_StartSound(sndname,
													(803 + sndchanshift), CHANF_DEFAULT,
													type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
													ATTN_NORM,
													fstpitch);
					if (random(1,10) <= dupe3chance)
					{
						plr.A_StartSound(sndname,
														(804 + sndchanshift), CHANF_DEFAULT,
														type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
														(fstvolume * 0.6),
														ATTN_NORM,
														fstpitch);
						if (random(1,10) <= dupe4chance)
						{
							plr.A_StartSound(sndname,
															(805 + sndchanshift), CHANF_DEFAULT,
															type != 1 ? (fstvolume * 0.6) : (fstvolume * 0.8),
															ATTN_NORM,
															fstpitch);
						}
					}
				}
			}
			
			bool defaultsound;
			if (idx != fs_textures.Size()) defaultsound = false; 
																else defaultsound = true;
			if (dydudebug_footsteps) 
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
										 else Console.Printf("\c[green]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[green]%s\c-, \c[green]floorpic: \c[gold]%d\c-, \c[green]truecrouchfactor: \c[orange]%.8f\c-, \c[green]fstpitch: \c[olive]%.8f\c-, \c[green]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
			else
			if (dydudebug_footsteps2)
			{
				if (defaultsound && !nulltext) Console.Printf("\c[red]FootStepSound (type: %d): %s\c-, \c[orange]texname: \c[red]%s\c-, \c[red]floorpic: \c[gold]%d\c-, \c[red]truecrouchfactor: \c[orange]%.8f\c-, \c[red]fstpitch: \c[olive]%.8f\c-, \c[red]fstvolume: \c[olive]%.8f\c- [%d]", type, idx != fs_textures.Size() ? fs_sndinfo[idx] : defaultSndinfo, texname, plr.floorpic, truecrouchfactor, fstpitch, fstvolume, gametic);
			}
		}
	}
	
	override void Tick()
	{
		tickCounter -= 1;
		if (tickCounter > 0)
		{
			Super.Tick();
			return;
		}

		double speed2d = (plr.vel.x * plr.vel.x) + (plr.vel.y * plr.vel.y);
		bool isrunning = false;
		bool ismanualmove = false;
		if (plr.player.cmd.buttons & BT_MOVELEFT ||
				plr.player.cmd.buttons & BT_MOVERIGHT ||
				plr.player.cmd.buttons & BT_FORWARD ||
				plr.player.cmd.buttons & BT_BACK) ismanualmove = true;
		if (cl_run) 
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = false; 
																				else isrunning = true; 
		}
		else
		{
			if (plr.player.cmd.buttons & BT_SPEED) isrunning = true; 
																				else isrunning = false; 
		}
		if (dydudebug_footsteps) Console.Printf("isrunning: %d, cl_run: %d, buttons: %d", isrunning, cl_run, plr.player.cmd.buttons);

		/* Only play footsteps when on the ground and moving fast enough.
			 The original speed threshold was ridiculously low for vanilla
			 movement. This new scheme has ample margin for AutoWalking,
			 my slowest movement warranting footsteps, plus the granularity
			 for several footstep intervals when moving faster.
		 */
		double basespd = 19.2;
		if (isrunning) basespd = 24.0;
		if (dydudebug_footsteps) Console.Printf("basespd: %.8f", basespd);
		if (speed2d >= basespd && 
				(plr.waterlevel <= 1 && plr.WaterDepth <= (plr.height * 0.1667)) &&
				(plr.pos.z - plr.floorz) <= 0 &&
				!plr.CountInv("DashTics") &&
				ismanualmove &&
				plr.GetClassName() == "DinahPlayer")
		{
			HandleFootsteps(0,isrunning); // Walking
			
			double baseinc = 32.0;
			if (isrunning) baseinc = 40;
			if (dydudebug_footsteps) Console.Printf("baseinc: %.8f", baseinc);
			if (speed2d < (baseinc * 1)) tickCounter = 12;
			else if (speed2d < (baseinc * 2.4)) tickCounter = 11;
			else if (speed2d < (baseinc * 3.9)) tickCounter = 10;
			else if (speed2d < (baseinc * 5.5)) tickCounter = 9;
			else if (speed2d < (baseinc * 7.2)) tickCounter = 8;
			else tickCounter = 7;
		}
		else 
		{
			// poll for movement
			if (plr.CountInv("DashTics")) tickCounter = random(6,9);
															 else tickCounter = 3; 
		}
		if (!isrunning) tickCounter *= 1.75;
		if (exex_footstepcounttype) tickCounter = plr.CountInv("IsStepping");
		if (dydudebug_footsteps) Console.Printf("\c[sapphire]speed2d: %.8f\c-, \c[gold]tickCounter: %d\c- [%d]", speed2d, tickCounter, gametic);
		
		Super.Tick();
	}

	Default
	{
		+NOINTERACTION
	}
}