class DDPlayerPawn : PlayerPawn
{
	int ipmodecooldowntimer;
	bool isvoodoodoll;
	int neverbleeds;
	bool recalledall;
	int ipchargesoundtimer;
	
	int lasthealth;
	
	int DashTimer; int MaxDashTimer; 
	int cooldash; bool sounddash; 
	int thrudash; bool isdashing;
	double floordashvel, airdashvel, dashjumpstrength;
	double dashvelx, dashvely, dashvelz;

	int dashcooldown;
	int dashcooldownmax;
	
	int deadtimer;
	int fadetime;
	int originalheight;
	int originalradius;
	int originalmass;

	int firsttic;
	int buttons, input;
	
	double TotalAirControl;
	double basexscale, baseyscale;
	double scalexmulti, scaleymulti;
	
	mixin IPCostCheck;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
		RenderStyle "Add";
		Alpha 1.0;
	}
	
	//===========================================================================
	//
	// G_PlayerFinishLevel
	// Called when a player completes a level.
	//
	// flags is checked for RESETINVENTORY and RESETHEALTH only.
	//
	//===========================================================================

	void PlayerFinishLevel (int mode, int flags)
	{
		Console.Printf("PlayerFinishLevel: %d, %d", mode, flags); 
		Inventory item, next;
		let p = player;

		if (p.morphTics != 0)
		{ // Undo morph
			Unmorph(self, 0, true);
		}
		// 'self' will be no longer valid from here on in case of an unmorph
		let me = p.mo;

		// Strip all current powers, unless moving in a hub and the power is okay to keep.
		item = me.Inv;
		while (item != NULL)
		{
			next = item.Inv;
			if (item is 'Powerup')
			{
				if (deathmatch || ((mode != FINISH_SameHub || !item.bHUBPOWER) && !item.bPERSISTENTPOWER)) // Keep persistent powers in non-deathmatch games
				{
					item.Destroy ();
				}
			}
			item = next;
		}
		let ReadyWeapon = p.ReadyWeapon;
		if (ReadyWeapon != NULL && ReadyWeapon.bPOWERED_UP && p.PendingWeapon == ReadyWeapon.SisterWeapon)
		{
			// Unselect powered up weapons if the unpowered counterpart is pending
			p.ReadyWeapon = p.PendingWeapon;
		}
		// reset invisibility to default
		me.RestoreRenderStyle();
		p.extralight = 0;					// cancel gun flashes
		p.fixedcolormap = PlayerInfo.NOFIXEDCOLORMAP;	// cancel ir goggles
		p.fixedlightlevel = -1;
		p.damagecount = 0; 				// no palette changes
		p.bonuscount = 0;
		p.poisoncount = 0;
		p.inventorytics = 0;

		if (mode != FINISH_SameHub)
		{
			// Take away flight and keys (and anything else with IF_INTERHUBSTRIP set)
			item = me.Inv;
			while (item != NULL)
			{
				next = item.Inv;
				if (item.InterHubAmount < 1)
				{
					item.DepleteOrDestroy ();
				}
				item = next;
			}
		}

		if (mode == FINISH_NoHub && !level.KEEPFULLINVENTORY)
		{ // Reduce all owned (visible) inventory to defined maximum interhub amount
			Array<Inventory> todelete;
			for (item = me.Inv; item != NULL; item = item.Inv)
			{
				// If the player is carrying more samples of an item than allowed, reduce amount accordingly
				if (item.bINVBAR && item.Amount > item.InterHubAmount)
				{
					item.Amount = item.InterHubAmount;
					if (level.REMOVEITEMS && !item.bUNDROPPABLE && !item.bUNCLEARABLE)
					{
						todelete.Push(item);
					}
				}
			}
			for (int i = 0; i < toDelete.Size(); i++)
			{
				let it = toDelete[i];
				if (!it.bDestroyed)
				{
					item.DepleteOrDestroy();
				}
			}
		}

		let lmp = Wads.FindLump("ARBITER.acs");
		Console.Printf("lmp: %d", lmp);
		// Resets player health to default if not dead.
		if ((flags & CHANGELEVEL_RESETHEALTH) && p.playerstate != PST_DEAD)
		{
			if (lmp == -1)
			{
				p.health = me.health = me.SpawnHealth();
			}
		}

		// Clears the entire inventory and gives back the defaults for starting a game
		if ((flags & CHANGELEVEL_RESETINVENTORY) && p.playerstate != PST_DEAD)
		{
			if (lmp == -1)
			{
				me.ClearInventory();
				me.GiveDefaultInventory();
			}
		}

		// [MK] notify self and inventory that we're about to travel
		// this must be called here so these functions can still have a
		// chance to alter the world before a snapshot is done in hubs
		me.PreTravelled();
		for (item = me.Inv; item != NULL; item = item.Inv)
		{
			item.PreTravelled();
		}
	}

	override void BeginPlay()
	{
		basexscale = scale.x;
		baseyscale = scale.y;
		scalexmulti = 1.00;
		scaleymulti = 1.00;

		// Player is always considered a Voodoo Doll during BeginPlay, so height/radius have to be saved before the initial change and then reverted back to it for PostBeginPlay/etc when proper doll detection actually works >____>;
		// Also 'isvoodoodoll' CAN'T be set right now, has to be done in PostBeginPlay/Tick as well <____<;
		originalheight = height;
		originalradius = radius;
		originalmass = mass;

		A_SetSize(16,56,false);
		scale.x = 1.0;
		scale.y = 1.0;
		Mass = 100;
		vel.x = vel.y = vel.z = 0;
		if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [BeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);

		Super.BeginPlay(); 
	}

	override void PostBeginPlay()
	{
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)
		{
			A_SetSize(16,56,false);
			scale.x = 1.0;
			scale.y = 1.0;
			Mass = 100;
			isvoodoodoll = true;
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			Super.PostBeginPlay(); 
			return;
		}
		else
		{
			A_SetSize(originalradius,originalheight,false);
			Mass = originalmass;
			scale.x = basexscale;
			scale.y = baseyscale;
			if (dydudebug_showvoodoodoll) Console.Printf("Player [PostBeginPlay] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
		}

		if (bNOBLOOD == 1) 
		{
			if (bNOBLOODDECALS == 0) bNOBLOODDECALS == 1;
			neverbleeds = 1;
		}
		if (bNOBLOODDECALS == 1) 
		{
			if (bNOBLOOD == 0) bNOBLOOD == 1;
			neverbleeds = 1;
		}
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}

	override void CheckAirSupply()
	{
		if (!player || !player.mo || player.mo != self)
		{
			super.CheckAirSupply();
		}
		else
		{
			int DrownDmg = 2 + ((level.maptime - player.air_finished) / TICRATE);
			DrownDmg = ceil(DrownDmg * frandompick(0.625,0.75,0.875,1.000));
			DrownDmg = clamp(DrownDmg, 0, DrownDmg);
			// Handle air supply	
			//if (level.airsupply > 0)
			{
				let player = self.player;
				if (waterlevel < 3 || (bInvulnerable) || 
					(player.cheats & (CF_GODMODE | CF_NOCLIP2)) || (player.cheats & CF_GODMODE2) || 
					CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
				{
					ResetAirSupply();
				}
				else if (player.air_finished <= level.maptime && !(level.maptime & 31))
				{
					DamageMobj(NULL, NULL, DrownDmg, 'Drowning');
				}
			}
			int AirTime = max(player.air_finished - level.maptime, 0);
			if (dydudebug_airmeter) Console.Printf("    WaterLevel: %d, Level.Time: %d, Level.MapTime: %d, Player.AirFinished: %d, \cxAirTime: %d / %d\c- (%d), DrownDmg: %d", waterlevel, level.time, level.maptime, player.air_finished, AirTime, level.airsupply, AirCapacity, DrownDmg);
		}
	}
	
	override void MovePlayer()
	{
		if (!player || !player.mo || player.mo != self)
		{
		}
		else
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			String nm;
			int PlayerLevel;
			if (MiscItem) PlayerLevel = MiscItem.PlayerLevel;
			double AirControlBase = frandom(0.2432,0.2436);

			// Level Based AirControl
			double LVLAirControl = 1.00 + (PlayerLevel * 0.00125);

			// Armor items
			double ArmorAirControl = 1.00;
			if (CountInv("KnightGownItem"))			ArmorAirControl += 0.0667;
			if (CountInv("KnightGownItem2"))		ArmorAirControl += 0.10;
			if (CountInv("KnightGownItem3"))		ArmorAirControl += 0.1334;
			if (CountInv("KnightGownItem4"))		ArmorAirControl += 0.18;
			if (CountInv("PowerWineBuffWeak"))	ArmorAirControl *= frandom(0.98,1.00);
			if (CountInv("PowerWineBuffStrong"))	ArmorAirControl *= frandom(0.96,1.00);
			if (CountInv("PowerWineBuffStrongest"))	ArmorAirControl *= frandom(0.93,1.00);
			if (CountInv("PowerWineBuffStrongestEven"))	ArmorAirControl *= frandom(0.88,1.00);

			// Buffs
			double BuffAirControl = 1.00;
			if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) BuffAirControl *= 1.334;
			if (CountInv("PowerRoastBuff")) BuffAirControl *= 1.5;
			if (CountInv("PowerMealBuff")) BuffAirControl *= 2;
			if (CountInv("PowerMeal2Buff")) BuffAirControl *= 2;

			level.aircontrol = AirControlBase
											* LVLAirControl
											* ArmorAirControl
											* BuffAirControl;
			level.airfriction = level.aircontrol * -0.0941 + 1.0004;

			if (dydudebug_playermove)
			{
				Console.Printf("    \czSV_AirControl:\c- \cz%.8f\c-  \cwTotalAirControl:\c- \cw%.8f\c-, \cyAirControlBase:\c- \cy%.8f\c-, LVLAirControl: %.8f, ArmorAirControl: %.8f, BuffAirControl: %.8f", 
														sv_aircontrol, level.aircontrol, AirControlBase,
														LVLAirControl, ArmorAirControl, BuffAirControl);
				Console.Printf("    \cwTotalFriction:\c- \cw%.8f\c-, \cyLevelAirFriction:\c- \cy%.8f\c-", friction, level.airfriction);
			}
			//Console.Printf("Player.ForwardMove: (%.2f, %.2f), Player.SideMove: (%.2f, %.2f), Player.ViewBob: %.2f", ForwardMove1, ForwardMove2, SideMove1, SideMove2, ViewBob);
		}
		
		super.MovePlayer();
	}
	
	Override void Tick()
	{
		// VOODOO Doll Protection
		if ((!player || !player.mo || player.mo != self)) 
		{
			if (dydudebug_showvoodoodoll) Console.Printf("VoodooDoll [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			isvoodoodoll = true;
			Super.Tick();
			return;
		}
		else
		{
			buttons = GetPlayerInput(INPUT_BUTTONS);
			if (dydudebug_showvoodoodoll) Console.Printf("Player [Tick] - \c[gold]H: %d, R: %d, M: %d, \c[sapphire]Sx: %4f, Sy: %4f, \c[fire]PosX: %d, PosY: %d, PosZ: %d", height, radius, mass, scale.x, scale.y, pos.x, pos.y, pos.z);
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			let globalvars = DDGlobalVariables.Get();
			if (dydudebug_mapinfo)
			{
				Console.Printf("Player Age [tics]: %d, levelnum: \cx%d\c-, cluster: \cx%d\c-, clusterflags: \cx%d\c-, NextMap: \cy%s\c-, NextSecretMap: \cy%s\c-,\ntime: \cx%d\c-, maptime: \cx%d\c-, totaltime: \cx%d\c-, starttime: \cx%d\c-, partime: \cx%d\c-, sucktime: \cx%d\c-,\nlevelname: \cy%s\c-, mapname: \cy%s\c-, \ngravity: \cx%.8f\c-, aircontrol: \cx%.8f\c-, airfriction: \cx%.8f\c-, \cxTranslation #:\c- %d, \cyMapCheckSum:\cx %s", 
												GetAge(),
												level.levelnum, level.cluster, level.clusterflags, level.NextMap, level.NextSecretMap,
												level.time, level.maptime, level.totaltime, level.starttime, level.partime, level.sucktime,
												level.levelname, level.mapname,
												level.gravity, level.aircontrol, level.airfriction,
												translation, level.GetChecksum());
			}
			
			// Check IP Buttons [general check for quick editing later across all definitions]
			
			if (ipmodecooldowntimer) ipmodecooldowntimer--;
			int IPbuttonspressed = 0;
			if (buttons & BT_USE) IPbuttonspressed++;
			if (buttons & BT_ZOOM) IPbuttonspressed++;
			if (buttons & BT_SPEED) IPbuttonspressed++;
			if (exex_ikaripointsenabled)
			{
				if (exex_ikaripointtechpresstype == 0)
				{
					if (IPbuttonspressed >= 2) 
					{
						A_SetInventory("IPUseMode",1);
					}
					else
					{
						A_SetInventory("IPUseMode",0);
					}
				}
				else
				if (exex_ikaripointtechpresstype >= 1 && exex_ikaripointtechpresstype <= 2)
				{
					if (IPbuttonspressed >= 2) 
					{
						if (ipmodecooldowntimer <= 0)
						{
							ipmodecooldowntimer = random(9,12);
							if (CountInv("IPUseMode")) A_SetInventory("IPUseMode",0);
																		else A_SetInventory("IPUseMode",1);
						}
					}
				}
			}
			else
			{
				A_SetInventory("IPUseMode",0);
			}
			
			// The "Charge" sound[s] that plays in a loop while IP mode is active and the one that plays when it disperses [thanks to LilWhiteMouse for the sounds from Wolfen, wherever she herself had found them] :V
			double ipmodevol = 1.0;
			double basevollvl = 0.25;
			double ipmodepitch = 1.0;
			if (health > 0)
			{
				if (MiscItem && globalvars && MiscItem.MaxItemPoints)
				{
					ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
				}
				if (dydudebug_ipdisplays) Console.Printf("ipmodevol: %.4f, ipmodepitch: %.4f", ipmodevol, ipmodepitch);
				if (CountInv("IPUseMode"))
				{
					if (ipchargesoundtimer == 0)
					{
						if (MiscItem && globalvars)
						{
							ipmodevol = basevollvl + (double(MiscItem.ItemPoints / MiscItem.MaxItemPoints) * (1.0 - basevollvl));
						}
						A_StopSound(255);
						A_StartSound("ipmode/start",255,CHANF_NOSTOP,ipmodevol,ATTN_NORM,ipmodepitch);
					}
					ipchargesoundtimer++;
					if (ipchargesoundtimer >= 56)
					{
						int ipchargesoundtimer2 = ipchargesoundtimer % 56;
						if (ipchargesoundtimer2 == 0) 
						{
							A_StopSound(255);
							A_StartSound("ipmode/loop",255,CHANF_NOSTOP|CHANF_LOOPING,ipmodevol,ATTN_NORM,ipmodepitch);
						}
						if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer2: %d / 55", ipchargesoundtimer2);
					}
				}
				else
				{
					if (ipchargesoundtimer != 0)
					{
						ipchargesoundtimer = 0;
						A_StopSound(255);
						A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
					}
				}
			}
			else
			{
				if (ipchargesoundtimer != 0)
				{
					ipchargesoundtimer = 0;
					A_StopSound(255);
					A_StartSound("ipmode/disperse",255,CHANF_DEFAULT,ipmodevol,ATTN_NORM,ipmodepitch);
				}
				MiscItem.ItemPoints = 0;
				globalvars.ItemPoints = 0;
			}
			if (dydudebug_ipdisplays) Console.Printf("ipchargesoundtimer: %d", ipchargesoundtimer);
			
			double fademax = 1.00;
			if (health <= 0)
			{
				if (deadtimer <= 0) 
				{
					fadetime = int(TICRATE*frandom(2.1667,2.8334));
					A_SetBlend("00 00 00",0.00, fadetime, "00 00 00",fademax);
				}
				if (deadtimer > (fadetime-2)) A_SetInventory("BlackScreenHUD",1);
				deadtimer++;
				//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
			}
			else 
			{
				if (deadtimer > 0) 
				{
					fadetime *= 0.25;
					A_SetBlend("00 00 00",fademax, fadetime, "00 00 00",0.00);
					A_SetInventory("BlackScreenHUD",0);
					//Console.Printf("DeadTimer: %d, FadeTime: %d", deadtimer, fadetime);
				}
				deadtimer = 0;
			}

			int armortier = 0;
			double savepercent = 0.000000;

			let armoritem = BasicArmor(player.mo.FindInventory("BasicArmor"));
			if (armoritem != null && CountInv("BasicArmor") > 0)
			{
				savepercent = armoritem.savepercent;
				if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
				if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
				if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
				if (savepercent >= 0.87500 && savepercent <= 0.99999) armortier = 3;
				if (savepercent >= 1.00000) armortier = 4;
				
				if (dydudebug_playertick) Console.Printf("Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
			}
			
			if (armortier == 1) A_SetInventory("KnightGownItem",1); else A_SetInventory("KnightGownItem",0);
			if (armortier == 2) A_SetInventory("KnightGownItem2",1); else A_SetInventory("KnightGownItem2",0);
			if (armortier == 3) A_SetInventory("KnightGownItem3",1); else A_SetInventory("KnightGownItem3",0);
			if (armortier == 4) A_SetInventory("KnightGownItem4",1); else A_SetInventory("KnightGownItem4",0);
			
			if (MiscItem) MiscItem.GetSpeedFactor();
		}

		// Recall All
		if (recalledall)
		{
			if (dydudebug_recalldisplays) Console.Printf("Recall All Attempt");

			actor recalleetarg;
			recalleetarg = actor(AimTarget());

			int numberrecalled = 0;
			ActorIterator it = Level.CreateActorIterator(1000);
			Actor recallee;
			while (recallee = it.Next())
			{
				if (recallee.bISMONSTER && recallee.bFRIENDLY)
				{
					if (dydudebug_recalldisplays) Console.Printf("\cx(Recall All)\c- Name: %s (TID: %d)", recallee.GetClassName(), recallee.tid);
					Vector3 savedpos = (pos.x, pos.y, (pos.z + random(6.0,12.0)));
					recallee.SetOrigin(savedpos,false);
					recallee.angle += frandom(0.0,360.0);
					recallee.vel.x += frandom(-4.0,4.0);
					recallee.vel.y += frandom(-4.0,4.0);
					recallee.vel.z += frandom(4.0,8.0);
					numberrecalled++;
					if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) recallee.target = recalleetarg;
				}
			}
			
			if (numberrecalled > 0)
			{
				//A_StartSound("monstersummon", 161, CHANF_DEFAULT);
				A_SpawnItemEx("PlayerWhistle",0.0,0.0,32.0,0.0,0.0,0.0,0.0,SXF_NOCHECKPOSITION);
				Vector3 savedpos2 = (pos.x, pos.y, pos.z+(height*0.25));
				Actor fog = Spawn("TeleportFog", savedpos2, ALLOW_REPLACE); 
				if (fog != null)
				{
					fog.scale.x *= frandom(0.375, 0.625);
					fog.scale.y *= frandom(0.375, 0.625);
					fog.A_SetRenderStyle(frandom(0.375, 0.625),STYLE_Add);
				}
				
				if (recalleetarg && recalleetarg.bISMONSTER && !recalleetarg.bFRIENDLY) A_PrintBold(String.Format("\cfRecalled all allies to your location and gave them a new target!"), frandom(0.685,0.8));
				else A_PrintBold(String.Format("\cfRecalled all allies to your location!"), frandom(0.685,0.8));
			}
			else
			{
				A_StartSound("inv_fail",84,CHANF_DEFAULT,1.0,ATTN_NORM);
				A_PrintBold(String.Format("\cgRecall Failed: No creatures available to recall!"), frandom(0.685,0.8));
			}

			recalledall = false;
		}
		
		//****************************************************
		//*Flicker the Player when they survive a mortal hit *
		//****************************************************
		if (self.health == 1 && (player.cheats & CF_BUDDHA || player.cheats & CF_BUDDHA2) && lasthealth > 1)
		{
			let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				MiscItem.MercyInvulnOn = true;
				MiscItem.MercyInvulnTimer = 1210; // 1.5 Seconds
				
				player.health = player.mo.health = 1;
			}
		}

		lasthealth = health;
		
		Super.Tick();
	}

	override void CheckJump()
	{
		let player = self.player;
		// [RH] check for jump
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && player.onground && player.jumpTics == 0)
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z += jumpvelz;
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
			}
		}
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDPlayPawn, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}

	void A_CheckNeverBleed(int type, int damage, int flags)
	{
		if (type == 0)
		{
			if (neverbleeds == 0)
			{
				if (bNOBLOOD) bNOBLOOD = 0;
				if (bNOBLOODDECALS) bNOBLOODDECALS = 1;
			}
		}
		else
		{
			//Console.Printf("(A_CheckNeverBleed [player], damage: %d)", damage);
			if (flags & !DMG_EXPLOSION)
			{
				if (neverbleeds == 0)
				{
					bNOBLOOD = 1;
					bNOBLOODDECALS = 1;
				}
			}
		}
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		int firstdmg = damage;
		let MiscItem = PlayerStatItem(FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();

		int PlayerLevel;
		if (MiscItem) PlayerLevel = MiscItem.PlayerLevel;
		
		Actor AttackingActor;
		Actor UniqueProjectile;
		FastProjectile UniqueProjectileFast;
		Actor ailmentproj;
		FastProjectile ailmentprojfast;
		Actor singleripproj;
		FastProjectile singlefastripproj;
		
		if (dydudebug_playerdamagemobj)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
			if (flags & DMG_NO_PAIN) Console.Printf("    (\cyPainless?: yes)");
		}
		if (dydudebug_playerdamagemobj) Console.Printf("DamageType: %s", mod);
		
		if (source) AttackingActor = Actor(source);
		if (inflictor) 
		{
			UniqueProjectile = Actor(inflictor);
			UniqueProjectileFast = FastProjectile(inflictor);
			ailmentproj = Actor(inflictor);
			ailmentprojfast = FastProjectile(inflictor);
			singleripproj = Actor(inflictor);
			singlefastripproj = FastProjectile(inflictor);
		}
		
		int oldhealthratio;
		int oldhealth = health;
		if (CountInv("NormalHealth")) oldhealthratio = 0;
		if (CountInv("DecentHealth")) oldhealthratio = 1;
		if (CountInv("LowHealth")) oldhealthratio = 2;
		if (CountInv("CriticalHealth")) oldhealthratio = 3;

		
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		int olddmg;
		int armortier = 0;
		double savepercent = 0.000000;
		
		int flatdefense;
		bool useflatdefense;
		let armoritem = BasicArmor(player.mo.FindInventory("BasicArmor"));
		if (armoritem != null && CountInv("BasicArmor") > 0)
		{
			savepercent = armoritem.savepercent;
			if (savepercent >= 0.00000 && savepercent <= 0.49999) armortier = 0;
			if (savepercent >= 0.50000 && savepercent <= 0.74999) armortier = 1;
			if (savepercent >= 0.75000 && savepercent <= 0.87499) armortier = 2;
			if (savepercent >= 0.87500 && savepercent <= 0.99999) armortier = 3;
			if (savepercent >= 1.00000) armortier = 4;
			
			if (dydudebug_playerdamagemobj) Console.Printf("Armor SavePercent: %.8f, Tier: %d", savepercent, armortier);
		}
		
		bool SigilDrain;
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1] - Base: %d", damage);
		if (mod == 'Sigil' && source == null && inflictor == self && flags & DMG_NO_ARMOR)
		{
			flags |= DMG_NO_FACTOR;
			flags |= DMG_NO_PROTECT;
			flags |= DMG_NO_ENHANCE;
			flags |= DMG_THRUSTLESS;
			flags |= DMG_NO_PAIN;
			SigilDrain = true;
			if (dydudebug_playerdamagemobj) Console.Printf("SigilDrain"); 
		}
		
		if (mod != 'Slime' || 
				mod != 'Magma' || 
				mod != 'Crush' || 
				mod != 'Falling' || 
				mod != 'Poison' || 
				mod != 'PoisonCloud' || 
				mod != 'Magic' || 
				mod != 'Eldritch' || 
				mod != 'Sigil' || 
				mod != 'SpectralLow')
		{
			if (mod == 'Beats' && flags & DMG_EXPLOSION && AttackingActor == self)
			{
				flags |= DMG_NO_ARMOR;
				flags |= DMG_THRUSTLESS;
				damage = ceil(damage * frandompick(1.0,1.0,1.0,1.125,1.125));
				if (dydudebug_playerdamagemobj) Console.Printf("Grimophone Alt-Fire (%d)", damage);
				if (damage >= health) return 0;
			}
			else
			{
				if (SigilDrain) { }
				else damage = ceil(damage * 1.125);
			}
			if (SigilDrain) { }
			else if (CountInv("DoingSpinAttack")) damage *= 0.25;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Step 1b]: %d", damage);
		}
		else
		if (mod == 'Magic' || 
				mod == 'Poison' || 
				mod == 'PoisonCloud' || 
				mod == 'Eldritch' || 
				mod == 'Sigil' ||
				mod == 'SpectralLow')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * 0.875);
			if (SigilDrain) { }
			else if (CountInv("DoingSpinAttack")) damage *= 0.25;
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (non-normal base) [Step 1b]: %d", damage);
		}
		else
		if (mod == 'Slime' || 
				mod == 'Magma' ||
				mod == 'Crush' || 
				mod == 'Falling')
		{
			if (SigilDrain) { }
			else damage = ceil(damage * frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.125,1.125,1.25));
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage (misc base) [Step 1b]: %d", damage);
		}
		
		// VOODOO Doll Protection
		if (!player || !player.mo || player.mo != self)  
		{
			if (dydudebug_playerdamagemobj) Console.Printf("\cyIS A VOODOO DOLL\c-)", damage);
			//*********************************************************************
			return super.DamageMobj(inflictor, source, damage, mod, flags, angle); 
			//*********************************************************************
		}

		// Direct Damage Changes
		if (flags & DMG_INFLICTOR_IS_PUFF)
		{
			if (AttackingActor != self)
			{
				if (BulletPuff(self))
				{
					olddmg = damage;
					if (dydudebug_playerdamagemobj) Console.Printf("Hit by Doom Bullet");
					if (armortier == 0) damage = ceil(damage * 0.9375);
					if (armortier == 1) damage = ceil(damage * 0.875);
					if (armortier == 2) damage = ceil(damage * 0.75);
					if (armortier == 3) damage = ceil(damage * 0.625);
					if (armortier == 4) damage = ceil(damage * 0.5);
					if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.667,0.75,0.75,0.75,0.75,0.75,0.834));
					if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.667,0.75,0.75,0.75,0.75,0.75,0.834) * 0.25));
					if (CountInv("DoingSpinAttack")) damage *= 0.25; // Cricket Bat Spin Attack almost entirely negates bullet damage

					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Bullet Buff]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		olddmg = damage;
		if (flags & DMG_EXPLOSION)
		{
			if (AttackingActor == self)
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Own AOE");
				
				if (mod == 'Beats')
				{
				}
				else
				{
					damage = ceil(damage * (0.25 - (MiscItem.PlayerLevel * 0.01)));
					if (MiscItem.PlayerLevel <= 50 && damage < 1) damage = 1;
					if (armortier == 1) damage = ceil(damage * 0.975);
					if (armortier == 2) damage = ceil(damage * 0.9625);
					if (armortier == 3) damage = ceil(damage * 0.95);
					if (armortier == 4) damage = ceil(damage * 0.925);
					useflatdefense = false;
				}
			}
			else
			{
				if (dydudebug_playerdamagemobj) Console.Printf("Damage Is Not Own AOE");
		
				if (AttackingActor != null)
				{
					if (sour == "Cyberdemon") damage = ceil(damage * frandompick(0.875,0.9375,0.9375,0.9375,0.9375,0.9375,1.00));
					else if (sour == "Archvile" || sour == "ArchvileNew") damage = ceil(damage * frandompick(0.5,0.625,0.625,0.625,0.625,0.625,0.75));
					else damage = ceil(damage * frandompick(0.75,0.875,0.875,0.875,0.875,0.875,1.00));
				}
				else
				{
					damage = ceil(damage * frandompick(0.75,0.875,0.875,0.875,0.875,0.875,1.00));
				}
				useflatdefense = true;
			}
			if (CountInv("CricketBatGuard")) damage = ceil(damage * frandompick(0.334,0.5,0.5,0.5,0.5,0.5,0.667));
			if (CountInv("CricketBatGuard2")) damage = ceil(damage * (frandompick(0.334,0.5,0.5,0.5,0.5,0.5,0.667) * 0.25));
			if (CountInv("DoingSpinAttack")) damage *= 0.05; // Cricket Bat Spin Attack almost entirely negates AOE damage

			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [AOE]: %d (%d)", damage, olddmg);
		}
		
		olddmg = damage;
		if (source != null)
		{
			if (Crusader(source))
			{
				if (flags & DMG_EXPLOSION) // The Crusader's death AOE does very little damage to Dinah (37.5% and dropping)
				{
					damage *= (frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
					if (armortier == 1) damage *= 0.90;
					if (armortier == 2) damage *= 0.80;
					if (armortier == 3) damage *= 0.60;
					if (armortier == 4) damage *= 0.20;
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderAOE]: %d (%d)", damage, olddmg);
				}
				if (inflictor != null)
				{
					if (CrusaderMissile(inflictor) || FastFlameMissile(inflictor)) // The Crusader's attacks are very wanting against Dinah overall (37.5% and dropping)
					{
						damage *= (frandompick(0.375,0.375,0.375,0.5,0.5,0.625,0.625,0.75,0.75,0.75) - 0.375);
						if (armortier == 1) damage *= 0.90;
						if (armortier == 2) damage *= 0.80;
						if (armortier == 3) damage *= 0.60;
						if (armortier == 4) damage *= 0.20;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [CrusaderProj]: %d (%d)", damage, olddmg);
					}
				}
			}
			
			if (Revenant(source))
			{
				if (inflictor != null)
				{
					if (RevenantTracer(inflictor))
					{
						damage *= (frandompick(0.5,0.5,0.625,0.625,0.75,0.75,0.75,0.875,0.875) - 0.125);
						if (armortier == 1) damage *= 0.95;
						if (armortier == 2) damage *= 0.90;
						if (armortier == 3) damage *= 0.80;
						if (armortier == 4) damage *= 0.60;
						if (dydudebug_playerdamagemobj) Console.Printf("PDamage [RevMissile]: %d (%d)", damage, olddmg);
					}
				}
			}
		}
		
		// Check FRIGHTENED/FRIENDLY flags
		if (damage > 0)
		{
			if (AttackingActor)
			{
				if (AttackingActor != self)
				{
					if (AttackingActor.bFRIENDLY)
					{
						damage = 0;
						if (dydudebug_playerdamagemobj) Console.Printf("END DAMAGE ATTEMPT (FRIENDLY)");
						return 0;
					}
					else
					{
						if (AttackingActor.CountInv("ScramblerConfusion")) // If the attacker is under the effect of the Confusion debuff from the Scrambler
						{
							damage = ceil(damage * frandompick(0,0,0.125,0.25,0.375,0.5,0.625,0.75,0.875,1.0));
							if (damage == 0) return 0;
						}
						else
						{
							if (AttackingActor.bFRIGHTENED) // Attacker is frightened, AND the Player is the one that is doing the frightening
							{
								if (player.cheats & CF_FRIGHTENING || bFRIGHTENING) damage = ceil(damage * frandompick(0.625,0.6875,0.75)); else damage = ceil(damage * frandompick(0.9375,0.95,0.9625));
							}
						}
					}
					if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Friendly/Frighten Check]: %d (%d)", damage, olddmg);
				}
			}
		}
		
		// Armor Checks
		if (armortier)
		{
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Drowning' || mod == 'Falling'))
			{
				olddmg = damage;
				if (mod == 'Crush')
				{
					if (useflatdefense)
					{
						if (armortier == 1) damage -= randompick(0,0,0,0,1);
						if (armortier == 2) damage -= randompick(0,0,0,1,1);
						if (armortier == 3) damage -= randompick(0,0,1,1,2);
						if (armortier >= 4) damage -= randompick(1,1,2,2,3);
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,32) > 1) damage = 1;
						if (armortier == 3 && random(1,32) > 2) damage = 1;
						if (armortier >= 4 && random(1,32) > 4) damage = 1;
					}
				}
				else
				{
					if (useflatdefense)
					{
						if (armortier == 1) damage -= (random(0,1) + (PlayerLevel * 0.025));
						if (armortier == 2) damage -= (random(1,2) + (PlayerLevel * 0.050));
						if (armortier == 3) damage -= (random(2,3) + (PlayerLevel * 0.075));
						if (armortier >= 4) damage -= (random(4,5) + (PlayerLevel * 0.125));
					}
					if (damage <= 0)
					{
						if (armortier == 1) damage = 1;
						if (armortier == 2 && random(1,8) > 1) damage = 1;
						if (armortier == 3 && random(1,8) > 2) damage = 1;
						if (armortier >= 4 && random(1,8) > 4) damage = 1;
					}
				}
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Raw Armor Def]: %d", damage, olddmg);
			}
			else
			{
				if (useflatdefense)
				{
					if (armortier == 1) damage -= randompick(0,0,0,0,0,0,0,0,0,0,0,0,1);
					if (armortier == 2) damage -= randompick(0,0,0,0,0,0,0,0,0,0,0,1,1);
					if (armortier == 3) damage -= randompick(0,0,0,0,0,0,0,0,0,0,1,1,2);
					if (armortier >= 4) damage -= randompick(0,0,0,0,0,0,0,0,1,1,2,2,3);
				}
			}
		}
		
		// Berserk Effects
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD") && !SigilDrain)
		{
			olddmg = damage;
			if (mod == 'Falling') damage = ceil(damage * frandom(0.625,0.75));
			if (mod == 'Crush') damage = ceil(damage * frandom(0.75,0.875));
			if (mod == 'Drowning') damage = ceil(damage * frandom(0.875,1.000));
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Berserk Effects]: %d", damage, olddmg);
		}
		
		if (CountInv("PlayerDashing") && !SigilDrain)
		{
			if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Dashing Avoids Damage]");
			return 0;
		}

		if (CountInv("PowerTimeFreezer") || 
				CountInv("DDMiscTimeFreezer") || 
				(CountInv("DebugTimeFreezer") && dydudebug_timeslowinterval > 1) || 
				CountInv("TimePotionTimeFreezer") || 
				CountInv("DashTimeFreezer"))
		{
			if (mod == 'Slime' || mod == 'Magma')
			{
				if (dydudebug_playerdamagemobj) Console.Printf("PDamage [TimeFreeze on Slime abort]");
				return 0;
			}
		}
		
		bool isinvuln = false;
		// If Invulnerable
		{
			if (bINVULNERABLE || player.cheats & CF_GODMODE2 || player.cheats & CF_GODMODE || CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
			{ 
				if (SigilDrain) damage = 0;
				A_StartSound("Player/TookNoDamageInvuln",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				isinvuln = true;
			}
		}

		int armoramt = CountInv("BasicArmor");
		if (dydudebug_playerdamagemobj) Console.Printf("PDamage [Final] - Final Damage: %d", damage);
		
		string combatlogmsg = "\c[sapphire]*\c- ";
		if (dydudebug_playerdamagemobj && armoramt) Console.Printf("Armor Amount: %d", armoramt);
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		int armdmg = (armoramt - CountInv("BasicArmor"));
		if (armdmg <= 0) armdmg = 0;
		if (dydudebug_playerdamagemobj && armdmg) Console.Printf("Armor Damage: %d", armdmg);
		if (armdmg && exex_armordmgsounds)
		{
			A_StopSound(213);
			if (CountInv("BasicArmor")) A_StartSound("armordamaged",213,CHANF_DEFAULT,1.0,ATTN_NORM);
														 else A_StartSound("armorbroken",213,CHANF_DEFAULT,1.0,ATTN_NORM);
		}
		if (exex_playerdmglog)
		{
			if (mod == 'NONE') mod = 'Typeless';
			if (ret || armdmg)
			{
				if (armdmg && !ret) combatlogmsg.AppendFormat("\c[darkgreen]%d AP\c- ", armdmg);
				else if (armdmg && ret) combatlogmsg.AppendFormat("\c[darkred]%d HP\c- & \c[darkgreen]%d AP\c- ", ret, armdmg);
				else combatlogmsg.AppendFormat("\c[darkred]%d HP\c- ", ret);
				if (dydudebug_dmgdiffdebug)
				{
					if (firstdmg > ret) combatlogmsg.AppendFormat("[\c[lightblue]%d\c-] ", (ret - firstdmg));
					else if (firstdmg < ret) combatlogmsg.AppendFormat("[\c[brick]+%d\c-] ", (ret - firstdmg));
				}
				combatlogmsg.AppendFormat("of damage taken ");
			}
			else
			{
				if (isinvuln) 
				{
					combatlogmsg.AppendFormat("\c[green]Invulnerable!\c- No Damage taken \c-");
				}
				else
				{
					combatlogmsg.AppendFormat("\c[white]No Damage taken \c-");
				}
			}
			if (source) // Has a source
			{
				combatlogmsg.AppendFormat("from \c[purple]%s\c-", source.GetTag());
				if (inflictor && inflictor != source) combatlogmsg.AppendFormat("\c[purple]'s\c- \c[brick]%s\c-", inflictor.GetTag());
			}
			else
			if (inflictor) // No source, but has an inflictor
			{
				combatlogmsg.AppendFormat(" from %s", inflictor.GetTag());
			}
			combatlogmsg.AppendFormat("!");
			combatlogmsg.AppendFormat(" [%s]", mod);
			if (flags & DMG_EXPLOSION) combatlogmsg.AppendFormat(" \c[brick][AOE]\c-", mod);
			if (dydudebug_showgametic) combatlogmsg.AppendFormat(" \c[green][tic: %d]\c-", gametic);
			Console.Printf(combatlogmsg);
		}

		// Item/Ikari Point Gains
		if (exex_ikaripointsenabled && ret && MiscItem && globalvars && health > 0)
		{
			int gain = 0;
			if ((source && source != self) && (inflictor && inflictor != self)) gain += 1;
			if (!(mod == 'Slime' || mod == 'Lava' || mod == 'Drowning' || mod == 'Falling' || mod == 'Crush')) gain += 1;
			if (gain)
			{
				double base;
				// The mod's first and original formula
				if (exex_ikaripointscalctype <= 0)
				{
					base = ret * 100.0 / MiscItem.MaxHealthTrue;
					if (oldhealthratio == 0) base *= 1.0;
					if (oldhealthratio == 1) base *= 1.125;
					if (oldhealthratio == 2) base *= 1.25;
					if (oldhealthratio == 3) base *= 1.5;
					if (oldhealthratio == 4) base *= 2.25;
					if (oldhealth > 1 && health == 1) base *= 3.25;
					base *= (0.125 + (MiscItem.PlayerLevel * 0.00125) + (MiscItem.PlayerLUCK * frandompick(0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.0005,0.001,0.001,0.001,0.001,0.001,0.001,0.002,0.002,0.002,0.002,0.003,0.003)));
				}
				// The more Lufia II equse formula
				if (exex_ikaripointscalctype >= 0)
				{
					base = ret * 100.0 / oldhealth; // % of remaining HP removed
					if (base >= 0.001)
					{
						if (base >= 0.001 && base <= 50.000) base *= 0.50; // <= 50% equals half of the percent in IP points given [up to 25%]
						if (base >= 50.001 && base <= 65.000) base *= 0.558077; 
						if (base >= 65.001 && base <= 75.000) base *= 0.646154;
						if (base >= 75.001 && base <= 85.000) base *= 0.76; 
						if (base >= 85.001 && base <= 90.000) base *= 0.90; 
						if (base >= 90.001 && base <= 100.000) base *= 1.00; 
						if (base >= 100.001) base *= 1.25;
						if (oldhealth > 1 && health == 1) base += MiscItem.MaxItemPoints;
					}
				}
				double basef = base;
				int IPTimerBaseInc = -35;
				if (SigilDrain)
				{
					base *= (1.0 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
					basef *= (0.334 / frandompick(1.5,1.75,1.75,2,2,2,2.25,2.25,2.5));
				}
				if (base <= 0.01) base = 0.01;
				if (basef <= 0.01) basef = 0.01;
				if (base)
				{
					if (MiscItem.IPTimer1 > 0) MiscItem.IPTimer1 = (IPTimerBaseInc * basef);
																else MiscItem.IPTimer1 += (IPTimerBaseInc * basef);
					MiscItem.ItemPoints += base;
					globalvars.ItemPoints += base;
					if (exex_playerdmglog) Console.Printf("\c[red]+%.2f%% IP Gained!", base);
				}
			}
		}
		return ret;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (!player || !player.mo || player.mo != self)
		{
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PPawnVoodoo] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return true;
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PPawnVoodoo] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}
		else
		{
			// Non-passive means the one moving into the other is performing the checks.
			if (!passive)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) [PlayerPawn] {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [PlayerPawn] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic);
					return false;
				}
			}
			else
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) [PlayerPawn] vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic); 
				return true;
			}
		}

		// We don't really care about others making the check.
		return true;
	}
	
	void A_APPPain()
	{
		if (GetClassName() == "DinahPlayer")
		{
			double MaxHealthTrue = CountInv("PlayerMaxHP");
			if ((!player || !player.mo || player.mo != self) || !MaxHealthTrue) MaxHealthTrue = SpawnHealth();
			double HealthRatio = health / MaxHealthTrue;
			// Console.Printf("%.8f", HealthRatio);
			if (health > 0)
			{
				if (HealthRatio >= 0.667) A_StartSound("Dinah/Pain1",CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
				else if (HealthRatio >= 0.334 && HealthRatio < 0.667) A_StartSound("Dinah/Pain2",CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
				else if (HealthRatio < 0.334) A_StartSound("Dinah/Pain3",CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
			}
		}
	}
}

class DinahPlayer : DDPlayerPawn // HereticPlayer
{
	default
	{
		Player.DisplayName "Dinah Wyck";
		Player.SoundClass "DinahPlayer";
		Player.StartItem "PlayerStatItem";
		//Player.StartItem "DynamicMusic";
		Player.StartItem "PlayerDashJump";
		Player.StartItem "CricketBat";
		Player.StartItem "HandToHand";
		Player.StartItem "MalletAmmo", 10;
		Player.Weaponslot 1, "HandToHand";
		Player.Weaponslot 2, "CricketBat";
		Player.Weaponslot 3, "Blundaxe", "Scrambler";
		Player.Weaponslot 4, "AppleJack";
		Player.Weaponslot 5, "WizardPike";
		Player.Weaponslot 6, "SuperVac";
		Player.Weaponslot 7, "Grimophone";
		Player.WeaponSlot 8, "SigilDD", "CandleWhip";
		Player.WeaponSlot 9, "CrazyBallDD";
		Player.ForwardMove 0.75, 0.75; // 0.75
		Player.SideMove 0.65, 0.65; // 0.65
		Player.ViewBob 0.5;
		Player.AttackZOffset 8;
		Player.AirCapacity 1;
		Player.JumpZ 9;
		//Player.GruntSpeed 12;
		Player.ViewHeight 36;
		Player.InvulnerabilityMode "Reflective";
		Species "Players";
		Health 80; // 100
		Player.MaxHealth 80;
		Player.MugShotMaxHealth -1; // 100
		Scale 0.8572;
		Mass 60;
		Height 48; // Slightly Shorter than Flora in Aetherius
		Radius 12; // Dinah is actually SLIGHTLY thinner than even Flora is in Aetherius
		Tag "Dinah Wyck";
		+NOBLOOD
		+PLAYERPAWN.NOTHRUSTWHENINVUL
	}

	/*
	override void Tick()
	{
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
	*/

	States
	{
		Spawn:
			DINA A -1;
			Loop;
		See:
			DINA BCDE 4;
			Loop;
		Pain:
			DINA H 6 A_APPPain();
			Goto Spawn;
		Missile:
			DINA FG 6;
			Goto Spawn;
		Melee:
			DINA FG 6;
			Goto Spawn;
		Death:
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		XDeath:
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		Burn:
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinDeath:
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
		AltSkinXDeath:
			DINA H 9 A_PlayerScream;
			DINA I 9 A_NoBlocking;
			DINA JK 9;
			DINA K -1;
			Stop;
  }
}

class RavenPlayer : DDPlayerPawn
{
	default
	{
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 16;
		Height 32;
		Speed 0.5;
		+NoSkin
		-PickUp
		+NoTarget
		Player.Viewheight 32;
		Player.DisplayName "Raven";
		Player.MorphWeapon "RavenWeapon";
	}
	States
	{
		Spawn:
			RVPL A 0;
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		See:
			RVPL ABCD 5 A_GiveInventory("RavenPowerups", 1);
			Loop;
		Pain:
			RVPL C 4 A_Pain;
			Goto Spawn;
		Death:
			TNT1 A -1;
			Stop;
	}
}

class RatPlayer : DDPlayerPawn
{
	default
	{
		Health 30;
		ReactionTime 0;
		PainChance 255;
		Radius 10;
		Height 20;
		Speed 1;
		+NOSKIN
		-PICKUP
		PainSound "Rat/Pain";
		DeathSound "Rat/Death";
		Player.JumpZ 3;
		Player.Viewheight 18;
		Player.ForwardMove 0.75, 0.75;
		Player.SideMove 0.65, 0.65;
		Player.SpawnClass "Rat";
		Player.SoundClass "Rat";
		Player.DisplayName "Rat";
		Player.MorphWeapon "RatNose";
	}
	
	States
	{
		Spawn:
			RATS A 0 A_StopSound(5);
			RATS A -1;
			Stop;
		See:
			RATS ABC 3;
			Loop;
		Melee:
		Missile:
			RATS B 8;
			RATS A 8;
			Goto Spawn;
		Pain:
			RATS C 4 A_Pain();
			Goto Spawn;
		Death:
			RATS D 6 A_Scream();
			RATS E 6 A_NoBlocking();
			RATS F 6;
			TNT1 A 1 A_CheckPlayerDone();
			Wait;
	}
}
