// The Almighty Sigil from Strife! :V ------------------------------------------------------

class SigilPickup : CustomInventoryExt 
{
	bool PlayerHasSigil;
	int SigilPiecesFound;
	actor plysigl;
	default
	{
		Scale 0.5;
		Tag "$TAG_SIGIL"; // "SIGIL"
		Inventory.Icon "I_SGL1";
		Inventory.PickupMessage "";
		Inventory.PickupSound "weapons/sigilcharge";
		CustomInventoryExt.PickUpVoice false;
		+DONTGIB;
		+FLOORCLIP;
		+FLOATBOB;
	}
	
	override void Tick()
	{
		PlayerHasSigil = false;
		plysigl = players[0].mo.FindInventory("SigilDD");
		if (plysigl) 
		{
			PlayerHasSigil = true;
			SigilPiecesFound = plysigl.health;
		}
		super.Tick();
	}
	
	States
	{
		Spawn:
			SIGL B 0 NoDelay;
			SIGL B 1
			{
				if (invoker.SigilPiecesFound == 5) { Thing_Remove(0); }
				else if (invoker.SigilPiecesFound == 4) { return resolvestate("Piece5"); }
				else if (invoker.SigilPiecesFound == 3) { return resolvestate("Piece4"); }
				else if (invoker.SigilPiecesFound == 2) { return resolvestate("Piece3"); }
				else if (invoker.SigilPiecesFound == 1) { return resolvestate("Piece2"); }
				else { return resolvestate("Piece1"); }
				return resolvestate(null);
			}
			loop;
		Piece1:
			SGLP AAAA 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 0) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			SGPG AAAA 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 0) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			goto Spawn;
		Piece2:
			SGLP BBBB 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 1) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			SGPG BBBB 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 1) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			goto Spawn;
		Piece3:
			SGLP DDDD 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 2) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			SGPG DDDD 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 2) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			goto Spawn;
		Piece4:
			SGLP CCCC 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 3) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			SGPG CCCC 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 3) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			goto Spawn;
		Piece5:
			SGLP EEEE 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 4) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			SGPG EEEE 1 bright
			{
				A_SetTics(random(2,3));
				if (invoker.SigilPiecesFound != 4) { return resolvestate("Spawn"); }
				return resolvestate(null);
			}
			goto Spawn;
		Pickup:
			TNT1 A 0
			{
				if (invoker.SigilPiecesFound == 0)
				{
					Console.Printf("\c[gold]What in all the realms is this thing? It looks like a piece of some broken weapon...\c- \cx[Slot 8]\c-!");
					A_SetInventory("Sigil1DD", 1, AAPTR_PLAYER1);
					return resolvestate("Success");
				}
				if (invoker.SigilPiecesFound == 1)
				{ 
					Console.Printf("\c[gold]Hmmm, this looks similar to that other object I found. They seem to link together to make a 'circle' of somekind...\c- \cx[Slot 8]\c-");
					A_SetInventory("Sigil2DD", 1, AAPTR_PLAYER1);
					return resolvestate("Success");
				}
				if (invoker.SigilPiecesFound == 2)
				{ 
					Console.Printf("\c[gold]Hmmm... this object looks similar too, and interfaces with that odd 'weapon' I found earlier...\c- \cx[Slot 8]\c-");
					A_SetInventory("Sigil3DD", 1, AAPTR_PLAYER1);
					return resolvestate("Success");
				}
				if (invoker.SigilPiecesFound == 3)
				{ 
					Console.Printf("\c[gold]Looks like this is the opposite 'prong' of that build-a-weapon I've been finding parts of...\c- \cx[Slot 8]\c-");
					A_SetInventory("Sigil4DD", 1, AAPTR_PLAYER1);
					return resolvestate("Success");
				}
				if (invoker.SigilPiecesFound == 4)
				{ 
					Console.Printf("\c[gold]Woah! Now this piece seems to be the last of that weird weapon I've been finding parts of. It's glowing with incredible energies...\c- \cx[Slot 8]\c-");
					A_SetInventory("Sigil5DD", 1, AAPTR_PLAYER1);
					return resolvestate("Success");
				}
				return resolvestate(null);
			}
			Fail;
		Success:
			TNT1 A 0
			{
				A_SetInventory("SigilModeType",(invoker.SigilPiecesFound+1));
				Thing_Remove(0);
			}
			stop;
	}
}

class SigilDD : DinahWeapon replaces Sigil
{
	// NUmPieces gets stored in 'health', so that it can be quickly accessed by ACS's GetSigilPieces function.
	int downpieces;
	int basedrain;
	int drainamt;
	int truedrainamt;
	
	Default
	{
		Weapon.Kickback 100;
		Weapon.SelectionOrder 4000;
		Weapon.SlotNumber 8;
		Weapon.SlotPriority 6.0;
		Health 1;
		+FLOORCLIP
		+WEAPON.CHEATNOTWEAPON
		Inventory.PickupSound "weapons/sigilcharge";
		Tag "The Sigil of the One God: \c[purple]<FIRE>\c- shoots an attack dependent on the current 'phase' of it. \c[purple]<USER4>\c- allows you to assemble/disassemble individual pieces that you've collected to change its main attack. \c[brick]Uses your\c- \c[red]HEALTH\c- \c[brick]as ammo and can be fatal if overused too much at once.\c-";
		Inventory.Icon "I_SGL1";
		Inventory.PickupMessage "$TXT_SIGIL";
	}
	
	States(Actor)
	{
		Spawn:
			SIGL A 1;
			SIGL A -1 A_SelectPiece;
			Stop;
			SIGL B -1;
			Stop;
			SIGL C -1;
			Stop;
			SIGL D -1;
			Stop;
			SIGL E -1;
			Stop;
	}
	
	States(Weapon)
	{
		Deselect:
			"----" A 1 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 5, "Deselect5");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 5, "Deselect5");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 4, "Deselect4");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 3, "Deselect3");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 2, "Deselect2");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 1, "Deselect1");
		Deselect1:
			DSGH A 1 Bright 
			{ 
				A_GetSigilDrainAmt();
				A_Lower(12);
			}
			Loop;
		Deselect2:
			DSGH B 1 Bright 
			{
				A_GetSigilDrainAmt();
				A_Lower(12);
			}
			Loop;
		Deselect3:
			DSGH C 1 Bright 
			{ 
				A_GetSigilDrainAmt();
				A_Lower(12);
			}
			Loop;
		Deselect4:
			DSGH D 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Lower(12);
			}
			Loop;
		Deselect5:
			DSGH E 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Lower(12);
			}
			Loop;

		//
		Select:
			"----" A 1 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 5, "Select5");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 5, "Select5");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 4, "Select4");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 3, "Select3");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 2, "Select2");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 1, "Select1");
		Select1:
			DSGH A 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Raise(12);
			}
			Loop;
		Select2:
			DSGH B 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Raise(12);
			}
			Loop;
		Select3:
			DSGH C 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Raise(12);
			}
			Loop;
		Select4:
			DSGH D 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Raise(12);
			}
			Loop;
		Select5:
			DSGH E 1 Bright
			{ 
				A_GetSigilDrainAmt();
				A_Raise(12);
			}
			Loop;

		//Well, it seems using "----" A in 'Ready' makes ZDoom refuse
		//to give you the item. Interesting.
		Ready:
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 5, "Ready5");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 4, "Ready4");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 3, "Ready3");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 2, "Ready2");
			TNT1 A 0 A_JumpIf(CountInv("SigilModeType",AAPTR_PLAYER1) == 1, "Ready1");
		Ready1:
			DSGH A 1 
			{
				A_WeaponReady(WRF_ALLOWUSER4);
				A_GetSigilDrainAmt();
			}
			goto Ready;
		Ready2:
			DSGH B 1
			{
				A_WeaponReady(WRF_ALLOWUSER4);
				A_GetSigilDrainAmt();
			}
			goto Ready;
		Ready3:
			DSGH C 1
			{
				A_WeaponReady(WRF_ALLOWUSER4);
				A_GetSigilDrainAmt();
			}
			goto Ready;
		Ready4:
			DSGH D 1
			{
				A_WeaponReady(WRF_ALLOWUSER4);
				A_GetSigilDrainAmt();
			}
			goto Ready;
		Ready5:
			DSGH E 1
			{
				A_WeaponReady(WRF_ALLOWUSER4);
				A_GetSigilDrainAmt();
			}
			goto Ready;
			
		User4:
			"####" # 0
			{
				A_SetInventory("SigilPieces",(invoker.health),AAPTR_PLAYER1);
				if (CountInv("SigilPieces",AAPTR_PLAYER1) > 1)
				{
					A_GiveInventory("SigilModeType",1,AAPTR_PLAYER1);
					A_StartSound("weapons/sigil",CHAN_WEAPON);

					if (CountInv("SigilModeType",AAPTR_PLAYER1) > CountInv("SigilPieces",AAPTR_PLAYER1)) { A_SetInventory("SigilModeType",1,AAPTR_PLAYER1); }
				}
				
				if (CountInv("SigilModeType",AAPTR_PLAYER1) == 1) { return resolvestate("Change1"); }
				if (CountInv("SigilModeType",AAPTR_PLAYER1) == 2) { return resolvestate("Change2"); }
				if (CountInv("SigilModeType",AAPTR_PLAYER1) == 3) { return resolvestate("Change3"); }
				if (CountInv("SigilModeType",AAPTR_PLAYER1) == 4) { return resolvestate("Change4"); }
				if (CountInv("SigilModeType",AAPTR_PLAYER1) == 5) { return resolvestate("Change5"); }
				return resolvestate(null);
			}
			goto Ready;
		Change1:
			DSGH A 1 
			{ 
				A_GetSigilDrainAmt();
				A_SetTics(random(6,8)*2);
			}
			goto Ready;
		Change2:
			DSGH B 1 
			{ 
				A_GetSigilDrainAmt();
				A_SetTics(random(6,8)*2);
			}
			goto Ready;
		Change3:
			DSGH C 1 
			{ 
				A_GetSigilDrainAmt();
				A_SetTics(random(6,8)*2);
			}
			goto Ready;
		Change4:
			DSGH D 1 
			{ 
				A_GetSigilDrainAmt();
				A_SetTics(random(6,8)*2);
			}
			goto Ready;
		Change5:
			DSGH E 1 
			{ 
				A_GetSigilDrainAmt();
				A_SetTics(random(6,8)*2);
			}
			goto Ready;
		
		Fire:
			TNT1 A 0
			{
				invoker.A_CheckIPState1();
				invoker.A_ConfirmIPAttackSigil(181,0,1,3,true,(3 * CountInv("SigilModeType")));

				if (CountInv("SigilModeType") >= 5) 
				{
					return resolvestate("Fire5");
				}
				if (CountInv("SigilModeType") == 4) 
				{
					return resolvestate("Fire4");
				}
				if (CountInv("SigilModeType") == 3)
				{
					return resolvestate("Fire3");
				}
				if (CountInv("SigilModeType") == 2)
				{
					return resolvestate("Fire2");
				}
				if (CountInv("SigilModeType") <= 1) 
				{
					return resolvestate("Fire1");
				}
				return resolvestate(null);
			}
		Fire1:
			DSGH A 18 Bright A_SigilCharge(18);
			DSGH A 3 Bright A_GunFlashSigil(3);
			DSGH A 10 A_FireSigil1(10);
			DSGH A 5 A_EndSigilFire(5);
			Goto FireEnd;
		Fire2:
			DSGH B 18 Bright A_SigilCharge(18);
			DSGH B 3 Bright A_GunFlashSigil(3);
			DSGH B 10 A_FireSigil2(10);
			DSGH B 5 A_EndSigilFire(5);
			Goto FireEnd;
		Fire3:
			DSGH C 18 Bright A_SigilCharge(18);
			DSGH C 3 Bright A_GunFlashSigil(3);
			DSGH C 10 A_FireSigil3(10);
			DSGH C 5 A_EndSigilFire(5);
			Goto FireEnd;
		Fire4:
			DSGH D 18 Bright A_SigilCharge(18);
			DSGH D 3 Bright A_GunFlashSigil(3);
			DSGH D 10 A_FireSigil4(10);
			DSGH D 5 A_EndSigilFire(5);
			Goto FireEnd;
		Fire5:
			DSGH E 18 Bright A_SigilCharge(18);
			DSGH E 3 Bright A_GunFlashSigil(3);
			DSGH E 10 A_FireSigil5(10);
			DSGH E 5 A_EndSigilFire(5);
			Goto FireEnd;
		FireEnd:
			TNT1 A 0
			{
				invoker.A_CheckIPModeOnUse();
			}
			Goto Ready;
		Flash:
			DSGF A 4 Bright A_Light2;
			DSGF B 6 Bright A_LightInverse;
			DSGF A 4 Bright A_Light1;
			DSGF A 0 Bright A_Light0;
			Stop;
	}
	
	//============================================================================
	//
	// ASigil :: HandlePickup
	//
	//============================================================================

	override bool HandlePickup (Inventory item)
	{
		if (item is "SigilDD")
		{
			int otherPieces = item.health;
			if (otherPieces > health)
			{
				item.bPickupGood = true;
				Icon = item.Icon;
				// If the player is holding the Sigil right now, drop it and bring
				// it back with the new piece(s) in view.
				if (Owner.player != null && Owner.player.ReadyWeapon == self)
				{
					DownPieces = health;
					Owner.player.PendingWeapon = self;
				}
				health = otherPieces;
			}
			return true;
		}
		return false;
	}

	//============================================================================
	//
	// ASigil :: CreateCopy
	//
	//============================================================================

	override Inventory CreateCopy (Actor other)
	{
		SigilDD copy = SigilDD(Spawn("SigilDD"));
		copy.Amount = Amount;
		copy.MaxAmount = MaxAmount;
		copy.health = health;
		copy.Icon = Icon;
		GoAwayAndDie ();
		return copy;
	}

	//============================================================================
	//
	// A_SelectPiece
	//
	// Decide which sprite frame self Sigil should use as an item, based on how
	// many pieces it represents.
	//
	//============================================================================
	
	void A_SelectPiece()
	{
		int pieces = min(health, 5);

		if (pieces > 1)
		{
			SetState (FindState("Spawn") + pieces);
		}
	}

	action void A_GetSigilDrainAmt(int usetype = 0)
	{
		invoker.drainamt = (0.03 * Player.mo.CountInv("PlayerMaxHP"));
		if (invoker.drainamt < 1) invoker.drainamt = 1;
		invoker.drainamt *= CountInv("SigilModeType");
		if (bINVULNERABLE || player.cheats & CF_GODMODE2 || player.cheats & CF_GODMODE || CountInv("PowerInvulnDD") || CountInv("PowerInvulnerable"))
		{
			invoker.drainamt = 0;
		}
		invoker.truedrainamt = invoker.drainamt;
		if (CountInv("IPUseMode"))
		{
			let MiscItem = PlayerStatItem(Player.mo.FindInventory("PlayerStatItem"));
			let globalvars = DDGlobalVariables.Get();
			double sigilcost = (3.0 * player.mo.CountInv("SigilModeType"));
			invoker.IPCostTemp = invoker.A_GetIPCost(181,true,sigilcost);
			If (MiscItem.ItemPoints >= invoker.IPCostTemp && globalvars.ItemPoints >= invoker.IPCostTemp)
			{
				invoker.truedrainamt = ceil(int(0.334 * invoker.truedrainamt));
				if (invoker.truedrainamt < 1) invoker.truedrainamt = 1;
			}
		}
	}

	//============================================================================
	//
	// A_SelectSigilView
	//
	// Decide which first-person frame self Sigil should show, based on how many
	// pieces it represents. Strife did self by selecting a flash that looked like
	// the Sigil whenever you switched to it and at the end of an attack. I have
	// chosen to make the weapon sprite choose the correct frame and let the flash
	// be a regular flash. It means I need to use more states, but I think it's
	// worth it.
	//
	//============================================================================

	action void A_SelectSigilView ()
	{
		if (player == null)
		{
			return;
		}
		PSprite pspr = player.GetPSprite(PSP_WEAPON);
		if (pspr) pspr.SetState(pspr.CurState + invoker.health);
		invoker.downpieces = 0;
	}

	//============================================================================
	//
	// A_SelectSigilDown
	//
	// Same as A_SelectSigilView, except it uses DownPieces. self is so that when
	// you pick up a Sigil, the old one will drop and *then* change to the new
	// one.
	//
	//============================================================================

	action void A_SelectSigilDown ()
	{
		if (player == null)
		{
			return;
		}
		PSprite pspr = player.GetPSprite(PSP_WEAPON);
		int pieces = invoker.downpieces;
		if (pieces < 1 || pieces > 5) pieces = invoker.health;
		if (pspr) pspr.SetState(pspr.CurState + pieces);
	}

	//============================================================================
	//
	// A_SelectSigilAttack
	//
	// Same as A_SelectSigilView, but used just before attacking.
	//
	//============================================================================

	action void A_SelectSigilAttack ()
	{
		if (player == null)
		{
			return;
		}
		PSprite pspr = player.GetPSprite(PSP_WEAPON);
		if (pspr) pspr.SetState(pspr.CurState + (4 * invoker.health - 3));
	}

	//
	//
	//
	action void A_SigilFireTics(int ticduration, double levelfactor = 0.075, int ticmin = 1)
	{
		levelfactor *= 0.25;
		if (Player.mo.FindInventory("PowerStrength") || Player.mo.FindInventory("PowerStrengthDD")) ticduration *= frandompick(0.75,0.875,0.875,1.0,1.0,1.0,1.0,1.0);
		let MiscItem = PlayerStatItem(Player.mo.FindInventory("PlayerStatItem"));
		if (MiscItem) ticduration -= (MiscItem.TruePlayerLevel * levelfactor);
		if (invoker.IPAttackCheck) ticduration = ceil(ticduration * 0.5);
		if (ticduration < ticmin) ticduration = ticmin;
		A_SetTics(ticduration);
	}

	action void A_EndSigilFire(int ticduration)
	{
		A_SigilFireTics(ticduration,0.025,0);
	}
	
	action void A_GunFlashSigil(int ticduration)
	{
		A_SigilFireTics(ticduration,0.015,0);
		A_GunFlash();
	}

	//============================================================================
	//
	// A_SigilCharge
	//
	//============================================================================

	action void A_SigilCharge(int ticduration)
	{
		invoker.basedrain = (0.03 * Player.mo.CountInv("PlayerMaxHP"));
		if (invoker.basedrain < 1) invoker.basedrain = 1;

		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);
		if (player != null)
		{
			player.extralight = 2;
		}
		
		A_SigilFireTics(ticduration,0.125,0);
	}

	//============================================================================
	//
	// A_FireSigil1
	//
	//============================================================================

	action void A_FireSigil1(int ticduration)
	{
		Actor spot = null;
		EEProjectile spot2 = null;
		FTranslatedLineTarget t;

		if (player == null || player.ReadyWeapon == null)
			return;
		
		double draindmg = (1.0 * invoker.basedrain);
		if (invoker.IPAttackCheck) draindmg = ceil(int(0.334 * draindmg));
		if (draindmg < 1) draindmg = 1;

		DamageMobj (self, null, draindmg, 'SigilDrain', DMG_NO_ARMOR);
		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);

		double shotangle = 0;
		double shotangleend = 0;
		double shotangleinc = 0;
		double origangle = angle;
		int maxshots = 1;
		if (invoker.IPAttackCheck) 
		{
			if (random(1,8) <= 1)
			{
				shotangle = 0;
				shotangleend = 360;
				shotangleinc = 90;
				maxshots = 4;
			}
			else
			{
				shotangle = 0;
				shotangleend = 360;
				shotangleinc = 120;
				maxshots = 3;
			}
		}
		
		if (invoker.IPAttackCheck) A_SetAngle(angle+shotangle);
		for (int i = 0; i < maxshots; i++)
		{
			BulletSlope (t, ALF_PORTALRESTRICT);
			if (t.linetarget != null)
			{
				spot = Spawn("SpectralLightningSpotNew", (t.linetarget.pos.xy, t.linetarget.floorz), ALLOW_REPLACE);
				if (spot != null)
				{
					spot.tracer = t.linetarget;
				}
			}
			else
			{
				if (i && invoker.IPAttackCheck) A_SetAngle(angle+shotangleinc);
				spot = Spawn("SpectralLightningSpotNew", Pos, ALLOW_REPLACE);
				if (spot != null)
				{
					spot.VelFromAngle(28., angle);
				}
			}
			if (spot != null)
			{
				spot.SetFriendPlayer(player);
				spot.target = self;
				if (invoker.IPAttackCheck)
				{
					spot.ReactionTime = randompick(70,random(87,88),random(87,88),random(87,88),random(87,88),random(87,88),105);
					spot2 = EEProjectile(spot);
					if (spot2) spot2.IPAttack = true;
				}
			}
		}
		if (invoker.IPAttackCheck) A_SetAngle(origangle);
		
		A_SigilFireTics(ticduration,0.075,1);
	}

	//============================================================================
	//
	// A_FireSigil2
	//
	//============================================================================

	action void A_FireSigil2(int ticduration)
	{
		EEProjectile spot2;
		if (player == null || player.ReadyWeapon == null)
			return;

		double draindmg = (2.0 * invoker.basedrain);
		if (invoker.IPAttackCheck) draindmg = ceil(int(0.334 * draindmg));
		if (draindmg < 1) draindmg = 1;

		DamageMobj (self, null, draindmg, 'SigilDrain', DMG_NO_ARMOR);
		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);
		
		double shotangle = 0;
		double shotangleend = 0;
		double shotangleinc = 0;
		double origangle = angle;
		int extrabounces = 0;
		int maxshots = 1;
		if (invoker.IPAttackCheck) 
		{
			if (random(1,8) <= 1)
			{
				shotangle = -45.0;
				shotangleend = 45.0;
				shotangleinc = 22.5;
				maxshots = 5;
				extrabounces = randompick(1,1,1,1,2);
			}
			else
			{
				shotangle = -22.5;
				shotangleend = 22.5;
				shotangleinc = 22.5;
				maxshots = 3;
				extrabounces = 0;
			}
		}
		
		if (invoker.IPAttackCheck) A_SetAngle(angle+shotangle);
		for (int i = 0; i < maxshots; i++)
		{
			if (i && invoker.IPAttackCheck) A_SetAngle(angle+shotangleinc);
			Actor spot = SpawnPlayerMissile("SpectralLightningH1New");
			if (spot != null)
			{
				spot.target = self;
				if (invoker.IPAttackCheck)
				{
					spot.Speed *= 1.5;
					spot.BounceFactor = 1.00;
					spot.WallBounceFactor = 1.00;
					spot.BounceCount = 2 + extrabounces;
					spot.bSKYEXPLODE = true;
					spot.bBOUNCEONWALLS = true;
					spot.bBOUNCEONFLOORS = true;
					spot.bBOUNCEONCEILINGS = true;
					spot.bCANBOUNCEWATER = true;
					spot.bDONTBOUNCEONSHOOTABLES = true;
					spot2 = EEProjectile(spot);
					if (spot2)
					{
						spot2.IPAttack = true;
					}
				}
			}
		}
		if (invoker.IPAttackCheck) A_SetAngle(origangle);
		
		A_SigilFireTics(ticduration,0.075,1);
	}

	//============================================================================
	//
	// A_FireSigil3
	//
	//============================================================================

	action void A_FireSigil3(int ticduration)
	{
		EEProjectile spot2;
		if (player == null || player.ReadyWeapon == null)
			return;

		double draindmg = (3.0 * invoker.basedrain);
		if (invoker.IPAttackCheck) draindmg = ceil(int(0.334 * draindmg));
		if (draindmg < 1) draindmg = 1;

		DamageMobj (self, null, draindmg, 'SigilDrain', DMG_NO_ARMOR);
		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);
		double startangle = 90.0;
		if (invoker.IPAttackCheck) startangle = 180.0;
		int shotcount = 20;
		if (invoker.IPAttackCheck) shotcount = 60;
		double anginc = 9.0;
		if (invoker.IPAttackCheck) anginc = 6.0;

		angle -= startangle;
		for (int i = 0; i < shotcount; ++i)
		{
			angle += anginc;
			Actor spot = SpawnSubMissile("SpectralLightningBall1New", self);
			if (spot != null)
			{
				spot.SetZ(pos.z + 32);
				spot.target = self;
				if (invoker.IPAttackCheck)
				{
					spot.Speed *= 1.5;
					spot.BounceFactor = 1.00;
					spot.WallBounceFactor = 1.00;
					spot.BounceCount = 2;
					spot.bSKYEXPLODE = true;
					spot.bBOUNCEONWALLS = true;
					spot.bBOUNCEONFLOORS = true;
					spot.bBOUNCEONCEILINGS = true;
					spot.bCANBOUNCEWATER = true;
					spot.bDONTBOUNCEONSHOOTABLES = true;
					spot2 = EEProjectile(spot);
					if (spot2) spot2.IPAttack = true;
				}
			}
		}
		angle -= startangle;
		
		A_SigilFireTics(ticduration,0.075,1);
	}

	//============================================================================
	//
	// A_FireSigil4
	//
	//============================================================================

	action void A_FireSigil4(int ticduration)
	{
		EEProjectile spot2;
		FTranslatedLineTarget t;
		
		if (player == null || player.ReadyWeapon == null)
			return;

		double draindmg = (4.0 * invoker.basedrain);
		if (invoker.IPAttackCheck) draindmg = ceil(int(0.334 * draindmg));
		if (draindmg < 1) draindmg = 1;

		DamageMobj (self, null, draindmg, 'SigilDrain', DMG_NO_ARMOR);
		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);
		
		double startangle = 0;
		if (invoker.IPAttackCheck) startangle = 22.5;
		int shotcount = 1;
		if (invoker.IPAttackCheck) shotcount = 3;
		double anginc = 0;
		if (invoker.IPAttackCheck) anginc = 22.5;

		angle -= startangle;
		for (int i = 0; i < shotcount; ++i)
		{
			if (i > 0) angle += anginc;
			Actor spot;
			BulletSlope (t, ALF_PORTALRESTRICT);
			if (t.linetarget != null)
			{
				spot = SpawnPlayerMissile ("SpectralLightningBigV1New", angle, pLineTarget: t, aimFlags: ALF_PORTALRESTRICT);
				if (spot != null)
				{
					spot.tracer = t.linetarget;
				}
			}
			else
			{
				spot = SpawnPlayerMissile ("SpectralLightningBigV1New");
				if (spot != null)
				{
					spot.VelFromAngle(spot.Speed, angle);
				}
			}
			if (spot != null)
			{
				spot.target = self;
				if (invoker.IPAttackCheck)
				{
					spot.Speed *= 1.5;
					spot.BounceFactor = 1.00;
					spot.WallBounceFactor = 1.00;
					spot.BounceCount = 2;
					spot.bSKYEXPLODE = true;
					spot.bBOUNCEONWALLS = true;
					spot.bBOUNCEONFLOORS = true;
					spot.bBOUNCEONCEILINGS = true;
					spot.bCANBOUNCEWATER = true;
					spot.bDONTBOUNCEONSHOOTABLES = true;
					spot2 = EEProjectile(spot);
					if (spot2)
					{
						spot2.IPAttack = true;
					}
				}
			}
		}
		angle -= startangle;
		
		A_SigilFireTics(ticduration,0.075,1);
	}

	//============================================================================
	//
	// A_FireSigil5
	//
	//============================================================================

	action void A_FireSigil5(int ticduration)
	{
		if (player == null || player.ReadyWeapon == null)
			return;

		double draindmg = (5.0 * invoker.basedrain);
		if (invoker.IPAttackCheck) draindmg = ceil(int(0.334 * draindmg));
		if (draindmg < 1) draindmg = 1;

		DamageMobj (self, null, draindmg, 'SigilDrain', DMG_NO_ARMOR);
		A_StartSound ("weapons/sigilcharge", CHAN_WEAPON);
		
		double startangle = 0;
		if (invoker.IPAttackCheck) startangle = 22.5;
		int shotcount = 1;
		if (invoker.IPAttackCheck) shotcount = 3;
		double anginc = 0;
		if (invoker.IPAttackCheck) anginc = 22.5;

		angle -= startangle;
		for (int i = 0; i < shotcount; ++i)
		{
			if (i > 0) angle += anginc;
			Actor spot = SpawnPlayerMissile("SpectralLightningBigBall1New");
			if (spot != null)
			{
				if (invoker.IPAttackCheck)
				{
					spot.Speed *= 1.5;
					spot.BounceFactor = 1.00;
					spot.WallBounceFactor = 1.00;
					spot.BounceCount = 2;
					spot.bSKYEXPLODE = true;
					spot.bBOUNCEONWALLS = true;
					spot.bBOUNCEONFLOORS = true;
					spot.bBOUNCEONCEILINGS = true;
					spot.bCANBOUNCEWATER = true;
					spot.bDONTBOUNCEONSHOOTABLES = true;
				}
			}
		}
		angle -= startangle;
		
		A_SigilFireTics(ticduration,0.075,1);
	}

	//============================================================================
	//
	// ASigil :: SpecialDropAction
	//
	// Monsters don't drop Sigil pieces. The Sigil pieces grab hold of the person
	// who killed the dropper and automatically enter their inventory. That's the
	// way it works if you believe Macil, anyway...
	//
	//============================================================================

	override bool SpecialDropAction (Actor dropper)
	{
		// Give a Sigil piece to every player in the game
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (playeringame[i] && players[i].mo != null)
			{
				GiveSigilPiece (players[i].mo);
				Destroy ();
			}
		}
		return true;
	}

	//============================================================================
	//
	// ASigil :: GiveSigilPiece
	//
	// Gives the actor another Sigil piece, up to 5. Returns the number of Sigil
	// pieces the actor previously held.
	//
	//============================================================================

	static int GiveSigilPiece (Actor receiver)
	{
		SigilDD sigl = SigilDD(receiver.FindInventory("SigilDD"));
		if (sigl == null)
		{
			sigl = SigilDD(Spawn("Sigil1DD"));
			if (!sigl.CallTryPickup (receiver))
			{
				sigl.Destroy ();
			}
			return 0;
		}
		else if (sigl.health < 5)
		{
			++sigl.health;
			static const class<Sigil> sigils[] =
			{
				"Sigil1", "Sigil2", "Sigil3", "Sigil4", "Sigil5"
			};
			sigl.Icon = GetDefaultByType(sigils[clamp(sigl.health, 1, 5)-1]).Icon;
			// If the player has the Sigil out, drop it and bring it back up.
			if (sigl.Owner.player != null && sigl.Owner.player.ReadyWeapon == sigl)
			{
				sigl.Owner.player.PendingWeapon = sigl;
				sigl.DownPieces = sigl.health - 1;
			}
			return sigl.health - 1;
		}
		else
		{
			return 5;
		}
	}
}

// Sigil 1 ------------------------------------------------------------------

class Sigil1DD : SigilDD replaces Sigil1
{
	Default
	{
		Inventory.Icon "I_SGL1";
		Health 1;
	}
}

// Sigil 2 ------------------------------------------------------------------

class Sigil2DD : SigilDD replaces Sigil2
{
	Default
	{
		Inventory.Icon "I_SGL2";
		Health 2;
	}
}

// Sigil 3 ------------------------------------------------------------------

class Sigil3DD : SigilDD replaces Sigil3
{
	Default
	{
		Inventory.Icon "I_SGL3";
		Health 3;
	}
}

// Sigil 4 ------------------------------------------------------------------

class Sigil4DD : SigilDD replaces Sigil4
{
	Default
	{
		Inventory.Icon "I_SGL4";
		Health 4;
	}
}

// Sigil 5 ------------------------------------------------------------------

class Sigil5DD : SigilDD replaces Sigil5
{
	Default
	{
		Inventory.Icon "I_SGL5";
		Health 5;
	}
}

// The base class for attacks used by The Sigil of the One God, whether they are the Player's attacks or those of a Spectral Monster. 
// The base class also has a bit of explosive radius for their impact, although not all of their inheritors use said explosive damage.

// Container for all spectral lightning deaths ------------------------------
class SpectralLightningBaseNew : EEProjectile // replaces SpectralLightningBase 
{
	default
	{
		+SPECTRAL 
		DamageType "Sigil";
		+NOTELEPORT
		+ACTIVATEIMPACT
		+ACTIVATEPCROSS
		+STRIFEDAMAGE
		MaxStepHeight 4;
		RenderStyle "Add";
		SeeSound "weapons/sigil";
		DeathSound "weapons/sigilhit";
	}
	
	States
	{
		Death:
			ZAP1 B 3 bright
			{
				A_GetSigilDamage(0,0); A_GetSigilDamage(0,1);
				A_Explode((finaldamagedealt), (finaldamagedealt2), 0);
			}
			ZAP1 A 3 bright 
			{
				if (random(1,256) > 96)
				{
					A_AlertMonsters();
				}
			}
			ZAP1 BCDEFE 3 bright
			{
			}
			ZAP1 DCB 2 bright
			{
			}
			ZAP1 A 1 bright
			{
			}
			Stop;
	}
}


// Spectral Lightning death that does not explode ---------------------------
class SpectralLightningDeath1New : SpectralLightningBaseNew
{
	States
	{
		Death:
			Goto Super::Death+1;
	}
}

// Spectral Lightning death that does not alert monsters --------------------
class SpectralLightningDeath2New : SpectralLightningBaseNew
{
	States
	{
		Death:
			Goto Super::Death+2;
	}
}

// Spectral Lightning death that is shorter than the rest -------------------
class SpectralLightningDeathShortNew : SpectralLightningBaseNew
{
	States
	{
		Death:
			Goto Super::Death+6;
	}
}

// Sigil Lightning Spot (roams around dropping lightning from above) --------
class SpectralLightningSpotNew : SpectralLightningDeath1New
{
	Default
	{
		Speed 18;
		ReactionTime 70;
		+NOBLOCKMAP
		+NOBLOCKMONST
		+NODROPOFF
		RenderStyle "Translucent";
		Alpha 0.6;
	}

	States
	{
		Spawn:
			ZAP5 A 4 Bright A_Countdown;
			ZAP5 B 4 Bright A_SpectralLightning;
			ZAP5 CD 4 Bright A_Countdown;
			Loop;
	}
}

// Sigil Lightning (Vertical #1) --------------------------------------------
class SpectralLightningV1New : SpectralLightningDeathShortNew
{
	Default
	{
		Speed 22;
		Radius 8;
		Height 24;
		Damage 100;
		Projectile;
		DamageType "SpectralLow";
		+SPECTRAL
	}
	States
	{
		Spawn:
			ZOT1 AB 4 Bright;
			ZOT1 CDE 6 Bright;
			Loop;
	}
}

// Sigil Lightning (Vertical #2 - less damaging) ----------------------------
class SpectralLightningV2New : SpectralLightningV1New
{
	Default
	{
		Damage 50;
	}
}

// Spectral Lightning (Horizontal #1) -------------------------------------
class SpectralLightningH1New : SpectralLightningBaseNew
{
	Default
	{
		Tag "Sigil Lightning Bolt";
		Speed 30;
		Radius 8;
		Height 16;
		DamageFunction (finaldamagedealt); // 70
		Projectile;
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			ZAP6 A 0 Bright NoDelay { A_GetSigilDamage(5,0); }
			ZAP6 A 4 Bright
			{
				A_GetSigilDamage(5,0);
			}
			ZAP6 BC 4 Bright 
			{
				A_GetSigilDamage(5,0);
				A_SpectralLightningTail();
			}
			Loop;
	}
}

// Spectral Lightning (Horizontal #2) -------------------------------------
class SpectralLightningH2New : SpectralLightningH1New
{
	Default
	{
		Tag "Sigil Lightning Bolt";
		Damage 20;
	}
}

// Spectral Lightning (Horizontal #3) -------------------------------------
class SpectralLightningH3New : SpectralLightningH1New
{
	Default
	{
		Tag "Sigil Lightning Bolt";
		DamageFunction (finaldamagedealt); // 10
	}
	
	States
	{
		Spawn:
			ZAP6 A 0 Bright NoDelay { A_GetSigilDamage(7,0); }
			ZAP6 A 4 Bright
			{
				A_GetSigilDamage(7,0);
			}
			ZAP6 BC 4 Bright 
			{
				A_GetSigilDamage(7,0);
				A_SpectralLightningTail();
			}
			Loop;
	}
}
	
// ASpectralLightningHTail --------------------------------------------------
class SpectralLightningHTailNew : EEProjectile
{
	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+DROPOFF
		+ZDOOMTRANS
		RenderStyle "Add";
	}
	States
	{
		Spawn:
			ZAP6 ABC 5 Bright;
			Stop;
	}
}
	
// Spectral Lightning (Ball Shaped #1) --------------------------------------
class SpectralLightningBall1New : SpectralLightningBaseNew
{
	Default
	{
		Tag "Sigil Spread Shot";
		Speed 30;
		Radius 8;
		Height 16;
		DamageFunction (finaldamagedealt); // 70
		Projectile;
		+SPECTRAL
	}
	States
	{
		Spawn:
			ZOT3 A 0 Bright NoDelay { A_GetSigilDamage(1,0); }
			ZOT3 ABCDE 4 Bright
			{
				A_GetSigilDamage(1,0);
			}
			Loop;
	}
}

// Spectral Lightning (Ball Shaped #2) --------------------------------------
class SpectralLightningBall2New : SpectralLightningBall1New
{
	Default
	{
		Tag "Spectral Spread Shot";	
		DamageFunction (finaldamagedealt); // 20
	}
	
	States
	{
		Spawn:
			ZOT3 A 0 Bright NoDelay { A_GetSigilDamage(2,0); }
			ZOT3 ABCDE 4 Bright
			{
				A_GetSigilDamage(2,0);
			}
			Loop;
	}
}
	
// Sigil Lightning (Big Vertical #1) ----------------------------------------
class SpectralLightningBigV1New : SpectralLightningDeath1New
{
	Default
	{
		Tag "Sigil Lightning Column";
		Speed 28;
		Radius 8;
		Height 16;
		DamageFunction (finaldamagedealt); // 120
		Projectile;
		+SPECTRAL
	}
	States
	{
		Spawn:
			ZOT2 A 0 Bright NoDelay { A_GetSigilDamage(3,0); }
			ZOT2 ABCDE 4 Bright 
			{
				A_GetSigilDamage(3,0);
				double tang = 19.6875;
				if (IPAttack) tang = (19.6875 * 3);
				A_SeekerMissile(tang,tang,SMF_LOOK|SMF_PRECISE); // A_Tracer2(tang);
			}
			Loop;
	}
}

// Sigil Lightning (Big Vertical #2) ----------------------------------------
class SpectralLightningBigV2New : SpectralLightningBigV1New
{
	Default
	{
		DamageFunction (finaldamagedealt/2); // 60
	}
}

// Spectral Lightning (Big Ball #1) -----------------------------------------
class SpectralLightningBigBall1New : SpectralLightningDeath2New
{
	Default
	{
		Tag "Sigil Lightning MegaBlast";
		Speed 18;
		Radius 15; // 20;
		Height 20; // 40;
		DamageFunction (finaldamagedealt); // 130
		Projectile;
		+SPECTRAL
	}
	
	override void Tick()
	{
		if (IPAttack) 
		{
			double tang = 19.6875;
			double tang2 = 2.4609375;
			if (GetAge() % 12 == 0) A_SeekerMissile(tang,tang,SMF_LOOK|SMF_PRECISE);
			if (GetAge() % 3 == 0) A_SeekerMissile(tang2,tang2,SMF_LOOK|SMF_PRECISE);
		}
		Super.Tick();
	}
	
	States
	{
		Spawn:
			ZAP7 A 0 Bright NoDelay { A_GetSigilDamage(8,0); }
			ZAP7 AB 4 Bright 
			{
				A_GetSigilDamage(8,0);
				A_SpectralBigBallLightning("SpectralLightningH3New");
			}
			ZAP7 CDE 6 Bright
			{
				A_GetSigilDamage(8,0);
				A_SpectralBigBallLightning("SpectralLightningH3New");
			}
			Loop;
	}
}

// Spectral Lightning (Big Ball #2 - less damaging) -------------------------
class SpectralLightningBigBall2New : SpectralLightningBigBall1New
{
	Default
	{
		Damage 30;
	}
}

//*********************
//* LE CRAZEH BALZ :V *
//*********************
class CrazyBallDD : DinahWeapon
{
	default
	{
		Weapon.SelectionOrder 3000;
		Inventory.PickupSound "misc/w_pkup";
		Weapon.AmmoType "CzBall";
		Weapon.AmmoGive 1;
		Weapon.AmmoUse 1;
		Weapon.SlotNumber 9;
		Weapon.SlotPriority 5.0;
		Inventory.Pickupmessage "\c[gold]What in heck's name is this \c[sapphire]crazy looking ball-like thing\c[gold]...? \cx[Slot 9]\c-";
		AttackSound "";
		Tag "Crazy Ball: \c[purple]<FIRE>\c- throws a single ball forward that will emit a blizzard of colorful projectiles that weave everywhere. Can very rarely deal self-damage with a shot. \c[orange]Eventually exhausts itself and then explodes into bits.\c-";
		Scale 0.6;
		+FLOATBOB
	}
	
	override String PickupMessage()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		string msg = PickupMsg;
		if (MiscItem)
		{
			if (MiscItem.GrabbedCrazyBalls > 0) msg = "\c[gold]Another \c[sapphire]Crazy Ball\c-\c[gold]? Better use it carefully. These are chaotic as heck... \cx[Slot 9]\c-";
			else MiscItem.GrabbedCrazyBalls++;
		}
		return msg;
	}
	
	States 
	{ 
		Spawn: 
			CRZY A 0 A_Jump(240,2);
			CRZY A 0 A_StartSound("CRZ"); 
			CRZY AAAAAA 8;
			CRZY BCDODCB 2;
			CRZY A 0 A_Jump(128,3);		//Randomize
			CRZY AAAAAA 8;
			loop;
		Ready: 
			DCRZ A 1 
			{
				A_JumpIfNoAmmo("ReadyNoAmmo");
				A_WeaponReady(); // WRF_ALLOWUSER4
			}
			loop;
		ReadyNoAmmo: 
			TNT1 A 1 
			{
				A_WeaponReady(); // WRF_ALLOWUSER4
			}
			goto Ready;
		Deselect:
			DCRZ A 1 
			{
				A_Lower(12);
			}
			loop;
		Select: 
			DCRZ A 1 
			{
				A_Raise(12);
			}
			loop;
		Fire: 
			DCRZ A 1 A_JumpIfNoAmmo(5);
			DCRZ B 0
			{
				A_CheckIPState1();
				A_ConfirmIPAttack(211,0,9,13);
			}
			DCRZ B 6;
			DCRZ B 6;
			DCRZ C 10 
			{
				EEProjectile IPCompat;
				actor BombShots;
				bool success;
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD"))
				{
					[success, BombShots] = A_FireProjectile("CrazyBallBerserk", 0, 2, 5, 5);
				}
				else
				{
					[success, BombShots] = A_FireProjectile("CrazyBall", 0, 2, 5, 5);
				}
				if (BombShots && invoker.IPAttackCheck)
				{
					IPCompat = EEProjectile(BombShots);
					if (IPCompat)
					{
						IPCompat.IPattack = true;
						IPCompat.Speed *= frandompick(1.125,1.25,1.375);
					}
				}
				invoker.A_CheckIPModeOnUse();
			}
			Goto Select;
			DCRZ C 0;
			GoTo Deselect;
	} 
} 

class CzBall : Ammo
{
	default
	{
		Scale 0.6;
		+FLOATBOB
		Inventory.Amount 1;
		Inventory.MaxAmount 10;
		Ammo.BackpackAmount 0;
		Ammo.BackpackMaxAmount 15;
		Inventory.PickupMessage "";
		Inventory.PickupSound "misc/i_pkup";
		Inventory.Icon "CRZYZ0";
	}
	
	States
	{
		Spawn:
			CRZY A 8 A_GiveToTarget("CrazyBallDD", 1);
			CRZY AAAAAA 8;
			CRZY BCDODCB 2;
			Loop;
	}
}

class CrazyBall : EEProjectile
{
	int hurtflag;
	int hurtflag2;
	int expbase;
	string shottype;
	int basechance;
	default
	{
		Radius 8;
		Height 16;
		Speed 40;
		Damage 2;
		Scale 0.6;
		+ACTIVATEIMPACT
		+ACTIVATEPCROSS
		+DROPOFF
		+MISSILE
		+NOTELEPORT
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
		SeeSound "";
		DeathSound "";
		BounceType "Hexen";
		BounceCount 2;
	}
	
	override void PostBeginPlay()
	{
		shottype = "CrazyBalls";
		if (IPAttack) shottype = "CrazyBallsIP";
		super.PostBeginPlay();
	}
	
	override void Tick()
	{
		hurtflag = CMF_AIMDIRECTION|CMF_BADPITCH|CMF_TRACKOWNER;
		hurtflag2 = 0;
		if (random(1,128) <= 1 && !IPAttack) 
		{
			hurtflag = CMF_AIMDIRECTION|CMF_BADPITCH;
			hurtflag2 = XF_HURTSOURCE;
		}
		//if (target) Console.Printf("Target: %s", target.GetClassName());
		//Console.Printf("HurtFlag: %d, HurtFlag2: %d", hurtflag, hurtflag2);
		expbase = 64;
		if (IPAttack) expbase = 128;
		
		super.Tick();
	}
	
	void A_SpawnCZProjectile(class<Actor> missiletype, double spawnheight = 32, double spawnofs_xy = 0, double angle = 0, int flags = 0, double pitch = 0, int ptr = AAPTR_TARGET)
	{
		int baseangle = angle;
		A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
		if (IPAttack)
		{
			A_SetAngle(baseangle+frandom(-180,180));
			A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
			A_SetAngle(baseangle);
			if (random(1,(basechance*0.67)) <= 1) 
			{
				A_SetAngle(baseangle+frandom(-180,180));
				A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
				A_SetAngle(baseangle);
			}
			if (random(1,basechance) <= 1) 
			{
				A_SetAngle(baseangle+frandom(-180,180));
				A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
				A_SetAngle(baseangle);
			}
			if (random(1,(basechance*(basechance*0.67))) <= 1) 
			{
				A_SetAngle(baseangle+frandom(-180,180));
				A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
				A_SetAngle(baseangle);
			}
			if (random(1,(basechance*basechance)) <= 1) 
			{
				A_SetAngle(baseangle+frandom(-180,180));
				A_SpawnProjectile(missiletype, spawnheight, spawnofs_xy, angle, flags, pitch, ptr);
				A_SetAngle(baseangle);
			}
		}
	}

	States
	{
		Spawn:
			CRZY A 3;
			loop;
		Death:
			CRZY AAAA 20 A_StartSound("CRZCLIK3");
			CRZY BCD 8;
		Loop1:
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(3,5);
			}
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_StartSound("CRZ");
			CRZY D 0 
			{
				int base = 256;
				if (IPAttack) base *= 1.5;
				if (random(1,base) <= 1) return resolvestate("Loop2");
				return resolvestate(null);
			}
			GoTo Loop1;
		Loop2:
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(4,7);
			}
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(4,7);
			}
			CRZY O 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 70));
			CRZY D 1 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_StartSound("CRZ");
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(4,7);
			}
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 70));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_StartSound("CRZ");
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(4,7);
			}
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 70));
			CRZY D 0 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 70));
			CRZY D 1 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(4,7);
			}
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 
			{
				int base = 256;
				if (IPAttack) base *= 2;
				if (random(1,base) <= 32) return resolvestate("Loop3");
				return resolvestate(null);
			}
			GoTo Loop2;
		Loop3:
			CRZY D 0 A_StartSound("CRZ");
			CRZY D 0 
			{
				A_Explode(expbase,128,hurtflag2,0,32);
				basechance = random(5,9);
			}
			CRZY D 2 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 3 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 1 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 2 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 5 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 12, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 3 A_SpawnCZProjectile(shottype, 14, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 3 A_SpawnCZProjectile(shottype, 6, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 0 A_StartSound("CRZ");
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 1 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 2 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 3 A_SpawnCZProjectile(shottype, 10, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY O 5 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 4 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 5 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 6 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 7 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 8 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 9 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 10 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 11 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 12 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 14 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 17 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 20 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 25 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY D 30 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 35 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY DD 15 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(-10, 180));
			CRZY DD 15 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY DDD 15 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY DDDD 15 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY DDDDD 15 A_SpawnCZProjectile(shottype, 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 20 A_StartSound("CRZ6");
			CRZY D 20 A_Explode(expbase,128,hurtflag2,0,32);
			CRZY C 0 A_StartSound("CRZCLIK3");
			CRZY CBBBB 20;
			CRZY B 20 A_StartSound("CRZCLIK3");
			CRZY B 20;
			PBFF B 3 Bright;
			CRZY D 0 A_SpawnProjectile("CrazyFlash", 12,-2,0,2,0);
			CRZY DDDDDDDDDD 0 A_SpawnProjectile("Sparkles", 8, 0, random(-180, 180), hurtflag, random(-180, 180));
			CRZY DD 0 A_SpawnProjectile("Popcorn_Shrap1", 2, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY DDDDDDDDDDDDDDDDDDDDDDDDDDDDD 0 A_SpawnProjectile("Popcorn_Shrap7", 2, 0, random(-180, 180), hurtflag, random(0, 180));
			PBFF D 0 A_StartSound("crazyball/detonate");
			PBFF D 0;
			CRZY D 0 A_SpawnProjectile("CrazyBits1", 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits2", 12, 0, random(-180, 180), hurtflag, random(0, 180));
			PBFF C 3 Bright A_SpawnProjectile("CrazyFlash", 4,2,0,2,0);
			CRZY CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 0 A_SpawnProjectile("Popcorn_Shrap7", 2, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits3", 12, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits4", 12, 0, random(-180, 180), hurtflag, random(0, 180));
			PBFF D 3 Bright A_SpawnProjectile("CrazyFlash", 16,-4,0,2,0);
			CRZY DDDDDDDDDDDDDDDDDDDDDDDDDDDDDD 0 A_SpawnProjectile("Popcorn_Shrap7", 2, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits5", 11, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits6", 11, 0, random(-180, 180), hurtflag, random(0, 180));
			PBFF E 3 Bright A_SpawnProjectile("CrazyFlash", 8,4,0,2,0);
			CRZY EEEEEEEEEEEEEEEEEEEEEEE 0 A_SpawnProjectile("Popcorn_Shrap7", 2, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits7", 9, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits8", 9, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits9", 8, 0, random(-180, 180), hurtflag, random(0, 180));
			CRZY D 0 A_SpawnProjectile("CrazyBits10", 8, 0, random(-180, 180), hurtflag, random(0, 180));
			PBFF F 3 Bright;
			Stop;
	}
}

class CrazyBallBerserk : CrazyBall
{
	default
	{
		Speed 100;
		Damage 10;
	}
}

class CrazyFlash : EEProjectile
{
	default
	{
		+NOGRAVITY
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
	}
	
	States
	{
		Spawn:
			PBFF BCDEF 3 Bright;
			Stop;
	}
}

class CrazyBits1 : EEProjectile
{
	default
	{
		Radius 5;
		Height 5;
		Speed 4;
		Scale 0.6;
	}
	
	States
	{
		Spawn:
			CRZY E 15 A_Jump(3,1);
			goto Spawn;
			CRZY E 15;
			Stop;
	}
}	
class CrazyBits2 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY F 15 A_Jump(3,1);
			goto Spawn;
			CRZY F 15;
			Stop;
	}
}	
class CrazyBits3 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY G 15 A_Jump(3,1);
			goto Spawn;
			CRZY G 15;
			Stop;
	}
}
class CrazyBits4 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY H 15 A_Jump(3,1);
			goto Spawn;
			CRZY H 15;
			Stop;
	}
}

class CrazyBits5 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY I 15 A_Jump(3,1);
			goto Spawn;
			CRZY I 15;
			Stop;
	}
}

class CrazyBits6 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY J 15 A_Jump(3,1);
			goto Spawn;
			CRZY J 15;
			Stop;
	}
}

class CrazyBits7 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY K 15 A_Jump(3,1);
			goto Spawn;
			CRZY K 15;
			Stop;
	}
}

class CrazyBits8 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY L 15 A_Jump(3,1);
			goto Spawn;
			CRZY L 15;
			Stop;
	}
}

class CrazyBits9 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY M 15 A_Jump(3,1);
			goto Spawn;
			CRZY M 15;
			Stop;
	}
}

class CrazyBits10 : CrazyBits1
{
	States
	{
		Spawn:
			CRZY N 15 A_Jump(3,1);
			goto Spawn;
			CRZY N 15;
			Stop;
	}
}

class CrazyBalls : EEProjectile
{
	default
	{
		Radius 8;
		Height 6;
		Speed 3;
		Damage 9;
		Scale 0.6;
		Projectile;
		Alpha 0.8;
		SeeSound "";
		DeathSound "";
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
	}
	States
	{
		Spawn:
			CRZY P 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY R 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY P 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 2 Bright ThrustThing( (angle*random(-256,-128))/360, 4, 0, 0);
			CRZY R 2 Bright ThrustThing( (angle*random(-256,-128))/360, 4, 0, 0);
			CRZY S 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY P 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 2 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY R 2 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY Q 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY R 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			Goto Spawn;
		Death:
			GLOB B 3 Bright;
			GLOB A 3 Bright A_Scream();
			GLOB H 3 Bright A_Fall;
			Stop;
	}
}

class CrazyBallsIP : EEProjectile
{
	default
	{
		Radius 8;
		Height 6;
		Speed 5;
		DamageFunction (random(13,14) * random(1,8));
		Scale 0.75;
		Projectile;
		Alpha 0.85;
		SeeSound "";
		DeathSound "";
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
	}
	States
	{
		Spawn:
			CRZY P 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY P 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY P 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY P 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(-256,-128))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(256,-128))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(-256,-128))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(256,-128))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(-128,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(-128,256))/360, 4, 0, 0);
			CRZY P 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY P 1 Bright ThrustThing( (angle*random(-128,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(0,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(128,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(0,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY Q 1 Bright ThrustThing( (angle*random(0,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY S 1 Bright ThrustThing( (angle*random(0,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY R 1 Bright ThrustThing( (angle*random(0,256))/360, 4, 0, 0);
			Goto Spawn;
		Death:
			GLOB B 2 Bright;
			GLOB A 2 Bright A_Scream();
			GLOB H 2 Bright A_Fall;
			Stop;
	}
}

class Sparkles : EEProjectile
{
	default
	{
		Radius 5;
		Height 5;
		Speed 10;
		+MISSILE
		//+LOWGRAVITY
		+NOBLOCKMAP
		+NOTELEPORT
		+NODAMAGETHRUST
		+ACTIVATEIMPACT
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
		Scale 0.25;
	}
	
	States
	{
		Spawn:
			PWT2 ABCDABCDABCDABCDABCD 1 Bright;
			Stop;
		Death:
			PWT2 E 2 A_Scream();
			PWT2 F 2 A_Fall;
			PWT2 GHI 2;
			Stop;
	}
}

class Popcorn_Shrap1 : EEProjectile
{
	default
	{
		Radius 2;
		Height 2;
		Speed 3;
		+MISSILE 
		+LOWGRAVITY 
		+NOTELEPORT
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
		Scale 0.5;
		SeeSound "";
		DeathSound "";
	}
	States
	{
		Spawn:
			SHRA ABC 2 Bright ThrustThing( (angle*random(-256,256))/360, 1, 0, 0);
			SHRA C 0 Bright A_Jump(128,3);
			SHRA DE 2 Bright ThrustThing( (angle*random(-256,256))/360, 1, 0, 0);
			SHRA ABC 2 Bright;
			Goto Spawn;
		Death:
			SHRA DDEE 3 Bright;
			Stop;
	}
}

class Popcorn_Shrap7 : EEProjectile
{
	default
	{
		Radius 2;
		Height 2;
		Speed 6;
		Damage 7;
		+MISSILE 
		+LOWGRAVITY
		+NOTELEPORT
		-CASTSPRITESHADOW
		+NOSPRITESHADOW
		Scale 0.75;
		SeeSound "";
		DeathSound "";
	}
	States
	{
		Spawn:
			//CRZY P 2 Bright ThrustThing( (angle*random(-256,256))/360, 4, 0, 0);
			CRZY PQR 1 Bright;
			Goto Spawn;
		Death:
			GLOB B 3 Bright;
			GLOB A 3 Bright;
			GLOB H 3 Bright;
			Stop;
	}
}

// EVIL WARRIOR'S SHIELD
class EvilWarriorShield : DinahWeapon
{
	int shieldenergy;
	int shieldenergybits;
	int shieldenergycost;
	int shieldrefire;
	default
	{
		//$Category EE KDIZD Weapons
		//$Sprite "EWSHF0"
		Radius 16;
		Height 16;
		Speed 6;
		Inventory.Pickupsound "Dinah/GetWeapon";
		DDWeapon.PickupVoice true;
		DDWeapon.PickupSound2 "misc/w_pkup";
		DDWeapon.PickupVoice2 false;
		Weapon.AmmoType "PikeAmmo";
		Weapon.AmmoGive 3;
		Weapon.AmmoUse 0;
		Weapon.SlotNumber 9;
		Weapon.SlotPriority 6.0;
		Weapon.BobSpeed 0.334;
		Weapon.BobStyle "Smooth";
		Weapon.KickBack 0;
		Tag "Hell Warrior's Shield: \c[purple]<FIRE>\c- uses microunits of Devil's Food [1000 microunits per full ammo] to launch ripping green magic \c[sapphire]zap\c- shots. \c[purple]<ALT-FIRE>\c- makes you guard extensively with the shield, also \c[green]greatly increasing your defense and allowing you to reflect most projectiles\c-. \c[gold]Dashing in this mode lets you do a powerful shield-dash attack.\c- \c[green]Just having this equipped also boosts your defenses by a moderate amount.\c-";
		Inventory.PickupMessage "\c[gold]Huh!? What in the world is this \c[sapphire]broken shield\c[gold]...? It feels like \c[sapphire]Devil's Food\c[gold] can be fed to it...\c- \cx[Slot 9]\c-";
		Obituary "%o was ripped apart by %k's Hell Warrior's Shield.";
		BounceType "Doom";
		+WEAPON.NOALERT;
		+DROPOFF;
		+DONTGIB;
	}
	
	// Hell Warrior Shield
	action void A_PHellWarShieldOff()
	{
		A_SetInventory("EWShieldDefendMode",0);
		A_SetInventory("EWShieldDefendModeExtra",0);
		bREFLECTIVE = 0;
		//bSHIELDREFLECT = 0;
	}
	
	action void A_PHellWarShieldOn()
	{
		A_SetInventory("EWShieldDefendMode",1);
		A_SetInventory("EWShieldDefendModeExtra",0);
		if (random(1,4) == 1) { A_SetInventory("EWShieldDefendModeExtra",1); }
		bREFLECTIVE = 1;
		//bSHIELDREFLECT = 1;
	}
	
	action void A_PHellWarShot()
	{
		int PlayerLevel;
		actor player = players[0].mo;
		int buttons = GetPlayerInput(INPUT_BUTTONS);
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
		A_PHellWarShieldOn();
		invoker.shieldenergy -= invoker.shieldenergycost;

		if (invoker.shieldenergy <= invoker.shieldenergycost)
		{
			if (CountInv("PikeAmmo") > 0)
			{
				A_TakeInventory("PikeAmmo",1);
				if (MiscItem) invoker.shieldenergy += MiscItem.HellWarriorMaxCharge;
				else invoker.shieldenergy += 1000;
			}
		}

		double shotangle = 0;
		double shotangleend = 0;
		double shotangleinc = 0;
		double origangle = angle;
		int maxshots = 1;
		int bounces = (randompick(2,2,2,2,2,2,2,3) + randompick(0,1,1,2) + randompick(0,0,0,0,1));
		string shottype = "EvilWarriorShieldBall";
		if (invoker.IPAttackCheck) 
		{
			shotangle = -45.0;
			shotangleend = 45.0;
			shotangleinc = 3.0;
			maxshots = 29;
			shottype = "EvilWarriorShieldBallIP";
		}
		if (invoker.IPAttackCheck) A_SetAngle(angle+shotangle);
		actor BombShots;
		EEProjectile IPCompat;
		for (int i = 0; i < maxshots; i++)
		{
			if (i && invoker.IPAttackCheck) A_SetAngle(angle+shotangleinc);
			BombShots = A_FireProjectile(shottype, 0, 0, 0, 3); 
			if (BombShots && invoker.IPAttackCheck)
			{
				IPCompat = EEProjectile(BombShots);
				if (IPCompat)
				{
					IPCompat.IPattack = true;
					IPCompat.Speed *= frandompick(0.75,0.875);
					IPCompat.BounceCount = bounces;
				}
			}
		}
		if (invoker.IPAttackCheck) A_SetAngle(origangle);
		invoker.A_CheckIPModeOnUse();
		if (random(1,8) <= 1) { A_AlertMonsters(); }
		A_Recoil(0.875);
	}
	
	action void A_CheckShieldRefire()
	{
		int tic;
		if (invoker.shieldrefire)
		{
			if (random(1,4) <= randompick(1,1,1,2))
			{
				tic = random(2,4);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tic = random(1,2);
			}
			else
			{
				tic = random(3,5);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tic = random(2,3);
			}
		}
		else
		{
			if (random(1,4) <= randompick(1,1,1,2))
			{
				tic = random(3,5);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tic = random(2,3);
			}
			else
			{
				tic = random(4,6);
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) tic = random(3,4);
			}
		}
		if (tic < 1) tic = 1;
		A_SetTics(tic);
	}
	
	States
	{
		Pickup:
			TNT1 A 0 
			{ 
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (player.CountInv("EvilWarriorShield"))
				{
					if (player.CountInv("HellWarriorShieldLevel") < 10)
					{
						player.A_GiveInventory("HellWarriorShieldLevel",1);
						A_FadeOut(1,1);
					}
				}
			}
			Fail;

		Ready:
			EWS4 D 1
			{
				A_WeaponReady(WRF_ALLOWUSER4);
			}
			loop;

		Select:
			EWS4 D 1
			{
				A_SetInventory("EWShieldIdleMode",1);
				A_Raise(12);
			}
			goto Select;

		Deselect:
			EWS4 D 1
			{
				A_SetInventory("EWShieldIdleMode",0);
				A_Lower(12);
			}
			goto Deselect;

		Fire:
			EWS4 A 0
			{
				A_CheckIPState1();
				A_ConfirmIPAttack(191,0,2,15,true);

				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();

				//HellWarriorMaxCharge
				invoker.shieldenergycost = (10 + (player.CountInv("HellWarriorShieldLevel") * 0.6));
				if (invoker.shieldenergy <= invoker.shieldenergycost)
				{
					if (CountInv("PikeAmmo") > 0)
					{
						A_TakeInventory("PikeAmmo",1);
						if (MiscItem) invoker.shieldenergy += MiscItem.HellWarriorMaxCharge;
						else invoker.shieldenergy += 1000;
					}
					else
					{
						return resolvestate("Ready");
					}
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			EWS4 D 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOn();
			}
			EWS4 C 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOn();
			}
			EWS4 B 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOn();
			}
		FireShot:
			EWS4 A 6 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				A_CheckShieldRefire();
				A_SetPitch(pitch + 0.875);
				A_PHellWarShieldOn();
			}
			EWS4 A 2 Bright
			{
				A_PHellWarShot();
			}
			EWS4 A 6 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				A_CheckShieldRefire();
				A_SetPitch(pitch - 0.875);
				A_PHellWarShieldOn();
			}
			EWS4 A 0 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				A_PHellWarShieldOn();
				if (buttons & BT_ATTACK) 
				{
					invoker.shieldrefire = 1;
					A_CheckIPState1();
					A_ConfirmIPAttack(191,0,2,15,true);
					
					//HellWarriorMaxCharge
					invoker.shieldenergycost = (10 + (player.CountInv("HellWarriorShieldLevel") * 0.6));
					if (invoker.shieldenergy <= invoker.shieldenergycost)
					{
						if (CountInv("PikeAmmo") > 0)
						{
							A_TakeInventory("PikeAmmo",1);
							if (MiscItem) invoker.shieldenergy += MiscItem.HellWarriorMaxCharge;
							else invoker.shieldenergy += 1000;
						}
						else
						{
							return resolvestate("Ready");
						}
						return resolvestate(null);
					}
					return resolvestate("FireShot");
				}
				invoker.shieldrefire = 0;
				return resolvestate(null);
			}
		FireEnd:
			EWS4 B 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOn();
			}
			EWS4 C 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOn();
			}
			EWS4 D 2 Bright
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOff();
			}
			Goto Ready;

		AltFire:
			EWS4 DEF 2
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_ForcePlayState4("ShieldGuard");
				A_PHellWarShieldOn();
			}
		AltHold:
			EWS4 G 2 BRIGHT
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_ForcePlayState4("ShieldGuard");
				A_SetInventory("HWShieldBlockHold",1);
				A_WeaponReady(WRF_NOFIRE|WRF_DISABLESWITCH);
				A_PHellWarShieldOn();
			}
			EWS4 G 0 
			{
				A_ForcePlayState4("ShieldGuard");
				if (exex_hwshieldaltfirekeytype == 0)
				{
					If (A_HoldInWeapon(0) == 0) { return resolvestate("AltEnd"); }
					If (A_HoldInWeapon(0) == 1) { return resolvestate("AltHold"); }
					If (A_HoldInWeapon(0) == 2) { return resolvestate("AltEnd"); }
					return resolvestate(null);
				}
				else
				{
					If (A_HoldInWeapon(0) == 2) { return resolvestate("AltEnd"); }
					If (A_HoldInWeapon(0) == 1) { return resolvestate("AltEnd"); }
					If (A_HoldInWeapon(0) == 0) { return resolvestate("AltHold"); }
					return resolvestate(null);
				}
				return resolvestate(null);
			}
			goto AltEnd;
		AltEnd:
			EWS4 FE 2
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_ForcePlayState4("ShieldGuard");
				A_SetInventory("HWShieldBlockHold",0);
				A_PHellWarShieldOn();
			}
			EWS4 D 2
			{
				int PlayerLevel;
				actor player = players[0].mo;
				int buttons = GetPlayerInput(INPUT_BUTTONS);
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				let globalvars = DDGlobalVariables.Get();
				
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) A_SetTics(1);
				A_PHellWarShieldOff();
			}
			Goto Ready;

		Spawn:
			EWSH ABCDEFGH 3
			{
				actor player = players[0].mo;
				if (player.CountInv("EvilWarriorShield"))
				{
					A_SpawnItemEx("EvilWarriorShieldExtraPickup",0,0,0, vel.x,vel.y,vel.z, 0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEVELOCITY,0,tid);
					A_FadeOut(1,1);
				}
			}
			Goto Spawn2;
		Spawn2:
			EWSH I 5
			{
				actor player = players[0].mo;
				if (player.CountInv("EvilWarriorShield"))
				{
					A_SpawnItemEx("EvilWarriorShieldExtraPickupGround",0,0,0, vel.x,vel.y,vel.z, 0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEVELOCITY,0,tid);
					A_FadeOut(1,1);
				}
			}
			loop;
	}
}

class EvilWarriorShieldExtraPickup : CustomInventoryExt
{
	default
	{
		+DONTGIB;
		+INVENTORY.ALWAYSPICKUP;
		Inventory.Pickupsound "Dinah/GetWeapon";
		CustomInventoryExt.PickupVoice true;
		CustomInventoryExt.PickupSound2 "misc/w_pkup";
		CustomInventoryExt.PickupVoice2 false;
		Inventory.PickupMessage "\c[gold]Another \c[sapphire]broken shield\c[gold]... wait did it just assimilate with mine?! Is mine \c[red]stronger\c[gold] now or something?\c- (\cy+20% damage\c-) \cx[Slot 9]\c-";
	}
	
	States
	{
		Spawn:
			EWSH ABCDEFGH 3
			{
				actor player = players[0].mo;
				if (player.CountInv("HellWarriorShieldLevel") >= 10)
				{
					string spawntype = "PikeAmmo";
					if (random(1,8) <= 1) spawntype = "PikeAmmoBig";

					A_SpawnItemEx(spawntype,0,0,0, vel.x,vel.y,vel.z, 0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEVELOCITY,0,tid);
					A_FadeOut(1,1);
				}
			}
			Goto Spawn2;
		Spawn2:
			EWSH I 5
			{
				actor player = players[0].mo;
				if (player.CountInv("HellWarriorShieldLevel") >= 10)
				{
					string spawntype = "PikeAmmo";
					if (random(1,8) <= 1) spawntype = "PikeAmmoBig";

					A_SpawnItemEx(spawntype,0,0,0, vel.x,vel.y,vel.z, 0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEVELOCITY,0,tid);
					A_FadeOut(1,1);
				}
			}
			loop;
			
		Pickup:
			TNT1 A 0 { A_GiveInventory("HellWarriorShieldLevel",1); }
			Stop;
	}
}

class EvilWarriorShieldExtraPickupGround : EvilWarriorShieldExtraPickup
{
	States
	{
		Spawn:
			EWSH I 5
			{
				actor player = players[0].mo;
				if (player.CountInv("HellWarriorShieldLevel") >= 10)
				{
					string spawntype = "PikeAmmo";
					if (random(1,8) <= 1) spawntype = "PikeAmmoBig";

					A_SpawnItemEx(spawntype,0,0,0, vel.x,vel.y,vel.z, 0,SXF_NOCHECKPOSITION|SXF_ABSOLUTEVELOCITY,0,tid);
					A_FadeOut(1,1);
				}
			}
			loop;
			
		Pickup:
			TNT1 A 0 { A_GiveInventory("HellWarriorShieldLevel",1); }
			Stop;
	}
}

class EvilWarriorShieldBall : EEProjectile
{
	default
	{
		Tag "Shield Ball Shredder";
		Radius 6;
		Height 8;
		Speed 8;
		DamageFunction (finaldamagedealt);
		PROJECTILE;
		RenderStyle "Add";
		+RANDOMIZE;
		+RIPPER;
		DamageType "Zap";
		Alpha 0.8;
		Scale 0.4;
		ProjectileKickBack 0;
		SeeSound "hellwarrior/shotfire";
		DeathSound "hellwarrior/shothit";
	}
	
	void A_CalcDmg()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		finaldamagedealt = 1;
		if (target && PlayerPawn(target) && MiscItem)
		{
			finaldamagedealt += floor(MiscItem.TruePlayerLevel * 0.015625);
			finaldamagedealt *= (random(1,4) + floor(MiscItem.TruePlayerLevel * 0.05));
			finaldamagedealt *= (1.0 + (player.CountInv("HellWarriorShieldLevel") * 0.2));
		}
		else
		{
			finaldamagedealt *= random(1,4);
		}
		double rollval;
		int rngroll = random(1,16);
		if (MiscItem) 
		{
			if (rngroll <= 12) rollval = (MiscItem.EWShieldKills * frandompick(0.0005,0.00075,0.00075,0.00075,0.00075,0.00075,0.001));
			else if (rngroll >= 13 && rngroll <= 15) rollval = (MiscItem.EWShieldKills * frandompick(0.01,0.015,0.015,0.015,0.015,0.015,0.02));
			else if (rngroll >= 16) rollval = (MiscItem.EWShieldKills * frandompick(0.002,0.003,0.003,0.003,0.003,0.003,0.004));
			finaldamagedealt *= (1.0 + rollval);
			if (dydudebug_attackstuff) Console.Printf("finaldamagedealt [HWShieldBall] (kills: %d): %d, rollval: %.8f, rngroll: %d", MiscItem.EWShieldKills, finaldamagedealt, rollval, rngroll);
		}
		if (IPattack) finaldamagedealt *= frandompick(2.5,3.75,3.75,3.75,3.75,5.0);
	}
	
	override void PostBeginPlay()
	{
		A_CalcDmg();
		super.PostBeginPlay();
	}
	
	override void Tick()
	{
		A_CalcDmg();
		super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if (dydudebug_shieldcollision) Console.Printf("\cyEvilWarriorShieldBall [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			If (ShieldPartBase(other)) return false;
			if (dydudebug_shieldcollision) Console.Printf("\cyEvilWarriorShieldBall (gametic %d):\c- passive: %s", gametic, GetClassName());
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			If (ShieldPartBase(other)) return false;
			if (dydudebug_shieldcollision) Console.Printf("\cyEvilWarriorShieldBall (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
	
	States
	{
		Spawn:
			GRBA ABCDEFGH 2 Bright;
			Loop;
		Death:
			GRBA AIJKLMN 3 Bright;
			Stop;
	}
}

class EvilWarriorShieldBallIP : EvilWarriorShieldBall
{
	default
	{
		BounceType "Hexen";
		BounceCount 0;
		+DONTREFLECT;
	}
}
