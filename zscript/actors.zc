// Base class [for later use]
class EEBaseZSC : Actor abstract
{
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double oldVelZ;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);

		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Bap') { }
		if (damagetype == 'Cricket') { }
		if (damagetype == 'Bonk') { }
		if (damagetype == 'Lead') { }
		if (damagetype == 'Chop') { }
		if (damagetype == 'Breakfast') { }
		if (damagetype == 'Zap') { }
		if (damagetype == 'Suck') { }
		if (damagetype == 'Dust') { }
		if (damagetype == 'Musak') { }
		if (damagetype == 'Fire') { }
		if (damagetype == 'CherryBomb') { }
		if (damagetype == 'Spinner') { }
		if (damagetype == 'BRocket') { }
		if (damagetype == 'Popper') { }
		if (damagetype == 'Tank') { }
		if (damagetype == 'Boiling') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	void A_NightmarePhase()
	{
		if (GetRenderStyle() == STYLE_Subtract)
		{
			double alphavar = 0.00;
			double alphavarbase = frandom(0.0375,0.0425);
			if (health > 0)
			{
				alphavarbase = frandom(0.0375,0.0425);
			}
			else
			{
				alphavarbase = frandom(0.00375,0.00425);
			}
			nightmarephasetimer = ((level.time + random(-nightmarephaserand,nightmarephaserand)) % 35);
			if (nightmarephasetimer == 0) alphavar = (alphavarbase * 0);
			if (nightmarephasetimer == 1 || nightmarephasetimer == 34) alphavar = (alphavarbase * 1);
			if (nightmarephasetimer == 2 || nightmarephasetimer == 33) alphavar = (alphavarbase * 2);
			if (nightmarephasetimer == 3 || nightmarephasetimer == 32) alphavar = (alphavarbase * 3);
			if (nightmarephasetimer == 4 || nightmarephasetimer == 31) alphavar = (alphavarbase * 4);
			if (nightmarephasetimer == 5 || nightmarephasetimer == 30) alphavar = (alphavarbase * 5);
			if (nightmarephasetimer == 6 || nightmarephasetimer == 29) alphavar = (alphavarbase * 6);
			if (nightmarephasetimer == 7 || nightmarephasetimer == 28) alphavar = (alphavarbase * 7);
			if (nightmarephasetimer == 8 || nightmarephasetimer == 27) alphavar = (alphavarbase * 8);
			if (nightmarephasetimer == 9 || nightmarephasetimer == 26) alphavar = (alphavarbase * 9);
			if (nightmarephasetimer == 10 || nightmarephasetimer == 25) alphavar = (alphavarbase * 10);
			if (nightmarephasetimer == 11 || nightmarephasetimer == 24) alphavar = (alphavarbase * 11);
			if (nightmarephasetimer == 12 || nightmarephasetimer == 23) alphavar = (alphavarbase * 12);
			if (nightmarephasetimer == 13 || nightmarephasetimer == 22) alphavar = (alphavarbase * 13);
			if (nightmarephasetimer == 14 || nightmarephasetimer == 21) alphavar = (alphavarbase * 14);
			if (nightmarephasetimer == 15 || nightmarephasetimer == 20) alphavar = (alphavarbase * 15);
			if (nightmarephasetimer == 16 || nightmarephasetimer == 19) alphavar = (alphavarbase * 16);
			if (nightmarephasetimer == 17 || nightmarephasetimer == 18) alphavar = (alphavarbase * 17);
			A_SetRenderStyle((0.7-alphavar),STYLE_Subtract);
			if (dydudebug_nightmarevisuals) Console.Printf("[%s] alphavar: %.2f (%.2f), nightmarephasetimer: %d", GetClassName(), alpha, alphavar, nightmarephasetimer);
		} 
	}
	
	action state A_CheckSolidFooting(StateLabel label, int flags = CSF_ALL)
	{
		// small optimization: if our z-vel has changed, we aren't standing on something
		if (invoker.oldVelZ != vel.z)
				return null;
		
		// are we standing on solid ground?
		if (abs(pos.z - GetZAt()) <= 1)
		{
				if (flags & CSF_SOLIDGROUND)
						return ResolveState(label);
		}
		
		// are we standing on an actor?
		bool ok; Actor below;
		[ok, below] = TestMobjZ(true);
		if (below)
		{
				if (flags & CSF_SOLIDACTORS)
						return ResolveState(label);
		}
		
		// has our z-velocity not changed?
		if (vel.z == invoker.oldVelZ && (flags & CSF_SOLIDGROUND))
				return ResolveState(label);
		
		// we aren't standing on anything
		return null;
	}
	
	void A_Feathers(string type = "Feather")
	{
		int count;

		if (health > 0)
		{ // Pain
			count = random[Feathers]() < 32 ? 2 : 1;
		}
		else
		{ // Death
			count = 5 + (random[Feathers](0, 3));
		}
		for (int i = 0; i < count; i++)
		{
			Actor mo = Spawn(type, pos + (0, 0, 20), NO_REPLACE);
			if (mo != null)
			{
				mo.target = self;
				mo.Vel.X = Random2[Feathers]() / 256.;
				mo.Vel.Y = Random2[Feathers]() / 256.;
				mo.Vel.Z = 1. + random[Feathers]() / 128.;
				mo.SetState (mo.SpawnState + (random[Feathers](0, 7)));
			}
		}
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

// Base Projectile Class
class EEProjectile : EEBaseZSC abstract
{
	mixin InvWeaponShare;
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	int ipprojid;
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	bool IPattack;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
		}
	}

	override void Tick()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (dydudebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("\c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);

			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		/*
		user_sparksizelevel = MartialArtsMastery + BerserkerFit;
		if (user_sparksizelevel <= 0) { A_SetScale(0.3125); A_FadeTo(0.6875); }
		if (user_sparksizelevel == 1) { A_SetScale(0.375); A_FadeTo(0.75); }
		if (user_sparksizelevel == 2) { A_SetScale(0.4375); A_FadeTo(0.8125); }
		if (user_sparksizelevel == 3) { A_SetScale(0.5); A_FadeTo(0.875); }
		if (user_sparksizelevel == 4) { A_SetScale(0.5625); A_FadeTo(0.9375); }
		if (user_sparksizelevel >= 5) { A_SetScale(0.625); A_FadeTo(1.0); }
		*/
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		//user_sparkscalemulti = (StamUpPerkLevel * 0.05) + (StamUpEXPerkLevel * 0.125);
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("PowerStrengthDD")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	int A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		int result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				BaseSigilMaxHealth = MiscItem.BaseStartMaxHealth;
				MaxHealthTrue =  MiscItem.MaxHealthTrue;
			}
			else return 32;
		}
		else
		{
			return 32;
		}
		
		if (attacktype == 0) // SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 32;
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 300 + random(-150,150); // 150 to 450
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 150 + random(-75,75); // 75 to 225
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 6) // SpectralLightningH2New
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 25 + random(-12,12); // 13 to 37
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 325 + random(-162,162); // 163 to 387
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (dydudebug_sigilatkinfo)
		{
			if (radiustype == 0) Console.Printf("Damage Result: %d", result);
			if (radiustype == 1) Console.Printf("Radius Result: %d", result);
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		double minerror = 0.67;
		double maxerror = 1.34;

		if (radiustype == 0) // Direct Damage is randomized a bit
		{
			minerror = 0.8334;
			maxerror = 1.1667;
			if (playpawn) // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [damage] (%s), %d", AttackerName, attacktype);
				
				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.125); // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.275); // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.45); // +45% damage
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.65); // +65% damage
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.875); // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 2.125); // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 2.4); // +140% damage
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 2.7); // +170% damage
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 3.025); // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 3.375); // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.0625); // +6.25% damage
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.1375); // +13.75% damage
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.225); // +22.5% damage
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.325); // +32.5% damage
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.4375); // +43.75% damage
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.5625); // +56.25% damage
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.70); // +70% damage
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.85); // +85% damage
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 2.0125); // +101.25% damage
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 2.1875); // +118.75% damage
				
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 20);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = result;
				finaldmg = result;
				if (attacktype != 0) finaldmg = floor(finaldmg * random(1,4)); // +STRIFEDAMAGE calculation
				nm = "EntityBoss"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecond"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 2.25);

				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}
		else // Radius is not randomized nearly as much
		{
			minerror = 0.9625;
			maxerror = 1.0375;
			if (playpawn)
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [radius] (%s), %d", AttackerName, attacktype);
				
				if (attacktype != 0)
				{
					if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
					{
						result *= 1.5;
						extradmg1 *= 1.5;
						extradmg2 *= 1.5;
						extradmg3 *= 1.5;
						extradmg4 *= 1.5;
						extradmg5 *= 1.5;
						extradmg6 *= 1.5;
					}
					if (attacktype == 6) // SpectralLightningH2New
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
					{
						result *= 0.75;
						extradmg1 *= 0.75;
						extradmg2 *= 0.75;
						extradmg3 *= 0.75;
						extradmg4 *= 0.75;
						extradmg5 *= 0.75;
						extradmg6 *= 0.75;
					}
					if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
					{
						result *= 2.5;
						extradmg1 *= 2.5;
						extradmg2 *= 2.5;
						extradmg3 *= 2.5;
						extradmg4 *= 2.5;
						extradmg5 *= 2.5;
						extradmg6 *= 2.5;
					}
				}

				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);

				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.03125);
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.06875);
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.1125);
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.1625);
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.21875); 
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 1.28125); 
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 1.35);
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 1.425);
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 1.50625); 
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 1.59375);
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.015625);
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.034375);
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.05625);
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.08125);
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.109375);
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.140625);
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.175);
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.2125);
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 1.253125);
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 1.296875);

				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 20;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 5);
				finaldmg = (finaldmg * hpextradmg3) / 100;

				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}

		if (radiustype == 0) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Damage Total: %d\c-", finaldmg);
			finaldamagedealt = finaldmg;
			return finaldmg;
		}
		if (radiustype == 1) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Radius Total: %d\c-", finaldmg);
			finaldamagedealt2 = finaldmg;
			return finaldmg;
		}
		return 32;
	}
	
	// Handle Fractal Egg Split Offs
	void A_EggGrenades(string eggname = "EggGrenade", double zheight = 2, double zheightadd = 35, double xyvelmin = 6, double xyvelmax = 6, double zvelmin = 6, double zvelmax = 12)
	{
		bool success;
		actor EggShots;
		actor player = players[0].mo;
		if (hitaceiling) { [success, EggShots] = A_ThrowGrenadeAngle(eggname,-zheight,-zheightadd,random(xyvelmin,xyvelmax),random(-zvelmax,-zvelmin),checkspawn:false); }
								else { [success, EggShots] = A_ThrowGrenadeAngle(eggname,zheight,zheightadd,random(xyvelmin,xyvelmax),random(zvelmin,zvelmax),checkspawn:false); }
		if (dydudebug_eggfractals) Console.Printf("\c[blue]success [%s]:\c- %d", GetClassName(), success);
		if (EggShots) // && success) 
		{
			EggShots.target = player; // EggShots.target = self.target;
			if (IPAttack)
			{
				EEProjectile IPCompat; 
				IPCompat = EEProjectile(EggShots);
				if (IPCompat)
				{
					IPCompat.target = player;
					IPCompat.IPattack = true;
				}
			}
			if (EggShots.target && dydudebug_eggfractals) Console.Printf("EggShots.\c[fire]target [\c[sapphire]%s\c-]:\c- %s", GetClassName(), EggShots.target.GetClassName());
		}
	}
	
	// Sigil
	void A_SpectralLightning()
	{
		EEProjectile flash2;

		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = "SpectralLightningV2New";
		else cls = "SpectralLightningV1New";

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}

		flash = Spawn("SpectralLightningV2New", (pos.xy, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}
	}
	
	void A_SpectralLightningTail()
	{
		Actor foo = Spawn("SpectralLightningHTailNew", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			if (target) foo.Target = Target;
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}
	
	void A_SpectralBigBallLightning(string spawntype = "SpectralLightningH3")
	{
		Actor foo;
		EEProjectile foo2;
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle += 180.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle -= 270.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
		}
	}
}

// Base FastProjectile Class
class EEFastProjectile : EEProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

class CFlameMissileNew : EEFastProjectile
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : EEProjectile
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 128, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : EEProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : EEFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class EEPuff : EEProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class EEVisualAImage : EEBaseZSC abstract
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 0.85;
		RenderStyle "Add";
		+NOGRAVITY
		+THRUACTORS
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	States
	{
		Spawn:
			TNT1 AA 1 Bright;
			Stop;
	}
}

class EEProp : EEBaseZSC abstract
{
}

class EECreature : EEBaseZSC abstract
{
	mixin MonsterCollider;
	int bossdeathactivate;
	bool IPAttackSummon;
	double gravitypulsetimer;
	int user_gravitytype;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	void A_DDAFDOrigBossDie()
	{
		actor player = players[0].mo;
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite"))
		{
			ACS_Execute(911,0,0,0,0);
		}
	}
	
	void A_DynamicMusic()
	{
		actor player = players[0].mo;
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite"))
		{
			ACS_Execute(102,0,0,0,0); // Uses the ACS-Based system within the original DD/AFD maps for the dynamic music, as originally coded
		}
		else
		{
			// To be coded eventually V: :V
		}
	}
	
	void A_DiabHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
		{
			A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
		}
		else
		if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 20)
		{
			A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
		}
	}
	
	// Diabloist Gravity Attack
	void A_DiabloistGravityCheck()
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer = 0;
		Actor targ = target;
		if (targ)
		{
			if (random(1,8) <= 3) user_gravitytype = 3;
											 else user_gravitytype = random(1,2);

			Actor playertarg = DDPlayerPawn(target);
			/*if (!playertarg && user_gravitytype != 0)*/ user_gravitytype = 1;
			//Console.Printf("user_gravitytype: %d", user_gravitytype);

			targ.A_StartSound("diabloistgravitystart", CHAN_7);
			bNOTARGETSWITCH = true;
			if (random(1,256) <= (21.3335 + (user_monsterlevel/1.5))) bNOPAIN = true;
			bQUICKTORETALIATE = false;
		}
	}
	
	void A_DiabloistSpawnGravityNodes()
	{
		int user_monsterlevel = CountInv("MonsterLevel");

		gravitypulsetimer = 0;
		if (user_gravitytype == 1 || user_gravitytype == 3) 
		{
			//A_Log("HP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 120) { A_VileTarget("DiabloistGravityHPTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityHPTargeter2"); }
			else { A_VileTarget("DiabloistGravityHPTargeter"); }
		}
		if (user_gravitytype == 2 || user_gravitytype == 3)
		{
			//A_Log("MP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 120) { A_VileTarget("DiabloistGravityManaTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityManaTargeter2"); }
			else { A_VileTarget("DiabloistGravityManaTargeter"); }
		}
		bNOTARGETSWITCH = true;
		bQUICKTORETALIATE = false;
	}
	
	void A_DiabloistGravityPulse(double speed)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer += speed;
		
		if ((level.time % 3) == 0)
		{
			if (bNOPAIN)
			{
				if (random (1,256) <= (8+(user_monsterlevel/(33.4*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
				}
			}
			else
			{
				if (random (1,256) <= (32+(user_monsterlevel/(25*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
				}
			}
		}
		
		if (gravitypulsetimer > 22.5)
		{
			gravitypulsetimer -= 22.5;
			A_StartSound("diabloistgravitypulse", CHAN_7);
		}
	}
	
	void A_DiabloistGravity(int gravitytype)
	{
		actor player = players[0].mo;
		gravitypulsetimer = 0;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue, LevelFactor;
		int basedmgratio;
		int AffectedStat, MultFactor, THEEffect;
		int InvulnerabilityTimer;
		let InvulnItem = PowerInvulnDD(player.FindInventory("PowerInvulnDD"));
		if (!InvulnItem)
		{
			let InvulnItem = PowerInvulnerable(player.FindInventory("PowerInvulnerable"));
		}
		if (InvulnItem) InvulnerabilityTimer = InvulnItem.EffectTics;
		int PrevHealth, PrevMana, PrevInvulnTimer;
		int healthdiff;
		int ptemp1, ptemp2;

		Actor targ = target;
		if (targ && targ.health > 0)
		{
			DDPlayerPawn playertarg;
			playertarg = DDPlayerPawn(target);
			EECreature actortarg;
			actortarg = EECreature(target);
			DDPlayerPawn playerculprit;
			playerculprit = DDPlayerPawn(self);
			EECreature actorculprit;
			actorculprit = EECreature(self);

			/*gravitytype -= 1;
			if (!playertarg && gravitytype != 0)*/ gravitytype = 0;

			A_FaceTarget();
			if (!CheckSight(targ, 0)) return;
			if (playertarg && playertarg.CountInv("PlayerDashing")) return;
			targ.A_StartSound("diabloistgravityend", CHAN_7);

			if (playertarg)
			{
				if (InvulnItem && InvulnerabilityTimer > 0)
				{
					//Console.Printf("gravitytype: %d [Invulnerable]", gravitytype);

					if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.03125;
					if (skill == SKILL_EASY) GravityEffectFactor = 0.0625;
					if (skill == SKILL_NORMAL) GravityEffectFactor = 0.1250;
					if (skill == SKILL_HARD) GravityEffectFactor = 0.1875;
					if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.21875;
					if (gravitytype == 2) GravityEffectFactor *= 2;
					if (random(1,16) == 16) GravityEffectFactor *= 2;

					FinalGravityFactor = 1.000 - GravityEffectFactor;
					GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
					if (GravityEffectFactor > 0.000)
					{
						double PrevInvulnTime = InvulnerabilityTimer;
						PropertyValue = InvulnerabilityTimer;
						PropertyValue = PropertyValue * FinalGravityFactor;
						
						if (PropertyValue < 1) PropertyValue = 1;
						InvulnItem.EffectTics = PropertyValue;
						if (playertarg) playertarg.A_SetBlend("C0 C0 C0",1.25,random(39,40));
						PrevInvulnTime -= PropertyValue;
						PrevInvulnTime /= 35;
						if (playertarg) playertarg.A_Print(String.Format("%1f second[s] of your invulnerablity were sapped!", PrevInvulnTime));
					}
				}
				else
				{
					//Console.Printf("gravitytype: %d", gravitytype);

					if (gravitytype == 0) // HP only
					{
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							/*
							ptemp1 = (630*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("HPPenaltyTimeAdd: %d", ptemp1);
							// HPRegenBonPenTimer
							*/

							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
							if (playertarg) playertarg.A_SetBlend("C0 00 00",1.25,random(39,40));
						}
					}
					/*
					else
					if (gravitytype == 1) // Mana only
					{
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PropertyValue = CallACS("StatCheck",14);
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (630*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("MPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",93,ptemp1,2); // MPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							CallACS("OtherVarSetDECORATE",2,PropertyValue);
							if (playertarg) playertarg.A_SetBlend("00 00 C0",1.25,random(39,40));
						}
					}
					else
					if (gravitytype == 2) // HP & Mana
					{
						// HP Damage
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (420*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("HPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",92,ptemp1,2); // HPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
						}
						
						// MP Damage
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						if (random(1,16) != 16) GravityEffectFactor /= 2;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PropertyValue = CallACS("StatCheck",14);
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (420*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("MPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",93,ptemp1,2); // MPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							CallACS("OtherVarSetDECORATE",2,PropertyValue);
						}
						if (playertarg) playertarg.A_SetBlend("C0 00 C0",1.25,random(39,40));
					}
					// Inflict Possible Blindness
					if (playertarg && random(1,32) <= 1) ACS_NamedExecuteAlways("BuffTimer",0,8,19,random(17,51));
					*/
				}
			}
			else
			{
				if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
				if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
				if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
				if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
				if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;

				LevelFactor = 128;
				if (exex_monsterlevelenabledflags) LevelFactor = 128 - CountInv("MonsterLevel");
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 128;

				FinalGravityFactor = 1.000 - GravityEffectFactor;
				GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
				if (GravityEffectFactor > 0.000)
				{
					PrevHealth = targ.health;
					PropertyValue = PrevHealth;
					PropertyValue *= FinalGravityFactor;
				
					if (PropertyValue < 1) PropertyValue = 1;
					targ.health = PropertyValue;
					healthdiff = (PrevHealth - PropertyValue);
				}
			}
			
			// Print Outs
			if (healthdiff)
			{
				string culprit = GetClassName();
				string victim;
				
				string friendmsg = " \cn(F)\c-";
				string charmmsg = " \cx(C)\c-";
				
				if ((playertarg && (exex_playerdmglog & 1)) || (actortarg && (exex_combatlog & 2)))
				{
					if (playertarg) victim = playertarg.GetClassName();
					if (actortarg) victim = actortarg.GetClassName();

						culprit = GetTag("");
						if (playertarg) victim = playertarg.GetTag("");
						if (actortarg) victim = actortarg.GetTag("");

					string DamageMessage = " \c[white]* ";
					DamageMessage.AppendFormat("\cy%d\c- ", healthdiff);
					DamageMessage.AppendFormat("\c[purple]Gravity\c- ");
					DamageMessage.AppendFormat("\c[red]Damage\c-");
					DamageMessage.AppendFormat(" dealt to \cx%s\c-", victim);
					if (actortarg)
					{
						if (actortarg.health > 0) DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
																 else DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
					}
					if (actortarg && actortarg.bFRIENDLY) 
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" by \cw%s's\c-", culprit);
					if (actorculprit && actorculprit.CountInv("MonsterLevel") >= 0) DamageMessage.AppendFormat(" \cw[L%d]\c-", actorculprit.CountInv("MonsterLevel"));
					if (actorculprit && actorculprit.bFRIENDLY)
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" \czGraviton Glare\c-!");
					if (dydudebug_showgametic) DamageMessage.AppendFormat(" (%d)", gametic);
					
					Console.Printf("%s", DamageMessage);
				}
			}
		}
		bQUICKTORETALIATE = true;
		bNOPAIN = false;
		bNOTARGETSWITCH = false;
	}
	
	
	//============================================================================
	//
	// DragonSeek
	//
	//============================================================================

	private void DragonSeek (double thresh, double turnMax)
	{
		double dist;
		double delta;
		Actor targ;
		int i;
		double bestAngle;
		double angleToSpot, angleToTarget;
		Actor mo;

		targ = tracer;
		if(targ == null)
		{
			return;
		}

		double diff = deltaangle(angle, AngleTo(targ));
		delta = abs(diff);

		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (diff > 0)
		{ // Turn clockwise
			angle = angle + delta;
		}
		else
		{ // Turn counter clockwise
			angle = angle - delta;
		}
		VelFromAngle();

		dist = DistanceBySpeed(targ, Speed);
		if (pos.z + height < targ.pos.z || targ.pos.z + targ.height < pos.z)
		{
			Vel.Z = (targ.pos.z - pos.z) / dist;
		}
		if (targ.bShootable && random[DragonSeek]() < 64)
		{ // attack the destination mobj if it's attackable
			Actor oldTarget;
			
			if (absangle(angle, AngleTo(targ)) < 22.5)
			{
				oldTarget = target;
				target = targ;
				if (CheckMeleeRange ())
				{
					int damage = random[DragonSeek](1, 8) * 10;
					int newdam = targ.DamageMobj (self, self, damage, 'Melee');
					targ.TraceBleed (newdam > 0 ? newdam : damage, self);
					A_StartSound (AttackSound, CHAN_WEAPON);
				}
				else if (random[DragonSeek]() < 128 && CheckMissileRange())
				{
					SpawnMissile(targ, "DragonFireball");		
					A_StartSound (AttackSound, CHAN_WEAPON);
				}
				target = oldTarget;
			}
		}
		if (dist < 4)
		{ // Hit the target thing
			if (target && random[DragonSeek]() < 200)
			{
				Actor bestActor = null;
				bestAngle = 360.;
				angleToTarget = AngleTo(target);
				for (i = 0; i < 5; i++)
				{
					if (!targ.args[i])
					{
						continue;
					}
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					mo = iter.Next ();
					if (mo == null)
					{
						continue;
					}
					angleToSpot = AngleTo(mo);
					double diff = absangle(angleToSpot, angleToTarget);
					if (diff < bestAngle)
					{
						bestAngle = diff;
						bestActor = mo;
					}
				}
				if (bestActor != null)
				{
					tracer = bestActor;
				}
			}
			else
			{
				// [RH] Don't lock up if the dragon doesn't have any
				// targs defined
				for (i = 0; i < 5; ++i)
				{
					if (targ.args[i] != 0)
					{
						break;
					}
				}
				if (i < 5)
				{
					do
					{
						i = (random[DragonSeek]() >> 2) % 5;
					} while(!targ.args[i]);
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					tracer = iter.Next ();
				}
			}
		}
	}

	//============================================================================
	//
	// A_DragonInitFlight
	//
	//============================================================================

	void A_DragonInitFlight()
	{
		ActorIterator iter = Level.CreateActorIterator(tid);

		do
		{ // find the first tid identical to the dragon's tid
			tracer = iter.Next ();
			if (tracer == null)
			{
				SetState (SpawnState);
				return;
			}
		} while (tracer == self);
		RemoveFromHash ();
	}

	//============================================================================
	//
	// A_DragonFlight
	//
	//============================================================================

	void A_DragonFlight()
	{
		double ang;

		DragonSeek (4., 8.);
		let targ = target;
		if (targ)
		{
			if(!target.bShootable)
			{ // target died
				target = null;
				return;
			}
			ang = absangle(angle, AngleTo(target));
			if (ang <22.5 && CheckMeleeRange())
			{
				int damage = random[DragonFlight](1, 8) * 8;
				int newdam = targ.DamageMobj (self, self, damage, 'Melee');
				targ.TraceBleed (newdam > 0 ? newdam : damage, self);
				A_StartSound (AttackSound, CHAN_WEAPON);
			}
			else if (ang <= 20)
			{
				SetState (MissileState);
				A_StartSound (AttackSound, CHAN_WEAPON);
			}
		}
		else
		{
			LookForPlayers (true);
		}
	}

	//============================================================================
	//
	// A_DragonFlap
	//
	//============================================================================

	void A_DragonFlap()
	{
		A_DragonFlight();
		if (random[DragonFlight]() < 240)
		{
			A_StartSound ("DragonWingflap", CHAN_BODY);
		}
		else
		{
			PlayActiveSound ();
		}
	}

	//============================================================================
	//
	// A_DragonAttack
	//
	//============================================================================

	void A_DragonAttack()
	{
		SpawnMissile (target, "DragonFireball");
	}


	//============================================================================
	//
	// A_DragonPain
	//
	//============================================================================

	void A_DragonPain()
	{
		A_Pain();
		if (!tracer)
		{ // no destination spot yet
			SetState (SeeState);
		}
	}

	//============================================================================
	//
	// A_DragonCheckCrash
	//
	//============================================================================

	void A_DragonCheckCrash()
	{
		if (pos.z <= floorz)
		{
			SetStateLabel ("Crash");
		}
	}
}

// A subclass for the DD/AFD unique monsters
class DDOrigCreature : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

// A subclass for the DD/AFD unique monsters
class DDAFDNPC : EECreature abstract
{
	default
	{
		MONSTER;
		+FLOORCLIP
		+NOINFIGHTING
		+NOBLOOD
		+DONTTHRUST
		+LOOKALLAROUND
		-COUNTKILL;
	}
}

class DDMiniTank : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

class DDHoganTarget : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

// A subclass for the DD/AFD unique boss-class enemies
class DDOrigBoss : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

class DDMorphedCreature : MorphedMonster abstract
{
}

class ShieldPartBase : EEBaseZSC
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (dydudebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}

		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class NoItemSpawn : EEBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : EEPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class PlayerWhistle : EEBaseZSC
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = MiscItem.TruePlayerLevel;
						if (TruePlayerLevel >= 25) dmg = random(2,4);
						if (TruePlayerLevel >= 50) dmg = random(3,4);
						if (TruePlayerLevel >= 75) dmg = random(4,5);
						if (TruePlayerLevel >= 100) dmg = random(5,5);
						if (TruePlayerLevel >= 125) dmg = random(6,7);
						if (TruePlayerLevel >= 150) dmg = random(7,7);
						if (TruePlayerLevel >= 175) dmg = random(8,9);
						if (TruePlayerLevel >= 200) dmg = random(9,9);
						dmg += (TruePlayerLevel * frandompick(0.1875,0.25,0.3125));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("PowerStrengthDD")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				if (target.GetClassName() == "DinahPlayer")
				{
					A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
					A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
				}
			}
			TNT1 A 1 
			{
				if (target && target.GetClassName() == "DinahPlayer")
				{
					A_AlertMonsters();
				}
			}
			stop;
	}
}

class BatNew : EEBaseZSC replaces Bat
{
	Default
	{
		Speed 5;
		Radius 3;
		Height 3;
		+NOBLOCKMAP +NOGRAVITY +MISSILE
		+NOTELEPORT +CANPASS
	}

	States
	{
		Spawn:
			ABAT ABC 2 A_BatMove;
			Loop;
		Death:
			ABAT A 2;
			Stop;
	}
	
	void A_BatMove()
	{
		if (special2 < 0)
		{
			SetStateLabel ("Death");
		}
		special2 -= 2;		// Called every 2 tics

		double newangle;
		if (random[BatMove]() < 128)
		{
			newangle = Angle + args[4];
		}
		else
		{
			newangle = Angle - args[4];
		}

		// Adjust velocity vector to new direction
		VelFromAngle(Speed, newangle);

		if (random[BatMove]() < 15)
		{
			A_StartSound ("BatScream", CHAN_VOICE, CHANF_DEFAULT, 1, ATTN_IDLE);
		}

		// Handle Z movement
		if (target)
		{
			SetZ(target.pos.Z + 2 * BobSin(args[0]));
			args[0] = (args[0] + 3) & 63;	
		}
	}
}

class PoisonCloudEE : EEBaseZSC replaces PoisonCloud
{
	Default
	{
		Tag "Poisonous Mushroom Bog";
		Radius 20;
		Height 30;
		Mass 0x7fffffff;
		+NOBLOCKMAP +NOGRAVITY +DROPOFF
		+NODAMAGETHRUST
		+DONTSPLASH +FOILINVUL +CANBLAST +BLOODLESSIMPACT +BLOCKEDBYSOLIDACTORS +FORCEZERORADIUSDMG +OLDRADIUSDMG
		RenderStyle "Translucent";
		Alpha 0.6;
		DeathSound "PoisonShroomDeath";
		DamageType "PoisonCloud";
	}

	States
	{
		Spawn:
			PSBG D 1;
			PSBG D 1 A_Scream;
			PSBG DEEEFFFGGGHHHII 2 A_PoisonBagDamage;
			PSBG I 2 A_PoisonBagCheck;
			PSBG I 1 A_PoisonBagCheck;
			Goto Spawn + 3;
		Death:
			PSBG HG 7;
			PSBG FD 6;
			Stop;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override void BeginPlay ()
	{
		Vel.X = MinVel; // missile objects must move to impact other objects
		special1 = random[PoisonCloud](24, 31);
		special2 = 0;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim.player)
		{
			DDPlayerPawn playpawn;
			playpawn = DDPlayerPawn(victim);
			bool mate = (target != null && victim.player != target.player && victim.IsTeammate (target));
			bool dopoison;
			
			if (!mate)
			{
				dopoison = victim.player.poisoncount < 4;
			}
			else
			{
				dopoison = victim.player.poisoncount < (int)(4. * level.teamdamage);
			}

			if (dopoison)
			{
				damage = random[PoisonCloud](15, 30);
				if (mate)
				{
					damage = (int)(damage * level.teamdamage);
				}
				// Handle passive damage modifiers (e.g. PowerProtection)
				damage = victim.GetModifiedDamage(damagetype, damage, true);
				// Modify with damage factors
				damage = victim.ApplyDamageFactor(damagetype, damage);
				if (damage > 0)
				{
					victim.player.PoisonDamage (self, random[PoisonCloud](15, 30), false); // Don't play painsound

					// If successful, play the poison sound.
					if (victim.player.PoisonPlayer (self, self.target, 50))
					{
						if (playpawn) playpawn.A_DDPain();
						else victim.A_StartSound ("*poison", CHAN_VOICE);
					}
				}
			}	
			return -1;
		}
		else if (!victim.bIsMonster)
		{ // only damage monsters/players with the poison cloud
			return -1;
		}
		return damage;
	}
	
	//===========================================================================
	//
	// A_PoisonBagCheck
	//
	//===========================================================================

	void A_PoisonBagCheck()
	{
		if (--special1 <= 0)
		{
			SetStateLabel("Death");
		}
	}

	//===========================================================================
	//
	// A_PoisonBagDamage
	//
	//===========================================================================

	void A_PoisonBagDamage()
	{
		A_Explode(4, 40);
		AddZ(BobSin(special2) / 16);
		special2 = (special2 + 1) & 63;
	}
}

// Practice Target
class PracticeTarget : EECreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright;
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) targetdummyhitcooldown--;
				if (targetdummyhitcooldown == 0) { A_EEHealThing(10000000, SpawnHealth(), 1); }
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : EECreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+SOLID;
		+NOPAIN;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright;
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) targetdummyhitcooldown--;
				if (targetdummyhitcooldown == 0) { A_EEHealThing(10000000, SpawnHealth(), 1); }
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}