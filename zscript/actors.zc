// Base class [for later use]
class EEBaseZSC : Actor abstract
{
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	
	int projprevdmg;
	int monsprevdmg;
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double temp1, temp2;
	double expshare;
	int user_legendaryevolved;
	int user_paintomissile;
	int user_chargechance;
	int user_Fuse;
	int user_fusemax;
	int user_spread, user_spread1, user_spread2;
	int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
	int user_defendtimer, user_defendtimermax, user_defendcycles;
	int user_statsbaseextra;
	int bullet_tracer_mode;
	int user_icekilledtimes;
	int chasetimer;
	int jumpchasetimer;
	int jumptimer;
	double basescalex, basescaley;
	double basealpha;
	int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPLowBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (dydudebug_dospecialdmg) Console.Printf("DoSpecialDamage: EEBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		
		damage = super.DoSpecialDamage(target, damage, damagetype);
		
		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Bap') { }
		if (damagetype == 'Cricket') { }
		if (damagetype == 'Bonk') { }
		if (damagetype == 'Lead') { }
		if (damagetype == 'Chop') { }
		if (damagetype == 'Breakfast') { }
		if (damagetype == 'Zap') { }
		if (damagetype == 'Suck') { }
		if (damagetype == 'Dust') { }
		if (damagetype == 'Musak') { }
		if (damagetype == 'Fire') { }
		if (damagetype == 'CherryBomb') { }
		if (damagetype == 'Spinner') { }
		if (damagetype == 'BRocket') { }
		if (damagetype == 'Popper') { }
		if (damagetype == 'Tank') { }
		if (damagetype == 'Boiling') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	bool A_CheckDDGame()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	bool IfPlayerDist(int distance, int dimension)
	{
		actor player = players[0].mo;
		if (dimension <= 0)
		{
			if (Distance2D(player) <= distance) return true;
		}
		else
		{
			if (Distance3D(player) <= distance) return true;
		}
		return false;
	}
	
	int A_EnemyRailgunDamage(int base = 0)
	{
		int damage = base;
		int charge = CountInv("RailgunCharge");
		double chargefactor = (((charge * 2) + (charge * 0.3334)) * (0.10 + (charge * 0.01)));
		damage *= chargefactor;
		if (damage < (base * 0.5)) damage = (base * 0.5);

		// if () Console.Printf("Damage: %d, [Base: %d], [Charge: %d% / ChargeFactor: %d%", damage, base, charge, chargefactor);
		return damage;
	}
	
	void A_EECustomMeleeAttack(int damage = 0, sound meleesound = "", sound misssound = "", name damagetype = "none", bool bleed = true, bool facetarg = true)
	{
		if (damagetype == 'None') damagetype == 'Melee';

		if (!target) return;
		else
		{
			if (facetarg) A_FaceTarget();
			if (CheckMeleeRange())
			{
				if (meleesound) A_StartSound(meleesound,CHAN_WEAPON,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
				int newdam = target.DamageMobj(self, self, damage, damagetype);
				if (bleed && newdam > 0) target.TraceBleed (newdam > 0 ? newdam : damage, self);
			}
			else
			{
				if (misssound) A_StartSound(misssound,CHAN_WEAPON,CHANF_DEFAULT,1.0,ATTN_NORM,1.0);
			}
		}
		return;
	}
	
	void A_PrintPowerupDDTNoRPG(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (A_CheckDDGame())
		{
			if (!exex_expenabled)
			{
				player.A_StartSound("player/statsup8",324,CHANF_DEFAULT,frandom(0.335,0.5),ATTN_NORM,frandom(0.8,1.25));
				player.A_StartSound("player/statsup",325,CHANF_DEFAULT,frandom(0.90,1.10),ATTN_NORM,frandom(0.9,1.125));
				player.A_StartSound("stats/allcompletion",326,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.8,1.2));
				if (type == 0) player.A_PrintBold(String.Format("\c[fire]New power wells up from within!\n\n\c[fire]HP, HP Regen/Degen, Attack, Defense, Movement Speed,\n\c[fire]Jump Power, Dash Meter, Air Meter, Inventory/Ammo Limits, etc. Increased!"), frandom(2.1,2.4));
				player.A_SetBlend("00 00 FF",0.3,random(65,90),"00 00 FF",0.0);
			}
		}
	}
	
	action int A_GetArmorAmt()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		name armorclasstype = "KGArmor";
		
		int amt = 0;
		if (player) amt = player.CountInv(armorclasstype);

		return amt;
	}

	void A_NightmarePhase()
	{
		if (GetRenderStyle() == STYLE_Subtract)
		{
			double alphavar = 0.00;
			double alphavarbase = frandom(0.0375,0.0425);
			if (health > 0)
			{
				alphavarbase = frandom(0.0375,0.0425);
			}
			else
			{
				alphavarbase = frandom(0.00375,0.00425);
			}
			nightmarephasetimer = ((level.time + random(-nightmarephaserand,nightmarephaserand)) % 35);
			if (nightmarephasetimer == 0) alphavar = (alphavarbase * 0);
			if (nightmarephasetimer == 1 || nightmarephasetimer == 34) alphavar = (alphavarbase * 1);
			if (nightmarephasetimer == 2 || nightmarephasetimer == 33) alphavar = (alphavarbase * 2);
			if (nightmarephasetimer == 3 || nightmarephasetimer == 32) alphavar = (alphavarbase * 3);
			if (nightmarephasetimer == 4 || nightmarephasetimer == 31) alphavar = (alphavarbase * 4);
			if (nightmarephasetimer == 5 || nightmarephasetimer == 30) alphavar = (alphavarbase * 5);
			if (nightmarephasetimer == 6 || nightmarephasetimer == 29) alphavar = (alphavarbase * 6);
			if (nightmarephasetimer == 7 || nightmarephasetimer == 28) alphavar = (alphavarbase * 7);
			if (nightmarephasetimer == 8 || nightmarephasetimer == 27) alphavar = (alphavarbase * 8);
			if (nightmarephasetimer == 9 || nightmarephasetimer == 26) alphavar = (alphavarbase * 9);
			if (nightmarephasetimer == 10 || nightmarephasetimer == 25) alphavar = (alphavarbase * 10);
			if (nightmarephasetimer == 11 || nightmarephasetimer == 24) alphavar = (alphavarbase * 11);
			if (nightmarephasetimer == 12 || nightmarephasetimer == 23) alphavar = (alphavarbase * 12);
			if (nightmarephasetimer == 13 || nightmarephasetimer == 22) alphavar = (alphavarbase * 13);
			if (nightmarephasetimer == 14 || nightmarephasetimer == 21) alphavar = (alphavarbase * 14);
			if (nightmarephasetimer == 15 || nightmarephasetimer == 20) alphavar = (alphavarbase * 15);
			if (nightmarephasetimer == 16 || nightmarephasetimer == 19) alphavar = (alphavarbase * 16);
			if (nightmarephasetimer == 17 || nightmarephasetimer == 18) alphavar = (alphavarbase * 17);
			A_SetRenderStyle((0.7-alphavar),STYLE_Subtract);
			if (dydudebug_nightmarevisuals) Console.Printf("[%s] alphavar: %.2f (%.2f), nightmarephasetimer: %d", GetClassName(), alpha, alphavar, nightmarephasetimer);
		} 
	}
	
	action state A_CheckSolidFooting(StateLabel label, int flags = CSF_ALL)
	{
		// small optimization: if our z-vel has changed, we aren't standing on something
		if (invoker.oldVelZ != vel.z)
				return null;
		
		// are we standing on solid ground?
		if (abs(pos.z - GetZAt()) <= 1)
		{
				if (flags & CSF_SOLIDGROUND)
						return ResolveState(label);
		}
		
		// are we standing on an actor?
		bool ok; Actor below;
		[ok, below] = TestMobjZ(true);
		if (below)
		{
				if (flags & CSF_SOLIDACTORS)
						return ResolveState(label);
		}
		
		// has our z-velocity not changed?
		if (vel.z == invoker.oldVelZ && (flags & CSF_SOLIDGROUND))
				return ResolveState(label);
		
		// we aren't standing on anything
		return null;
	}
	
	void A_Feathers(string type = "Feather")
	{
		int count;

		if (health > 0)
		{ // Pain
			count = random[Feathers]() < 32 ? 2 : 1;
		}
		else
		{ // Death
			count = 5 + (random[Feathers](0, 3));
		}
		for (int i = 0; i < count; i++)
		{
			Actor mo = Spawn(type, pos + (0, 0, 20), NO_REPLACE);
			if (mo != null)
			{
				mo.target = self;
				mo.Vel.X = Random2[Feathers]() / 256.;
				mo.Vel.Y = Random2[Feathers]() / 256.;
				mo.Vel.Z = 1. + random[Feathers]() / 128.;
				mo.SetState (mo.SpawnState + (random[Feathers](0, 7)));
			}
		}
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
	
	void A_GenericFreezeDeath()
	{
		A_SetTranslation('Ice');
		A_FreezeDeath();
	}
	
	bool A_CheckIfCCIllusion()
	{
		if (bNOBLOOD == true && 
				bNOPAIN == true &&
				bNOTARGETSWITCH == true &&
				bNOINFIGHTING == true &&
				bFULLVOLACTIVE == false && 
				bFULLVOLDEATH == false &&
				bBOSS == false) return true;
		
		return false;
	}
	
	
	// A recreation of how the dispersal of CCard's illusions work. Added for suicide-bomber enemies so they don't actually go into their explosion states and forces their dispersal
	void A_CCIllusionDisperse()
	{
		string nm, nn, no, np;
		nm = "CCards_Actor_IllusionBreak";
		nn = "CCards_Actor_Smoke";
		for (int i = 0; i < 4 + radius / 10; i++)
		{
			A_SpawnItemEx(nm);
			A_SpawnItemEx(nn, random(0, radius/2), 0, random(8, height+8), 1, 0, frandom(1, 3), random(0,360));
		}
		
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		Actor t;
		
		while (t = Actor(ti.Next()))
		{
			if (t && t.bMISSILE && t.target && t.target == self)
			{
				t.A_SpawnItemEx(nn, 0);
				t.A_Remove(AAPTR_DEFAULT, RMVF_MISSILES);
			}
		}

		A_Remove(AAPTR_DEFAULT);
	}
	
	bool A_CheckCCInvertGrav()
	{
		string nm;
		nm = "CCards_Actor_ReverseGravityBuff";
		if (CountInv(nm) >= 1 && bYFLIP == true) return true;
		
		return false;
	}
	
	actor A_SpawnProjectile(class<Actor> missiletype, double spawnheight = 32, double spawnofs_xy = 0, double angle = 0, int flags = 0, double pitch = 0, int ptr = AAPTR_TARGET)
	{
		double newspawnheight = spawnheight;
		double newangle = angle;
		if (A_CheckCCInvertGrav()) 
		{
			newspawnheight = (default.height - spawnheight);
			newangle = (angle * -1);
			Console.Printf("newspawnheight: %d [%d], newangle: %.4f [%.4f]", newspawnheight, spawnheight, newangle, angle);
		}
		return Super.A_SpawnProjectile(missiletype, newspawnheight, spawnofs_xy, angle, flags, pitch, ptr);
	}
	
	const ADI_FULLAMMO = 1;
	Actor A_DropItem(class<Actor> item, int dropamount = -1, int chance = 256, int flags = 0)
	{
		if (item != NULL && random[DropItem]() <= chance)
		{
			Actor mo;
			double spawnz = 0;

			if (!(Level.compatflags & COMPATF_NOTOSSDROPS))
			{
				int style = sv_dropstyle;
				if (style == 0)
				{
					style = gameinfo.defaultdropstyle;
				}
				if (style == 2)
				{
					spawnz = 24;
				}
				else
				{
					spawnz = Height / 2;
				}
			}
			mo = Spawn(item, pos + (0, 0, spawnz), ALLOW_REPLACE);
			if (mo != NULL)
			{
				mo.bDropped = true;
				mo.bNoGravity = false;	// [RH] Make sure it is affected by gravity
				if (!(Level.compatflags & COMPATF_NOTOSSDROPS))
				{
					mo.TossItem ();
				}
				let inv = Inventory(mo);
				if (inv)
				{
					if (!(flags & ADI_FULLAMMO)) inv.ModifyDropAmount(dropamount);
					inv.bTossed = true;
					if (inv.SpecialDropAction(self))
					{
						// The special action indicates that the item should not spawn
						inv.Destroy();
						return null;
					}
				}
				return mo;
			}
		}
		return NULL;
	}
	
	int A_CalcDamageFormula(int basedmg,
													int baserand,
													double factor1 = 0.005,
													double factor2 = 0.3334,
													double factor3 = 0.1667,
													double levelfactor = 0.005,
													int lvlthreshold1 = 30,
													int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && exex_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - EEProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - EEProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}

	int A_CalcDamageFormula2(int basedmg, 
													 double factor1 = 0.005,
													 int basedmg2 = 1, 
													 double factor2 = 0.3334, 
													 int basedmg3 = 1, 
													 double factor3 = 0.1667, 
													 double levelfactor = 0.005, 
													 int lvlthreshold1 = 30, 
													 int lvlthreshold2 = 60)
	{
		int damage = basedmg;
		if (target && exex_monsterlevelenabledflags)
		{
			int TargLevel = target.CountInv("MonsterLevel");
			if (PlayerPawn(target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}

			damage = basedmg + (TargLevel * (basedmg * factor1));
			if (CountInv("MonsterLevel") >= lvlthreshold1) damage += basedmg2 + (TargLevel * (basedmg2 * factor2));
			if (CountInv("MonsterLevel") >= lvlthreshold2) damage += basedmg3 + (TargLevel * (basedmg3 * factor3));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - EEProjectile] (\c[ice]%s of %s\c[fire]): %d\c- [gametic: %d]", GetClassName(), target.GetClassName(), damage, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = basedmg;
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - EEProjectile] (\c[ice]%s\c[fire]): %d [%d]\c- [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		return damage;
	}

	int A_CalcDamageFormulaEx(int basedmg,
														int baserand,
														double factor1 = 0.005,
														double factor2 = 0.3334,
														double factor3 = 0.1667,
														double levelfactor = 0.005,
														int lvlthreshold1 = 30,
														int lvlthreshold2 = 60)
	{
		if (baserand <= 0) baserand = random(1,8);
		int damage = (basedmg * baserand);
		if (target && target.target && exex_monsterlevelenabledflags)
		{
			int TargLevel = target.target.CountInv("MonsterLevel");
			if (PlayerPawn(target.target))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) TargLevel = MiscItem.TruePlayerLevel;
			}
			
			damage += (TargLevel * ((basedmg * factor1) * baserand));
			if (TargLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (TargLevel * ((basedmg * (factor1 * factor2)) * baserand));
			if (TargLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (TargLevel * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (TargLevel * levelfactor));
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - EEProjectile] (\c[ice]%s of %s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), target.GetClassName(), damage, basedmg, baserand, gametic);
			projprevdmg = damage;
		}
		else
		{
			if (damage != 0) damage = projprevdmg;
			if (damage == 0) damage = (basedmg * baserand);
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormulaEx - EEProjectile] (\c[ice]%s\c[fire]): %d\c-, projprevdmg: %d, [gametic: %d]", GetClassName(), damage, projprevdmg, gametic);
		}
		
		return damage;
	}
	
	bool A_CheckWalkSnd()
	{
		string nm = "CCards_Actor_Ghost";
		if (CountInv(nm)) return false;
		
		return true;
	}
	
	action void A_UCIIHealSpark(actor EEActor, string sparkname = "Heal1SparkAlly", double xscal = 1.0, double yscal = 1.0, string glittertype = "HealGlitter1", int glitterspawns = 0, double gxscal = 1.0, double gyscal = 1.0, double gspeed = 1.0)
	{
		/*
		Vector3 healpos = (EEActor.pos.x, EEActor.pos.y, EEActor.pos.z);
		Vector3 healpos2 = (EEActor.pos.x, EEActor.pos.y, (EEActor.pos.z)+(EEActor.height/2));
		Actor healspark = Spawn("Heal1SparkAlly", healpos, ALLOW_REPLACE); 
		CustomHealSpark iscustomspark;
		if (healspark != null)
		{
			iscustomspark = CustomHealSpark(healspark);
			healspark.SetOrigin(healpos2,false);
			healspark.target = EEActor;
			healspark.scale.x = xscal;
			healspark.scale.y = yscal;
			if (iscustomspark != null)
			{
				iscustomspark.glittertype = glittertype;
				iscustomspark.glitterspawns = glitterspawns;
				iscustomspark.glitterxscale = gxscal;
				iscustomspark.glitteryscale = gyscal;
				iscustomspark.glitterxspeed = gspeed;
				iscustomspark.glitteryspeed = gspeed;
				iscustomspark.glitterzspeed = gspeed;
			}
		}
		*/
	}
}

class EESwitchableDecoration : SwitchableDecoration
{
	
	bool IfPlayerDist(int distance, int dimension)
	{
		actor player = players[0].mo;
		if (dimension <= 0)
		{
			if (Distance2D(player) <= distance) return true;
		}
		else
		{
			if (Distance3D(player) <= distance) return true;
		}
		return false;
	}
}

class SingleTickDecoration : EEBaseZSC abstract
{
	bool ticked;
	
	override void Tick()
	{
		if (!ticked)
		{
			super.Tick();
			ticked = true;
		}
	}
}

class EECustomGib : EEBaseZSC abstract
{
	int deathcounter;
	int fadecounter;
	int ownedgib;

	override void Tick()
	{
		if (GetAge() >= 0 && GetAge() <= 4) { if (target != null) ownedgib = 1; }
		if (ownedgib)
		{
			if (target && target.health > 0) A_FadeOut(0.0625);

			if (exex_gibswillfade)
			{
				int maxage;
				if (exex_gibswillfade > 0) maxage = exex_gibswillfade;
				if (exex_gibswillfade < 0) maxage = exex_gibswillfade * 35;
				if (GetAge() >= maxage)
				{
					fadecounter++;
					A_FadeOut((1.0/random(32,38)),FTF_REMOVE);
					if (fadecounter > 39) Destroy();
					if (dydudebug_deathgibfadedisplays) Console.Printf("\cy%s\c- alpha: \cx%.8f\c- - fadecounter: %d / 40", GetClassName(), alpha, fadecounter);
				}
				else
				{
					if (dydudebug_deathgibfadedisplays) Console.Printf("\cy%s\c- deathcounter: \cx%d\c-", GetClassName(), GetAge());
				}
			}
		}

		//This space for rent.
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}

// Custom Powerups/Items that obey the effect of "AetheriusTimeFreezer" that might be used for monsters [buffs/debuffs/cooldowns]
// Custom Powerups/Items that obey the effect of "AetheriusTimeFreezer" that might be used for monsters [buffs/debuffs/cooldowns]
class EEPowerup : Powerup
{
	override void Tick()
	{
		// Powerups cannot exist outside an inventory
		if (Owner == NULL)
		{
			Destroy();
		}

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("PowerTimeFreezer") ||
				player.CountInv("DDMiscTimeFreezer") ||
				player.CountInv("DebugTimeFreezer") ||
				player.CountInv("TimePotionTimeFreezer") ||
				!player.player.timefreezer)
		{
			//Console.Printf("EffectTics: %d", EffectTics);
			EffectTics--;
		}
		if (EffectTics <= 0)
		{
			Destroy();
		}
	}
}

// Base Projectile Class
class EEProjectile : EEBaseZSC abstract
{
	bool isillusionaryproj;
	int willbevacced;
	int vacgiveamt;
	bool gavevac;
	int user_projtimer;
	float user_ignoreaoeimmunity;
	int saveddmg; // Save damage from things like A_CustomPunch for puffs
	int user_canafflict;
	int user_ailmentmaxchance;
	mixin InvWeaponShare;
	mixin HUDRecovery;
	mixin IPCostCheck;
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	int user_noseektimer;
	
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	int ipprojid;
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	bool IPattack;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	EECreature eeactor;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;

		if (target) 
		{
			playpawn = PlayerPawn(target);
			if (playpawn)
			{
				let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
				if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
			}
			
			if (target.bNOBLOOD == true && 
					target.bNOPAIN == true &&
					target.bNOTARGETSWITCH == true &&
					target.bNOINFIGHTING == true &&
					target.bFULLVOLACTIVE == false && 
					target.bFULLVOLDEATH == false &&
					target.bBOSS == false) isillusionaryproj = true;
					
			let IsPlayer = PlayerPawn(target);
			let IsAMonster = EECreature(target);
			if (IsAMonster)
			{
				OriginalActor = IsAMonster;
				OriginalActorType = IsAMonster.GetClassName();
			}
		}
	}
	
	void A_DDPostPain()
	{
		string nm;
		nm = "JustKicked"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustPunched"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustUppercutted"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustBatDashed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
		nm = "JustShieldDashed"; if (CountInv(nm) > 0) A_SetInventory(nm,0);
	}
	
	override void Tick()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (dydudebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == DDPlayerPawn(target)) REFLECTEDMONSTERPROJ = true;
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("\c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);

			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (dydudebug_dospecialdmg) Console.Printf("DoSpecialDamage: EEProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust" || GetClassName() == "BadKickPuff") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("PowerStrengthDD")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	int A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		int result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				BaseSigilMaxHealth = MiscItem.BaseStartMaxHealth;
				MaxHealthTrue =  MiscItem.MaxHealthTrue;
			}
			else return 32;
		}
		else
		{
			return 32;
		}
		
		if (attacktype == 0) // SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 32;
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 300 + random(-150,150); // 150 to 450
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 150 + random(-75,75); // 75 to 225
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 6) // SpectralLightningH2New
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 25 + random(-12,12); // 13 to 37
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 325 + random(-162,162); // 163 to 387
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (dydudebug_sigilatkinfo)
		{
			if (radiustype == 0) Console.Printf("Damage Result: %d", result);
			if (radiustype == 1) Console.Printf("Radius Result: %d", result);
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		double minerror = 0.67;
		double maxerror = 1.34;

		if (radiustype == 0) // Direct Damage is randomized a bit
		{
			minerror = 0.8334;
			maxerror = 1.1667;
			if (playpawn) // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [damage] (%s), %d", AttackerName, attacktype);
				
				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.125); // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.275); // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.45); // +45% damage
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.65); // +65% damage
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.875); // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 2.125); // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 2.4); // +140% damage
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 2.7); // +170% damage
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 3.025); // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 3.375); // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.0625); // +6.25% damage
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.1375); // +13.75% damage
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.225); // +22.5% damage
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.325); // +32.5% damage
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.4375); // +43.75% damage
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.5625); // +56.25% damage
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.70); // +70% damage
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.85); // +85% damage
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 2.0125); // +101.25% damage
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 2.1875); // +118.75% damage
				
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 20);
				finaldmg = (finaldmg * hpextradmg3) / 100;
				
				if (IPAttack)
				{
					finaldmg *= frandompick(1.25,1.334,1.334,1.334,1.5,1.5,1.5,1.5,1.5,1.5,1.667,1.667,1.667,1.75);
				}
				
				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
																
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = result;
				finaldmg = result;
				if (attacktype != 0) finaldmg = floor(finaldmg * random(1,4)); // +STRIFEDAMAGE calculation
				nm = "EntityBoss"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecond"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 2.25);

				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}
		else // Radius is not randomized nearly as much
		{
			minerror = 0.9625;
			maxerror = 1.0375;
			if (playpawn)
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [radius] (%s), %d", AttackerName, attacktype);
				
				if (attacktype != 0)
				{
					if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
					{
						result *= 1.5;
						extradmg1 *= 1.5;
						extradmg2 *= 1.5;
						extradmg3 *= 1.5;
						extradmg4 *= 1.5;
						extradmg5 *= 1.5;
						extradmg6 *= 1.5;
					}
					if (attacktype == 6) // SpectralLightningH2New
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
					{
						result *= 0.75;
						extradmg1 *= 0.75;
						extradmg2 *= 0.75;
						extradmg3 *= 0.75;
						extradmg4 *= 0.75;
						extradmg5 *= 0.75;
						extradmg6 *= 0.75;
					}
					if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
					{
						result *= 2.5;
						extradmg1 *= 2.5;
						extradmg2 *= 2.5;
						extradmg3 *= 2.5;
						extradmg4 *= 2.5;
						extradmg5 *= 2.5;
						extradmg6 *= 2.5;
					}
				}

				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);

				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.03125);
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.06875);
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.1125);
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.1625);
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.21875); 
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 1.28125); 
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 1.35);
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 1.425);
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 1.50625); 
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 1.59375);
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.015625);
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.034375);
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.05625);
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.08125);
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.109375);
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.140625);
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.175);
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.2125);
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 1.253125);
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 1.296875);

				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 20;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 5);
				finaldmg = (finaldmg * hpextradmg3) / 100;

				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}

		if (radiustype == 0) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Damage Total: %d\c-", finaldmg);
			finaldamagedealt = finaldmg;
			return finaldmg;
		}
		if (radiustype == 1) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Radius Total: %d\c-", finaldmg);
			finaldamagedealt2 = finaldmg;
			return finaldmg;
		}
		return 32;
	}
	
	// Handle Fractal Egg Split Offs
	void A_EggGrenades(string eggname = "EggGrenade", double zheight = 2, double zheightadd = 35, double xyvelmin = 6, double xyvelmax = 6, double zvelmin = 6, double zvelmax = 12)
	{
		bool success;
		actor EggShots;
		actor player = players[0].mo;
		if (IPAttack)
		{
			xyvelmin *= 1.5;
			xyvelmax *= 1.5;
			zvelmin *= 1.25;
			zvelmax *= 1.25;
		}
		if (hitaceiling) { [success, EggShots] = A_ThrowGrenadeAngle(eggname,-zheight,-zheightadd,random(xyvelmin,xyvelmax),random(-zvelmax,-zvelmin),checkspawn:false); }
								else { [success, EggShots] = A_ThrowGrenadeAngle(eggname,zheight,zheightadd,random(xyvelmin,xyvelmax),random(zvelmin,zvelmax),checkspawn:false); }
		if (dydudebug_eggfractals) Console.Printf("\c[blue]success [%s]:\c- %d", GetClassName(), success);
		if (EggShots) // && success) 
		{
			EggShots.target = player; // EggShots.target = self.target;
			if (IPAttack)
			{
				EEProjectile IPCompat; 
				IPCompat = EEProjectile(EggShots);
				if (IPCompat)
				{
					IPCompat.target = player;
					IPCompat.IPattack = true;
				}
			}
			if (EggShots.target && dydudebug_eggfractals) Console.Printf("EggShots.\c[fire]target [\c[sapphire]%s\c-]:\c- %s", GetClassName(), EggShots.target.GetClassName());
		}
	}

	// Handle Bad Fractal Egg Split Offs
	void A_EvilEggGrenades(string eggname = "EvilEggGrenade", double zheight = 2, double zheightadd = 35, double xyvelmin = 6, double xyvelmax = 6, double zvelmin = 6, double zvelmax = 12)
	{
		bool success;
		actor EggShots;
		if (IPAttack)
		{
			xyvelmin *= 1.5;
			xyvelmax *= 1.5;
			zvelmin *= 1.25;
			zvelmax *= 1.25;
		}
		if (hitaceiling) { [success, EggShots] = A_ThrowGrenadeAngle(eggname,-zheight,-zheightadd,random(xyvelmin,xyvelmax),random(-zvelmax,-zvelmin),checkspawn:false); }
								else { [success, EggShots] = A_ThrowGrenadeAngle(eggname,zheight,zheightadd,random(xyvelmin,xyvelmax),random(zvelmin,zvelmax),checkspawn:false); }
		if (dydudebug_eggfractals) Console.Printf("\c[blue]success [%s]:\c- %d", GetClassName(), success);
		if (EggShots) // && success) 
		{
			if (IPAttack)
			{
				EEProjectile IPCompat; 
				IPCompat = EEProjectile(EggShots);
				if (IPCompat)
				{
					IPCompat.target = target;
					IPCompat.IPattack = true;
				}
			}
			if (EggShots.target && dydudebug_eggfractals) Console.Printf("EggShots.\c[fire]target [\c[sapphire]%s\c-]:\c- %s", GetClassName(), EggShots.target.GetClassName());
		}
	}
	
	// Sigil
	void A_SpectralLightning()
	{
		EEProjectile flash2;

		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = "SpectralLightningV2New";
		else cls = "SpectralLightningV1New";

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}

		flash = Spawn("SpectralLightningV2New", (pos.xy, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}
	}
	
	void A_SpectralLightningTail()
	{
		Actor foo = Spawn("SpectralLightningHTailNew", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			if (target) foo.Target = Target;
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}
	
	void A_SpectralBigBallLightning(string spawntype = "SpectralLightningH3")
	{
		Actor foo;
		EEProjectile foo2;
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle += 180.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle -= 270.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
		}
	}
	
	// Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
		double radius;
		double radiuserror;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			radius = 12;
			radius += (PlayerSTR * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			radius = 12;
			radius += (PlayerSTR * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			radius = 20;
			radius += (PlayerSTR * 0.1333333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16;
			radius += (PlayerSTR * 0.125);
			radiuserror = frandom(0.84375,1.15625);
			if (player.CountInv("MAManual")) radius *= 1.334;
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24;
			radius += (PlayerSTR * 0.166667);
			radiuserror = frandom(0.84375,1.15625);
			if (player.CountInv("MAManual")) radius *= 1.334;
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24;
			radius += (PlayerSTR * 0.25);
			radiuserror = frandom(0.84375,1.15625);
			if (player.CountInv("MAManual")) radius *= 1.334;
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36;
			radius += (PlayerSTR * 0.3334);
			radiuserror = frandom(0.84375,1.15625);
			if (player.CountInv("MAManual")) radius *= 1.334;
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		radius = radius * (random(16,17) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);

		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (player.CountInv("PlayingDoom64"))
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}
		
		return radius;
	}
	

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
		int intensity;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0227272727272727);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0227272727272727);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			intensity = randompick(0,0,0,0,1);
			intensity += (PlayerSTR * 0.033334);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.03125);
			if (player.CountInv("MAManual")) intensity *= 1.334;
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0416666666666667);
			if (player.CountInv("MAManual")) intensity *= 1.334;
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0625);
			if (player.CountInv("MAManual")) intensity *= 1.334;
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0833333333333333);
			if (player.CountInv("MAManual")) intensity *= 1.334;
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		intensity = intensity * random(8,9) / 8;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) 
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
		int duration;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerSTR * 0.0178571428571429);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerSTR * 0.0178571428571429);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			duration = random(4,5);
			duration += (PlayerSTR * 0.0625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration += (PlayerSTR * 0.025);
			if (player.CountInv("MAManual")) duration *= 1.334;
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration += (PlayerSTR * 0.0357142857142857);
			if (player.CountInv("MAManual")) duration *= 1.334;
		}
		else
		if (attacktype == 5) // ?
		{
			duration = 6;
			duration += (PlayerSTR * 0.0714285714285714);
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration += (PlayerSTR * 0.05);
			if (player.CountInv("MAManual")) duration *= 1.334;
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration += (PlayerSTR * 0.0714285714285714);
			if (player.CountInv("MAManual")) duration *= 1.334;
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;

		duration = duration * random(8,9) / 8;
		int charduration = duration;
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, bersduration, duration);
		}
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int TruePlayerLevel = A_GetPlayerLvlProj(1);
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
		int tremrad;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			tremrad = 224;
			tremrad += (PlayerSTR * 0.875);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			tremrad = 224;
			tremrad += (PlayerSTR * 0.875);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			tremrad = 288;
			tremrad += (PlayerSTR * 1.125);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad += (PlayerSTR);
			if (player.CountInv("MAManual")) tremrad *= 1.334;
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad += (PlayerSTR * 1.25);
			if (player.CountInv("MAManual")) tremrad *= 1.334;
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad += (PlayerSTR * 1.75);
			if (player.CountInv("MAManual")) tremrad *= 1.334;
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad += (PlayerSTR * 3.5);
			if (player.CountInv("MAManual")) tremrad *= 1.334;
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		tremrad = tremrad * random(8,9) / 8;
		int chartremrad = tremrad;
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, berstremrad, tremrad);
		}
		return tremrad;
	}
	
	void A_HadesSphereExplode(int basedmg = 112, int baserad = 112)
	{
		int newdmg = basedmg;
		int newrad = baserad;
		if (target)
		{
			int maxhp;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp = (target.SpawnHealth() + target.Stamina);
			else maxhp = target.SpawnHealth();
			maxhp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0111111112)); // +100% damage every ~90 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0037037037333333)); // +33.4% damage every ~90 levels
				maxhp += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0018518518666667)); // +16.67% damage every ~90 levels
				maxhp += temp;
			}
			maxhp *= 0.25; // +100% damage every ~180 levels
			newdmg += maxhp;
			EECreature HSFound;
			HSFound = EECreature(target);
			int healthleft;
			if (HSFound) healthleft = HSFound.hsexphealth;
			healthleft *= (1.0 + (target.CountInv("MonsterLevel") * 0.0222222223)); // +100% damage every ~45 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0074074074333333)); // +33.4% damage every ~45 levels
				healthleft += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0037037037166667)); // +16.7% damage every ~45 levels
				healthleft += temp;
			}
			healthleft *= 0.5;
			newdmg += healthleft;

			int maxhp2;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp2 = (target.SpawnHealth() + target.Stamina);
			else maxhp2 = target.SpawnHealth();
			maxhp2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.005555556)); // +100% radius every ~180 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.001851852)); // +33.4% radius every ~180 levels
				maxhp2 += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if ((target.SpawnHealth() + target.Stamina) > 0) temp = (target.SpawnHealth() + target.Stamina);
				else temp = target.SpawnHealth();
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.000925926)); // +16.7% radius every ~180 levels
				maxhp2 += temp;
			}
			maxhp2 *= 0.125;
			newrad += maxhp2;
			HSFound = EECreature(target);
			int healthleft2;
			if (HSFound) healthleft2 = HSFound.hsexphealth;
			healthleft2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.011111112)); // +100% radius every ~90 levels
			if (target.CountInv("MonsterLevel") > 30) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.003703704)); // +33.4% radius every ~90 levels
				healthleft2 += temp;
			}
			if (target.CountInv("MonsterLevel") > 60) 
			{
				int temp;
				if (HSFound) temp = HSFound.hsexphealth;
				temp *= (1.0 + (target.CountInv("MonsterLevel") * 0.001851852)); // +16.7% radius every ~90 levels
				healthleft2 += temp;
			}
			healthleft2 *= 0.25;
			newrad += healthleft2;
			
			//if (dydudebug_showmiscdmginformation) Console.Printf("NewDmg: %d (%d), NewRad: %d (%d), MaxHP: %d, HealthLeft: %d, MaxHP2: %d, HealthLeft2: %d", newdmg, basedmg, newrad, baserad, maxhp, healthleft, maxhp2, healthleft2);
		}
		A_Explode(newdmg,newrad,0,(newrad*0.334));
	}
	

	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}

	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the retarget parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If  0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}

	void A_EESeekerBounce(int timerset = 6, int randomset = 0, bool clearpointers = false)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			if (clearpointers) A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}
	
	void A_EESeekerMissile(int threshold, int turnmax, int flags = 0, int chance = 50, int distance = 10)
	{
		if (user_noseektimer > 0) user_noseektimer--;
		if (user_noseektimer <= 0) A_SeekerMissile(threshold,turnmax,flags,chance,distance);
	}
	
	void A_VacUpProjectile()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		if (!gavevac)
		{
			if (vacgiveamt > 0)
			{
				vacgiveamt *= exex_supervacbagunitmulti;
				player.A_StartSound("VacDed",210,CHANF_DEFAULT,frandom(0.75,0.90),ATTN_NORM,frandom(1.8,2.7));
				player.A_GiveInventory("VacAmmoCounter",vacgiveamt);
				//Console.Printf("\c[sapphire]+%d\c- Vacuum Bag Units from \c[orange]%s\c-", vacgive, victim.GetTag());
				Console.Printf("\c[sapphire]+%d\c- Vacuum Bag Units", vacgiveamt);
			}
			else
			{
				Console.Printf("No Bag Units. Not an actual projectile...");
			}
			gavevac = true;
			
			if (willbevacced == 2 && MiscItem && globalvars)
			{
				double IPCostTemp = A_GetIPCost(151);
				IPCostTemp *= frandompick(0.5,0.625,0.625,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.875,0.875,0.875,1.0);
				If (MiscItem.ItemPoints >= IPCostTemp && globalvars.ItemPoints >= IPCostTemp)
				{
					if (!MiscItem.HasHarmonicAnger)
					{
						MiscItem.ItemPoints -= IPCostTemp;
						globalvars.ItemPoints -= IPCostTemp;
						A_IPUseHUD(IPCostTemp);
						if (MiscItem.IPDissipateTimer > 0) MiscItem.IPDissipateTimer *= 0.5;
					}
				}
				IPCostTemp = 0;
				if (exex_ikaripointtechpresstype >= 2 && player && player.CountInv("IPUseMode")) player.A_SetInventory("IPUseMode",0);
			}
			A_Remove(AAPTR_DEFAULT);
		}
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - EEProjectile)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	// D'Sparil Bolt
	void A_BlueSpark()
	{
		for (int i = 0; i < 2; i++)
		{
			Actor mo = Spawn("Sorcerer2FXSpark", pos, ALLOW_REPLACE);
			if (mo != null)
			{
				mo.Vel.X = Random2[BlueSpark]() / 128.;
				mo.Vel.Y = Random2[BlueSpark]() / 128.;
				mo.Vel.Z = 1. + Random[BlueSpark]() / 256.;
			}
		}
	}

	void A_GenWizard()
	{
		Actor mo = Spawn("Wizard", pos, ALLOW_REPLACE);
		if (mo != null)
		{
			mo.AddZ(-mo.Default.Height / 2, false);
			if (!mo.TestMobjLocation ())
			{ // Didn't fit
				mo.ClearCounters();
				mo.Destroy ();
			}
			else
			{ // [RH] Make the new wizards inherit D'Sparil's target
				if (self.target != null)
				{
					mo.CopyFriendliness (self.target, true);
				}

				Vel = (0,0,0);
				SetStateLabel('Death');
				bMissile = false;
				mo.master = target;
				SpawnTeleportFog(pos, false, true);
			}
		}
	}

	// Red Axe [Heretic]
	void A_DripBlood (string missiletype = "Blood")
	{
		double xo = random2[DripBlood]() / 32.0;
		double yo = random2[DripBlood]() / 32.0;
		Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, 0.), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.Vel.X = random2[DripBlood]() / 64.0;
			mo.Vel.Y = random2[DripBlood]() / 64.0;
			mo.Gravity = 1./8;
		}
	}
	
	// Ice Ball Splits
	void A_LichIceImpact(string missiletype = "HeadFX2", int numshots = 8, double zvel = -0.6)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor shard = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (shard != null)
			{
				shard.target = target;
				shard.angle = i*(360.0/numshots);
				shard.VelFromAngle();
				shard.Vel.Z = zvel;
				shard.CheckMissileSpawn(radius);
			}
		}
	}

	// Lich Fire Pillar
	void A_LichFireGrow ()
	{
		health--;
		AddZ(9.);
		if (health == 0)
		{
			RestoreDamage();
			SetStateLabel("NoGrow");
		}
	}
	
	//
	void A_MntrFloorFire(string missiletype = "MinotaurFX3")
	{
		SetZ(floorz);
		double x = Random2[MntrFloorFire]() / 64.;
		double y = Random2[MntrFloorFire]() / 64.;
		
		Actor mo = Spawn(missiletype, Vec2OffsetZ(x, y, floorz), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.target = target;
			mo.Vel.X = MinVel; // Force block checking
			mo.CheckMissileSpawn (radius);
		}
	}

	// Wendigo/IceLich Balls
	void A_IceGuyMissileExplode(string missiletype = "IceGuyFX2", int numshots = 8, double pitch = -0.3)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor mo = SpawnMissileAngleZ (pos.z+3, missiletype, i*45., pitch);
			if (mo)
			{
				mo.target = target;
			}
		}
	}
	
	void A_WraithFX2()
	{
		for (int i = 2; i; --i)
		{
			Actor mo = Spawn ("WraithFX2", Pos, ALLOW_REPLACE);
			if (mo)
			{
				double newangle = random[WraithFX2]() * (360 / 1024.f);
				if (random[WraithFX2]() >= 128)
				{
					newangle = -newangle;
				}
				newangle += angle;
				mo.Vel.X = ((random[WraithFX2]() / 512.) + 1) * cos(newangle);
				mo.Vel.Y = ((random[WraithFX2]() / 512.) + 1) * sin(newangle);
				mo.Vel.Z = 0;
				mo.target = self;
				mo.Floorclip = 10;
			}
		}
	}
	
	// WraithVerge
	void A_CHolyAttack2(string missiletype = "HolySpirit", int spiritnums = 4, int spiritfuse = 105, int spiritfusedm = 85)
	{
		for (int j = 0; j < spiritnums; j++)
		{
			Actor mo = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (!mo)
			{
				continue;
			}
			switch (j)
			{
				// float bob index

				case 0:
					mo.WeaveIndexZ = random[HolyAtk2]() & 7; // upper-left
					break;
				case 1:
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7); // upper-right
					break;
				case 2:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7); // lower-left
					break;
				case 3:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7);
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7);
					break;
			}
			mo.SetZ(pos.z);
			mo.angle = angle + 67.5 - 45.*j;
			mo.Thrust();
			mo.target = target;
			mo.args[0] = 10; // initial turn value
			mo.args[1] = 0; // initial look angle
			if (deathmatch)
			{
				// Ghosts last slightly less longer in DeathMatch
				mo.health = spiritfusedm;
				if (spiritfusedm <= 0) mo.health = 85;
			}
			else
			{
				mo.health = spiritfuse;
				if (spiritfuse <= 0) mo.health = 105;
			}
			if (tracer)
			{
				mo.tracer = tracer;
				mo.bNoClip = true;
				mo.bSkullFly = true;
				mo.bMissile = false;
			}
			HolyTail.SpawnSpiritTail (mo);
		}
	}
	
	// Quietus Sword Flames
	void A_FSwordFlames()
	{
		for (int i = random[FSwordFlame](1, 4); i; i--)
		{
			double xo = (random[FSwordFlame]() - 128) / 16.;
			double yo = (random[FSwordFlame]() - 128) / 16.;
			double zo = (random[FSwordFlame]() - 128) / 8.;
			Spawn ("FSwordFlame", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		}
	}
	
	// DragonFX2
	void A_DragonFX2(string missiletype = "DragonExplosion")
	{
		int delay = 16+(random[DragonFX2]()>>3);
		for (int i = random[DragonFX2](1, 4); i; i--)
		{
			double xo = (random[DragonFX2]() - 128) / 4.;
			double yo = (random[DragonFX2]() - 128) / 4.;
			double zo = (random[DragonFX2]() - 128) / 16.;

			Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.tics = delay + (random[DragonFX2](0, 3)) * i*2;
				mo.target = target;
			}
		}
	}
	
	states
	{
		VaccedUp:
			TNT1 A 0
			{
				//Console.Printf("VaccedUp (EEProjectile)");
				A_VacUpProjectile();
			}
			stop;
	}
}

class EEFireworksProj : EEProjectile
{
	int user_explosion;
	int expflags;
	int TruePlayerLevel;
	
	int A_GetPlayerLevel()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) Level = MiscItem.PlayerLevel;
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLevel - EEFireworksProj)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	double A_CalcTrueExpDmg(double basedmg, double basemul = 0.02, double tier1 = 0.5, double tier2 = 0.5, double tier3 = 0.5, double tier4 = 0.5)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		TruePlayerLevel = A_GetPlayerLevel();
		
		if (CherryBombShot(self))
		{
			if (player.CountInv("CBombUpgrade"))
			{
				if (player.CountInv("CBombUpgrade") == 1) 
				{
					basedmg *= 1.375;
					basemul *= 1.375;
					tier1 *= 1.375;
					tier2 *= 1.375;
					tier3 *= 1.375;
					tier4 *= 1.375;
				}
				if (player.CountInv("CBombUpgrade") == 2) 
				{
					basedmg *= 1.75;
					basemul *= 1.75;
					tier1 *= 1.75;
					tier2 *= 1.75;
					tier3 *= 1.75;
					tier4 *= 1.75;
				}
				if (player.CountInv("CBombUpgrade") >= 3) 
				{
					basedmg *= 2.125;
					basemul *= 2.125;
					tier1 *= 2.125;
					tier2 *= 2.125;
					tier3 *= 2.125;
					tier4 *= 2.125;
				}
			}
		}
		if (TruePlayerLevel) basedmg *= (1.0 + (TruePlayerLevel * basemul));
		if (TruePlayerLevel > 25) basedmg *= (1.0 + ((TruePlayerLevel - 25) * (basemul * tier1)));
		if (TruePlayerLevel > 50) basedmg *= (1.0 + ((TruePlayerLevel - 50) * (basemul * tier2)));
		if (TruePlayerLevel > 75) basedmg *= (1.0 + ((TruePlayerLevel - 75) * (basemul * tier3)));
		if (TruePlayerLevel > 100) basedmg *= (1.0 + ((TruePlayerLevel - 100) * (basemul * tier4)));
		if (dydudebug_rangedmg) Console.Printf("ExpDamage [%s]: %d", GetClassName(), basedmg);
		return basedmg;
	}
}

class EEEffectProjectile : EEProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_InflictHalve(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerHalve"))
		{
			player.SetInventory("PowerHalve",1);
			let BluntItem = PowerHalve(player.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics = basetime;
		}
		else
		{
			let BluntItem = PowerHalve(player.FindInventory("PowerHalve"));
			if (BluntItem) BluntItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/atkdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (dydudebug_inflictstatuseffect) Console.Printf("(A_InflictHalve)");
	}
	
	void A_InflictWeaken(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerWeaken"))
		{
			player.SetInventory("PowerWeaken",1);
			let SapItem = PowerWeaken(player.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics = basetime;
		}
		else
		{
			let SapItem = PowerWeaken(player.FindInventory("PowerWeaken"));
			if (SapItem) SapItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/defdown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (dydudebug_inflictstatuseffect) Console.Printf("(A_InflictWeaken)");
	}
	
	void A_InflictSlow(int basetime = 35, int sndchannel = 401)
	{
		actor player = players[0].mo;
		if (!player.CountInv("PowerSlow"))
		{
			player.SetInventory("PowerSlow",1);
			let SlowItem = PowerSlow(player.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics = basetime;
		}
		else
		{
			let SlowItem = PowerSlow(player.FindInventory("PowerSlow"));
			if (SlowItem) SlowItem.EffectTics += basetime;
		}
		player.A_StartSound("debuff/spddown",sndchannel,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.9,1.1));
		if (dydudebug_inflictstatuseffect) Console.Printf("(A_InflictSlow)");
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile [\c[green]%s\c[orange])", GetClassName());
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == player)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- master == player");
			if (player.CountInv("EWShieldIdleMode") > 0) 
			{
				if (player.CountInv("EWShieldDefendMode") > 0)
				{
					if (player.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		DDPlayerPawn playpawn;
		if (master)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = DDPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

class EEWhirlwind : EEProjectile
{
	default
	{
		Accuracy 8;
		DamageType "Wind";
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int randVal;
		Accuracy = clamp(Accuracy, 1, Accuracy);
		int whirltimer = level.time & (Accuracy-1);
		int whirldmg = 3 * randompick(1,1,1,1,1,1,1,1,2,2,2,3);

		if (!target.bDontThrust)
		{
			target.angle += Random2[WhirlwindDamage]() * (360 / 4096.);
			target.Vel.X += Random2[WhirlwindDamage]() / 64.;
			target.Vel.Y += Random2[WhirlwindDamage]() / 64.;
		}

		if ((level.time & 16) && !target.bBoss && !target.bDontThrust)
		{
			randVal = min(160, random[WhirlwindSeek]());
			target.Vel.Z += randVal / 32.;
			target.Vel.Z = clamp(target.Vel.Z, target.Vel.Z, 12);
		}

		if (whirltimer == 0)
		{
			target.DamageMobj (null, target, whirldmg, 'Wind');
		}
		return -1;
	}

	void A_WhirlwindSeek()
	{
		health -= 3;
		if (health < 0)
		{
			Vel = (0,0,0);
			SetStateLabel("Death");
			bMissile = false;
			return;
		}
		if ((threshold -= 3) < 0)
		{
			threshold = 58 + (random[WhirlwindSeek]() & 31);
			A_StartSound("ironlich/attack3", CHAN_BODY);
		}
		if (tracer && tracer.bShadow)
		{
			return;
		}
		A_SeekerMissile(10, 30);
	}
}

// Base FastProjectile Class
class EEFastProjectile : EEProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
	
	states
	{
		VaccedUp:
			TNT1 A -1
			{
				//Console.Printf("VaccedUp (EEFastProjectile)");
				A_VacUpProjectile();
			}
			stop;
	}
}

class EEEffectFastProjectile : EEFastProjectile
{
	default
	{
		+HITMASTER;
	}
	
	int A_StatusEffectChecker(int basechance)
	{
		if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile [\c[green]%s\c[orange])", GetClassName());
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == player)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- master == player");
			if (player.CountInv("EWShieldIdleMode") > 0) 
			{
				if (player.CountInv("EWShieldDefendMode") > 0)
				{
					if (player.CountInv("EWShieldDefendModeExtra") > 0) 
					{
						user_ailmentmaxchance *= 20;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Extra Guarding]");
					}
					else 
					{
						user_ailmentmaxchance *= 12;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Guarding]");
					}
				}
				else
				{
					user_ailmentmaxchance *= 4;
					if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- HWShield [Equipped but Idle]");
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Health Check");
			if (master.health <= 0) 
			{
				user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Health Is < 0");
			}

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
						if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Evaded/Dashing");
					}
		}

		DDPlayerPawn playpawn;
		if (master)
		{
			if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check");
			playpawn = DDPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found player]: %d", user_canafflict);
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
				if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- Invuln Check [found non-player]: %d", user_canafflict);
			}
		}
		if (dydudebug_inflictstatuseffect) Console.Printf("\c[orange](EEEffectFastProjectile - A_StatusEffectChecker:)\c- user_ailmentmaxchance: %d (basechance: %d), user_canafflict: %d", user_ailmentmaxchance, basechance, user_canafflict);
		return user_ailmentmaxchance;
	}
}

class EEFireworksFastProj : EEFastProjectile
{
	int user_explosion;
	int expflags;
	int TruePlayerLevel;
	
	int A_GetPlayerLevel()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) Level = MiscItem.PlayerLevel;
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLevel - EEFireworksFastProj)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	double A_CalcTrueExpDmg(double basedmg, double basemul = 0.02, double tier1 = 0.5, double tier2 = 0.5, double tier3 = 0.5, double tier4 = 0.5)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		TruePlayerLevel = A_GetPlayerLevel();
		
		if (CherryBombShot(self))
		{
			if (player.CountInv("CBombUpgrade"))
			{
				if (player.CountInv("CBombUpgrade") == 1) 
				{
					basedmg *= 1.375;
					basemul *= 1.375;
					tier1 *= 1.375;
					tier2 *= 1.375;
					tier3 *= 1.375;
					tier4 *= 1.375;
				}
				if (player.CountInv("CBombUpgrade") == 2) 
				{
					basedmg *= 1.75;
					basemul *= 1.75;
					tier1 *= 1.75;
					tier2 *= 1.75;
					tier3 *= 1.75;
					tier4 *= 1.75;
				}
				if (player.CountInv("CBombUpgrade") >= 3) 
				{
					basedmg *= 2.125;
					basemul *= 2.125;
					tier1 *= 2.125;
					tier2 *= 2.125;
					tier3 *= 2.125;
					tier4 *= 2.125;
				}
			}
		}
		if (TruePlayerLevel) basedmg *= (1.0 + (TruePlayerLevel * basemul));
		if (TruePlayerLevel > 25) basedmg *= (1.0 + ((TruePlayerLevel - 25) * (basemul * tier1)));
		if (TruePlayerLevel > 50) basedmg *= (1.0 + ((TruePlayerLevel - 50) * (basemul * tier2)));
		if (TruePlayerLevel > 75) basedmg *= (1.0 + ((TruePlayerLevel - 75) * (basemul * tier3)));
		if (TruePlayerLevel > 100) basedmg *= (1.0 + ((TruePlayerLevel - 100) * (basemul * tier4)));
		if (dydudebug_rangedmg) Console.Printf("ExpDamage [%s]: %d", GetClassName(), basedmg);
		return basedmg;
	}
}

// Base Bullet Tracer Class
class EEBulletTracer : EEFastProjectile
{
	int damagebase;
	default
	{
		Tag "Shot";
		Damagetype "Hitscan";
		DamageFunction (finaldamagedealt);
		Radius 2;
		Height 2;
		Mass 5;
		Speed 160; // 80
		PROJECTILE;
		+DONTREFLECT;
		+NODAMAGETHRUST;
		Renderstyle "Add";
		Alpha 1.0;
		Scale 1.0;
		decal "BulletChip";
	}
	
	override void PostBeginPlay()
	{
		EEFastProjectile.PostBeginPlay();
		A_ScaleVelocity(exex_tracervelmulti);
		
		if (finaldamagedealt <= 0) finaldamagedealt = (5 * random(1,3));
	}
	
	action void A_SpawnTracerTrail(string name = "EEBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay bright;
		Idle:
			TNT1 A 1 bright A_SpawnTracerTrail("EEBulletTracerTrail",6,-2.5);
			loop;
		XDeath:
			TNT1 A 1; //A_SpawnItem("BulletPuff")
			stop;
		Death:
		Crash:
			TNT1 A 1 A_SpawnItem("BulletPuff");
			stop;
	}
}

class EEBulletTracerTrail : EEBaseZSC
{
	default
	{
		Radius 1;
		Height 1;
		Speed 0;
		Damage 0;
		Projectile;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
		+NOCLIP;
		+DONTSPLASH;
		Scale 0.5;
		Renderstyle "Add";
	}
	
	States
	{
		Spawn:
			CTAC A 2 bright;
			stop;
	}
}

class CFlameMissileNew : EEFastProjectile
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : EEProjectile
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 128, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : EEProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : EEFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class EEPuff : EEProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		if (dydudebug_dospecialdmg) Console.Printf("DoSpecialDamage: EEPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class EEFireworksPuff : EEPuff
{
	int user_explosion;
	int expflags;
	int TruePlayerLevel;
	
	int A_GetPlayerLevel()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) Level = MiscItem.PlayerLevel;
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLevel - EEFireworksPuff)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	double A_CalcTrueExpDmg(double basedmg, double basemul = 0.02, double tier1 = 0.5, double tier2 = 0.5, double tier3 = 0.5, double tier4 = 0.5)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		TruePlayerLevel = A_GetPlayerLevel();
		
		if (TruePlayerLevel) basedmg *= (1.0 + (TruePlayerLevel * basemul));
		if (TruePlayerLevel > 25) basedmg *= (1.0 + ((TruePlayerLevel - 25) * (basemul * tier1)));
		if (TruePlayerLevel > 50) basedmg *= (1.0 + ((TruePlayerLevel - 50) * (basemul * tier2)));
		if (TruePlayerLevel > 75) basedmg *= (1.0 + ((TruePlayerLevel - 75) * (basemul * tier3)));
		if (TruePlayerLevel > 100) basedmg *= (1.0 + ((TruePlayerLevel - 100) * (basemul * tier4)));
		if (dydudebug_rangedmg) Console.Printf("ExpDamage [%s]: %d", GetClassName(), basedmg);
		return basedmg;
	}
}

class RocketBase : EEProjectile
{
	default
	{
		Tag "Rocket";
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		Projectile;
		+RANDOMIZE;
		+DEHEXPLOSION;
		+ROCKETTRAIL;
		SeeSound "weapons/rocklf";
		DeathSound "weapons/rocklx";
		Obituary "$OB_MPROCKET"; // "%o rode %k's rocket.";
	}
	States
	{
		Spawn:
			MISL A 1 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/rocklx",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
			}
			MISL B 8 Bright A_Explode();
			MISL C 6 Bright;
			MISL D 4 Bright;
			Stop;
	}
}

class BFGBallBase : EEProjectile
{
	double user_radiusdmg; 
	double user_radiussize; 
	int user_detonationtimer;
	
	default
	{
		Radius 13;
		Height 8;
		Speed 25;
		DamageFunction 100;
		Projectile;
		+RANDOMIZE;
		RenderStyle "Add";
		Alpha 0.75;
		DeathSound "weapons/bfgx";
		Obituary "$OB_MPBFG_BOOM";
	}
	
	States
	{
		Spawn:
			BFS1 AB 4 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/bfgx",CHAN_7);
				A_Quake(1, 12, 0, 768, "nosound/silent");
				A_Quake(5, 12, 0, 512, "nosound/silent");
			}
			BFE1 AB 8 Bright;
			BFE1 C 8 Bright A_BFGSpray();
			BFE1 DEF 8 Bright;
			Stop;
		
		ShotDown:
			TNT1 A 0 
			{
				A_ScaleVelocity(0);
				A_StartSound("weapons/bfgx",CHAN_7, CHANF_DEFAULT, 0.5);
				A_Quake(1, 12, 0, 384, "nosound/silent");
				A_Quake(5, 12, 0, 256, "nosound/silent");
			}
			BFE1 ABCDEF 4 Bright;
			Stop;
	}
}

class EEVisualAImage : EEBaseZSC abstract
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 0.85;
		RenderStyle "Add";
		+NOGRAVITY
		+THRUACTORS
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	States
	{
		Spawn:
			TNT1 AA 1 Bright;
			Stop;
	}
}

class EEProp : EEBaseZSC abstract
{
}

class EECreature : EEBaseZSC abstract
{
	mixin EvolveMonsters;
	mixin MonsterCollider;

	// Gargoyle
	bool extremecrash;
	// Afrit
	const FIREDEMON_ATTACK_RANGE = 64*8.;
	int fdstrafecount;
	// Bishop
	int missilecount;
	int bobstate;
	
	//
	int user_golddrop;
	int cannotres;
	int timesrevivedamonster;
	int timesrevivedpervile;
	int timesrevivedperdiabloist;
	//int timesrevivedperbanshee;
	bool isfractalspawned;
	bool isPEspawned;
	bool isHEspawned;
	bool isHOspawned;
	bool isasummonedclone;
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_autorestimer;
	int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
	int user_presetleveladd, user_presetlevelrand1, user_presetlevelrand2;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	int bossdeathactivate;
	bool IPAttackSummon;
	double gravitypulsetimer;
	int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
	int user_leveltransfer;
	int user_ranktransfer;
	int user_levelpreset;
	int user_rankpreset;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		EECreature.AggressionLevelThreshold 75, 150, 225;
	}
	
	
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	void A_LostSoulChargeWeakness()
	{
		if (GetClassName() == "LostSoul" || GetClassName() == "LostSoulNew") A_SetInventory("DMGWeakness100Percent",1);
		if (GetClassName() == "LostSoulAnnoying") A_SetInventory("DMGWeakness50Percent",1);
		if (GetClassName() == "ForgottenOne") A_SetInventory("DMGWeakness20Percent",1);
	}
	
	void A_UnSetDmgWeaknesses()
	{
		A_SetInventory("DMGWeakness100Percent",0);
		A_SetInventory("DMGWeakness75Percent",0);
		A_SetInventory("DMGWeakness50Percent",0);
		A_SetInventory("DMGWeakness20Percent",0);
	}

	int A_GetPlayerLevel()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) Level = MiscItem.PlayerLevel;
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLevel - EECreature)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void A_CheckTag()
	{
		let globalvars = DDGlobalVariables.Get();
		int monsterlevel = CountInv("MonsterLevel");
		int monsterrating = CountInv("MonsterRating");
		string origtag = default.GetTag();
		if (globalvars)
		{
			if (Teacher_KragClone(self) && globalvars.KilledKragClone) origtag = "Meister Krag (Clone)";
			if (Teacher_QuisClone(self) && globalvars.KilledQuislingClone) origtag = "Meister Quisling (Clone)";
			if (QuisFakeClone(self) && globalvars.KilledQuislingClone) origtag = "Meister Quisling (Clone)";
			if (Teacher_LauritzClone(self) && globalvars.KilledLauritzClone) origtag = "Meister Lauritz (Clone)";
			if (Teacher_JorgClone(self) && globalvars.KilledJorgensenClone) origtag = "Juffrau Jorgensen (Clone)";
			if (Teacher_VokterClone(self) && globalvars.KilledVokterClone) origtag = "Baron Vokter (Clone)";
			if (Tempest_BossClone(self) && globalvars.KilledTempestClone) origtag = "Governor Tempest (Clone)";
			if (Delila_BossClone(self) && globalvars.KilledDelilaClone) origtag = "Delila Dorsey (Clone)";
		}
		
		if (monsterlevel > 0 || exex_enemyscalingplevel)
		{
			origtag.AppendFormat(" \c[gold](L%d)\c-", monsterlevel);
		}
		if (monsterrating > 0)
		{
			if (monsterrating == 8) origtag.AppendFormat(" \c[purple]<SSS>\c-");
			else if (monsterrating == 7) origtag.AppendFormat(" \c[fire]<SS>\c-");
			else if (monsterrating == 6) origtag.AppendFormat(" \c[red][S]\c-");
			else if (monsterrating == 5) origtag.AppendFormat(" \c[brick][A]\c-");
			else if (monsterrating == 4) origtag.AppendFormat(" \c[orange][B]\c-");
			else if (monsterrating == 3) origtag.AppendFormat(" \c[yellow][C]\c-");
			else if (monsterrating == 2) origtag.AppendFormat(" \c[green][D]\c-");
			else if (monsterrating == 1) origtag.AppendFormat(" \c[sapphire][E]\c-");
		}
		SetTag(origtag);
	}
	
	int A_CalcDamageFormula(int basedmg,
													int baserand,
													double factor1 = 0.005,
													double factor2 = 0.3334,
													double factor3 = 0.1667,
													double levelfactor = 0.005,
													int lvlthreshold1 = 30,
													int lvlthreshold2 = 60)
	{
		int damage = (basedmg * baserand);
		if (baserand <= 0) baserand = random(1,8);
		if (exex_monsterlevelenabledflags)
		{
			int CurrLevel = CountInv("MonsterLevel");
			if (PlayerPawn(self))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = A_GetPlayerLevel();
				CurrLevel = TruePlayerLevel;
			}
			damage += (CurrLevel * ((basedmg * factor1) * baserand));
			if (CurrLevel >= lvlthreshold1) damage += ((basedmg * factor2) * baserand) + (CountInv("MonsterLevel") * ((basedmg * (factor1 * factor2)) * baserand));
			if (CurrLevel >= lvlthreshold2) damage += ((basedmg * factor3) * baserand) + (CountInv("MonsterLevel") * ((basedmg * (factor1 * factor3)) * baserand));
			damage *= (1.0 + (CurrLevel * levelfactor));
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula - EECreature] (\c[ice]%s\c[fire]): %d\c-, basedmg: %d, baserand: 1 to %d [gametic: %d]", GetClassName(), damage, basedmg, baserand, gametic);
			monsprevdmg = damage;
		}
		return damage;
	}

	int A_CalcDamageFormula2(int basedmg,
													 double factor1 = 0.005,
													 int basedmg2 = 1,
													 double factor2 = 0.3334,
													 int basedmg3 = 1,
													 double factor3 = 0.1667,
													 double levelfactor = 0.005,
													 int lvlthreshold1 = 30,
													 int lvlthreshold2 = 60)
	{
		int damage = basedmg;
		if (exex_monsterlevelenabledflags)
		{
			int CurrLevel = CountInv("MonsterLevel");
			if (PlayerPawn(self))
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) CurrLevel = MiscItem.TruePlayerLevel;
			}
			damage += (CurrLevel * (basedmg * factor1));
			if (CurrLevel >= lvlthreshold1) damage += basedmg2 + (CurrLevel * (basedmg2 * factor2));
			if (CurrLevel >= lvlthreshold2) damage += basedmg3 + (CurrLevel * (basedmg3 * factor3));
			damage *= (1.0 + (CurrLevel * levelfactor));
			monsprevdmg = damage;
			if (dydudebug_monsterdmgcalc) Console.Printf("\c[fire]damage [A_CalcDamageFormula2 - EECreature] (\c[ice]%s\c[fire]): %d\c- [gametic: %d]", GetClassName(), damage, gametic);
		}
		return damage;
	}
	
	void A_DDAFDOrigBossDie()
	{
		actor player = players[0].mo;
		if (A_CheckDDGame())
		{
			ACS_Execute(911,0,0,0,0);
		}
	}
	
	void A_VileHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		int maxviletimesrevived = exex_maxresperarchvile;
		if (maxviletimesrevived <= 0) maxviletimesrevived = 32;

		if (timesrevivedamonster < maxviletimesrevived)
		{
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
			}
			else
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 30)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
			}
		}
	}
	
	void A_DiabHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		int maxdiabtimesrevived = exex_maxresperdiabloist;
		if (maxdiabtimesrevived <= 0) maxdiabtimesrevived = 32;

		if (timesrevivedamonster < maxdiabtimesrevived)
		{
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
			}
			else
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 30)
			{
				A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
				A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
			}
		}
	}
	
	// Diabloist Gravity Attack
	void A_DiabloistGravityCheck()
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer = 0;
		Actor targ = target;
		if (targ)
		{
			if (random(1,8) <= 3) user_gravitytype = 3;
											 else user_gravitytype = random(1,2);

			Actor playertarg = DDPlayerPawn(target);
			/*if (!playertarg && user_gravitytype != 0)*/ user_gravitytype = 1;
			//Console.Printf("user_gravitytype: %d", user_gravitytype);

			targ.A_StartSound("diabloistgravitystart", CHAN_7);
			bNOTARGETSWITCH = true;
			if (random(1,256) <= (21.3335 + (user_monsterlevel/1.5))) bNOPAIN = true;
			bQUICKTORETALIATE = false;
		}
	}
	
	void A_DiabloistSpawnGravityNodes()
	{
		int user_monsterlevel = CountInv("MonsterLevel");

		gravitypulsetimer = 0;
		if (user_gravitytype == 1 || user_gravitytype == 3) 
		{
			//A_Log("HP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 80) { A_VileTarget("DiabloistGravityHPTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityHPTargeter2"); }
			else { A_VileTarget("DiabloistGravityHPTargeter"); }
		}
		if (user_gravitytype == 2 || user_gravitytype == 3)
		{
			//A_Log("MP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 80) { A_VileTarget("DiabloistGravityManaTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityManaTargeter2"); }
			else { A_VileTarget("DiabloistGravityManaTargeter"); }
		}
		bNOTARGETSWITCH = true;
		bQUICKTORETALIATE = false;
	}
	
	void A_DiabloistGravityPulse(double speed)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer += speed;
		
		if ((level.time % 3) == 0)
		{
			if (bNOPAIN)
			{
				if (random (1,256) <= (8+(user_monsterlevel/(33.4*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
				}
			}
			else
			{
				if (random (1,256) <= (32+(user_monsterlevel/(25*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
				}
			}
		}
		
		if (gravitypulsetimer > 22.5)
		{
			gravitypulsetimer -= 22.5;
			A_StartSound("diabloistgravitypulse", CHAN_7);
		}
	}
	
	void A_DiabloistGravity(int gravitytype)
	{
		actor player = players[0].mo;
		gravitypulsetimer = 0;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue, LevelFactor;
		int basedmgratio;
		int AffectedStat, MultFactor, THEEffect;
		int InvulnerabilityTimer;
		let InvulnItem = PowerInvulnDD(player.FindInventory("PowerInvulnDD"));
		if (!InvulnItem)
		{
			let InvulnItem = PowerInvulnerable(player.FindInventory("PowerInvulnerable"));
		}
		if (InvulnItem) InvulnerabilityTimer = InvulnItem.EffectTics;
		int PrevHealth, PrevMana, PrevInvulnTimer;
		int healthdiff;
		int ptemp1, ptemp2;

		Actor targ = target;
		if (targ && targ.health > 0)
		{
			DDPlayerPawn playertarg;
			playertarg = DDPlayerPawn(target);
			EECreature actortarg;
			actortarg = EECreature(target);
			DDPlayerPawn playerculprit;
			playerculprit = DDPlayerPawn(self);
			EECreature actorculprit;
			actorculprit = EECreature(self);

			/*gravitytype -= 1;
			if (!playertarg && gravitytype != 0)*/ gravitytype = 0;

			A_FaceTarget();
			if (!CheckSight(targ, 0)) return;
			if (playertarg && playertarg.CountInv("PlayerDashing")) return;
			targ.A_StartSound("diabloistgravityend", CHAN_7);

			if (playertarg)
			{
				if (InvulnItem && InvulnerabilityTimer > 0)
				{
					//Console.Printf("gravitytype: %d [Invulnerable]", gravitytype);

					if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.03125;
					if (skill == SKILL_EASY) GravityEffectFactor = 0.0625;
					if (skill == SKILL_NORMAL) GravityEffectFactor = 0.1250;
					if (skill == SKILL_HARD) GravityEffectFactor = 0.1875;
					if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.21875;
					if (gravitytype == 2) GravityEffectFactor *= 2;
					if (random(1,16) == 16) GravityEffectFactor *= 2;

					FinalGravityFactor = 1.000 - GravityEffectFactor;
					GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
					if (GravityEffectFactor > 0.000)
					{
						double PrevInvulnTime = InvulnerabilityTimer;
						PropertyValue = InvulnerabilityTimer;
						PropertyValue = PropertyValue * FinalGravityFactor;
						
						if (PropertyValue < 1) PropertyValue = 1;
						InvulnItem.EffectTics = PropertyValue;
						if (playertarg) playertarg.A_SetBlend("C0 C0 C0",1.25,random(39,40));
						PrevInvulnTime -= PropertyValue;
						PrevInvulnTime /= 35;
						if (playertarg) playertarg.A_Print(String.Format("%1f second[s] of your invulnerablity were sapped!", PrevInvulnTime));
					}
				}
				else
				{
					//Console.Printf("gravitytype: %d", gravitytype);

					if (gravitytype == 0) // HP only
					{
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;

							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
							if (playertarg) playertarg.A_SetBlend("C0 00 00",1.25,random(39,40));
						}
					}
				}
			}
			else
			{
				if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
				if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
				if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
				if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
				if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;

				LevelFactor = 128;
				if (exex_monsterlevelenabledflags) LevelFactor = 128 - CountInv("MonsterLevel");
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 128;

				FinalGravityFactor = 1.000 - GravityEffectFactor;
				GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
				if (GravityEffectFactor > 0.000)
				{
					PrevHealth = targ.health;
					PropertyValue = PrevHealth;
					PropertyValue *= FinalGravityFactor;
				
					if (PropertyValue < 1) PropertyValue = 1;
					targ.health = PropertyValue;
					healthdiff = (PrevHealth - PropertyValue);
				}
			}
			
			// Print Outs
			if (healthdiff)
			{
				string culprit = GetClassName();
				string victim;
				
				string friendmsg = " \cn(F)\c-";
				string charmmsg = " \cx(C)\c-";
				
				if ((playertarg && (exex_playerdmglog & 1)) || (actortarg && (exex_combatlog & 2)))
				{
					if (playertarg) victim = playertarg.GetClassName();
					if (actortarg) victim = actortarg.GetClassName();

						culprit = GetTag("");
						if (playertarg) victim = playertarg.GetTag("");
						if (actortarg) victim = actortarg.GetTag("");

					string DamageMessage = " \c[white]* ";
					DamageMessage.AppendFormat("\cy%d\c- ", healthdiff);
					DamageMessage.AppendFormat("\c[purple]Gravity\c- ");
					DamageMessage.AppendFormat("\c[red]Damage\c-");
					DamageMessage.AppendFormat(" dealt to \cx%s\c-", victim);
					if (actortarg)
					{
						if (actortarg.health > 0) DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
																 else DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
					}
					if (actortarg && actortarg.bFRIENDLY) 
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" by \cw%s's\c-", culprit);
					if (actorculprit && actorculprit.CountInv("MonsterLevel") >= 0) DamageMessage.AppendFormat(" \cw[L%d]\c-", actorculprit.CountInv("MonsterLevel"));
					if (actorculprit && actorculprit.bFRIENDLY)
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" \czGraviton Glare\c-!");
					if (dydudebug_showgametic) DamageMessage.AppendFormat(" (%d)", gametic);
					
					Console.Printf("%s", DamageMessage);
				}
			}
		}
		bQUICKTORETALIATE = true;
		bNOPAIN = false;
		bNOTARGETSWITCH = false;
	}
	
	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_EEWander(int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value5) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEWander]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		A_Wander(flags);
	}

	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_EEChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int NoAtkChance = 0;
		int PerkFactor;
		int SkillFactor;
		string Actorname = GetClassName();

		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			if (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("PowerInvisibility2") ||
					playpawn.CountInv("PowerRavenInvisibility") ||
					playpawn.CountInv("PowerGhost") ||
					playpawn.CountInv("PowerGhost2"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = 8334;
				}
				else
				{
					PerkFactor = 1667;
				}
				if (PerkFactor > 10000) PerkFactor = 10000;
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
			if (playpawn.CountInv("PlayerDashing"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = random(9937,9938);
				}
				else
				{
					PerkFactor = 8750;
				}
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
		}
		
		if (CountInv("ScramblerConfusion"))
		{
			PerkFactor = randompick(2500,3334,3334,3334,3334,3334,5000);
			SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
			NoAtkChance += SkillFactor;
		}
		
		if (dydudebug_showactormoveinfo && NoAtkChance > 0) 
		{
			if (target) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance: %d / 10000, Target: %s \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, target.GetClassName(), tics);
						 else Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance: %d / 10000 \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, tics);
		}
		int BaseWanderChance = 0;
		if (random(1,10000) <= NoAtkChance)
		{
			if (flags & CHF_FASTCHASE) flags &= ~CHF_FASTCHASE;
			if (playpawn && 
				 (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("PowerInvisibility2") ||
					playpawn.CountInv("PowerRavenInvisibility") ||
					playpawn.CountInv("PowerGhost") ||
					playpawn.CountInv("PowerGhost2")))
			{
				PerkFactor = 2500;
				SkillFactor = (10000 - BaseWanderChance) * PerkFactor / 10000;
				BaseWanderChance += SkillFactor;
			}
			if (CountInv("ScramblerConfusion"))
			{
				PerkFactor = randompick(2500,3334,3334,3334,3334,3334,5000);
				SkillFactor = (10000 - BaseWanderChance) * PerkFactor / 10000;
				BaseWanderChance += SkillFactor;
			}
			
			if (random(1,10000) <= BaseWanderChance) 
			{
				A_Wander();
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- A_Wander Succeed", GetClassName(), gametic);
			}
			else 
			{
				A_Chase(null,null,flags);
			}
			
			if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance Succeed \cytics: %d\c-", GetClassName(), gametic, tics);
		}
		else
		{
			A_Chase(melee,missile,flags);
		}
		if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- Default Chase \cytics: %d\c-", GetClassName(), gametic, tics);
	}
	
	void A_EEPain(int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		A_Pain();
		
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1) // SpeedPainChange
		{
			if (random(1,100) <= value5)
			{
				if (value1 <= 0) value1 = random(18,22);
				if (value2 <= 0) value2 = 8;
				
				int extrasteps;
				if (exex_monsterlevelenabledflags) extrasteps = user_monsterlevel / value2;
				specialspeed1 = value1 + extrasteps; // Number of steps to walk fast
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEPain]\c- specialspeed1: %d, basespeedtimer: %d, leveldivisor: %d, ?3: %d, ?4: %d, chanceroll[/100]: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, value4, value5, tics);
			}
		}

		if (GetClassName() == "Diabloist")
		{
			if (bNOTARGETSWITCH) bNOTARGETSWITCH = false;
			if (!bQUICKTORETALIATE) bQUICKTORETALIATE = true;
		}
	}

	void A_FastChaseCalc(int base = 3, int leveldivisor = 24)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		if (exex_monsterlevelenabledflags) { user_fastchaseextra = user_monsterlevel / leveldivisor; }
		user_fastchasechance = base + user_fastchaseextra + user_painfastchase;
		if (dydudebug_monsterspecialai) Console.Printf("Class: %s - \czFastChaseChance: %d (base: %d, leveldivisor: %d)\cz", GetClassName(), user_fastchasechance, base, leveldivisor); 
	}

	// Attempts to mitigate floating-monsters from drifting too out of control when fast-chasing or damaged [like if they get kicked backwards]
	// by slowing them down gradually and then stopping them at a certain interval that won't reset until they get hurt again or they attempt 
	// to fast-chase.
	void A_FloatLook(int time = 16)
	{
		A_Look();
		user_fastchasetimer = time;
		user_painreacttimer = time;
	}

	void A_FloatPain(int settime = 0, int settime2 = 8, int settime2chance = 64, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		A_EEPain(type,value1,value2,value3,value4,value5,value6);
		if (random(1,256) <= settime2chance) user_painreacttimer = settime2; else user_painreacttimer = settime;
	}

	void A_FloatSetFChaseT(int time = 0)
	{
		user_fastchasetimer = time;
	}

	void A_FloatChaseCheck(int time1 = 4, int time2 = 8, int time3 = 12, int time4 = 16, double decelrate1 = 0.5, double decelrate2 = 0.5)
	{
		user_painreacttimer++;
		if (user_painreacttimer == time1) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time2) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time3) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (dydudebug_monsterspecialai) 
		{ 
			if (user_painreacttimer == time1 || user_painreacttimer == time2 || user_painreacttimer == time3 || user_painreacttimer == time4) Console.Printf("Class: %s - \cxFloatPain-painreacttimer: %d\c-", GetClassName(), user_painreacttimer); 
		}
		
		user_fastchasetimer++;
		if (user_fastchasetimer == time1) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time2) { A_ScaleVelocity(decelrate2);}
		if (user_fastchasetimer == time3) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (dydudebug_monsterspecialai) 
		{ 
			if (user_fastchasetimer == time1 || user_fastchasetimer == time2 || user_fastchasetimer == time3 || user_fastchasetimer == time4) Console.Printf("Class: %s - \cwFloatChase-fastchasetimer: %d\c-", GetClassName(), user_fastchasetimer);
		}
	}

	
	void A_HadesTeleport(int minlevel = 45, int minchance = 64)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;
		//if (user_legendaryevolved) minchance *= frandompick(1.25,1.5,1.75,2.0);

		int RandRoll = random(1,1024);
		if (exex_monsterlevelenabledflags)
		{
			A_StopSound (CHAN_WEAPON);
			if (!CountInv("HadesTeleportCooldown")) 
			{
				if (user_monsterlevel >= (minlevel*9))
				{
					if (RandRoll <= (minchance*4)) splittype2 = 2;
				}
				else
				if (user_monsterlevel >= (minlevel*4))
				{
					if (RandRoll <= (minchance*2)) splittype2 = random(1,2);
				}
				else
				if (user_monsterlevel >= minlevel)
				{
					if (RandRoll <= minchance) splittype2 = randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (user_monsterlevel >= (minlevel/2))
				{
					if (RandRoll <= minchance) splittype2 = 1;
				}
			}
		}
		
		if (splittype2 == 1)
		{
			SetStateLabel("Teleport");
		}
		else
		if (splittype2 == 2)
		{
			SetStateLabel("Teleport2");
		}
	}
	void A_HadesTeleportChoose(int minlevel = 90)
	{
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;

		if (exex_monsterlevelenabledflags)
		{
			if (!CountInv("HadesTeleportCooldown")) 
			{
				if (CountInv("MonsterLevel") >= (minlevel*9))
				{
					splittype2 = 2;
				}
				else
				if (CountInv("MonsterLevel") >= (minlevel*4))
				{
					splittype2 = random(1,2);
				}
				else
				if (CountInv("MonsterLevel") >= minlevel)
				{
					randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (CountInv("MonsterLevel") >= (minlevel/2))
				{
					splittype2 = 1;
				}
			}
		}
		
		if (splittype2 == 1)
		{
			SetStateLabel("Teleport");
		}
		else
		if (splittype2 == 2)
		{
			SetStateLabel("Teleport2");
		}
	}

	double XSpread;
	double YSpread;
	void A_ActorGetHitScanXSpread(int type = 0)
	{
		double spread = 0.0;
		double spreadfactor = 1.0;
		int StrifeAccuracyLevel;
		int accuracydebug;

		// Special
		if (type == 101) // Strife Rebel Shots [checking player's accuracy to set their own] :V
		{
			spread = 8.0;
			spreadfactor = 1.0 - (StrifeAccuracyLevel * 0.1);
		}
		
		spread *= spreadfactor;
		if (accuracydebug) Console.Printf("XSpread: %.8f, XSpreadFactor %.8f" ,spread, spreadfactor);
		XSpread = spread;
	}
	
	void A_ActorGetHitScanYSpread(int type = 0)
	{
		double spread = 0.0;
		double spreadfactor = 1.0;
		int StrifeAccuracyLevel;
		int accuracydebug;

		// Special
		if (type == 101) // Strife Rebel Shots [checking player's accuracy to set their own] :V
		{
			spread = 0.0;
			spreadfactor = 1.0 - (StrifeAccuracyLevel * 0.1);
		}
		
		spread *= spreadfactor;
		if (accuracydebug) Console.Printf("YSpread: %.8f, YSpreadFactor %.8f" ,spread, spreadfactor);
		YSpread = spread;
	}

	// Cacodemons' Shadow Split
	void A_ActorStartShadowSplit()
	{
		A_Stop();
		A_StartSound("caco/shadowsplit", CHAN_7, CHANF_DEFAULT, 1, ATTN_NONE, frandom(1.2,1.4));
		A_FaceTarget();
		bSHOOTABLE = 0;
		int user_monsterlevel = CountInv("MonsterLevel");
		
		int nonsolidchance = 1;
		if (GetClassName() == "CacodemonNew") nonsolidchance += (user_monsterlevel / 90);
		if (GetClassName() == "Cacolantern") nonsolidchance += (user_monsterlevel / random(67,68));
		if (GetClassName() == "Abaddon") nonsolidchance += (user_monsterlevel / 45);
		if (GetClassName() == "PainElemental") nonsolidchance += (user_monsterlevel / 45);
		if (random(1,4) <= nonsolidchance) bSOLID = 0;
	}
	void A_ActorEndShadowSplit()
	{
		A_GiveInventory("ShadowSplitCooldown", 1);
		A_Stop();
		bSHOOTABLE = 1;
		if (!bSOLID) bSOLID = 1;
	}

	void A_ActorShadowSplit(int minlevel = 30, int minchance = 256)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;
		int RandRoll = random(1,1024);
		if (exex_monsterlevelenabledflags)
		{
			A_StopSound(CHAN_WEAPON);
			if (!CountInv("ShadowSplitCooldown")) 
			{
				if (user_monsterlevel >= (minlevel*9))
				{
					if (RandRoll <= (minchance*4)) splittype2 = 2;
				}
				else
				if (user_monsterlevel >= (minlevel*4))
				{
					if (RandRoll <= (minchance*2)) splittype2 = random(1,2);
				}
				else
				if (user_monsterlevel >= minlevel)
				{
					if (RandRoll <= minchance) splittype2 = randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (user_monsterlevel >= (minlevel/2))
				{
					if (RandRoll <= (minchance/4)) splittype2 = randompick(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2);
				}
			}
		}

		if (splittype2 == 0)
		{
		}
		else
		if (splittype2 == 1)
		{
			splittype = random(1,4);
			if (splittype == 1) { SetStateLabel("Shadowsplit1"); }
			if (splittype == 2) { SetStateLabel("Shadowsplit2"); }
			if (splittype == 3) { SetStateLabel("Shadowsplit3"); }
			if (splittype == 4) { SetStateLabel("Shadowsplit4"); }
		}
		else
		if (splittype2 == 2)
		{
			splittype = random(1,4);
			if (splittype == 1) { SetStateLabel("Shadowsplit1a"); }
			if (splittype == 2) { SetStateLabel("Shadowsplit2a"); }
			if (splittype == 3) { SetStateLabel("Shadowsplit3a"); }
			if (splittype == 4) { SetStateLabel("Shadowsplit4a"); }
		}
		if (dydudebug_monsterspecialai) Console.Printf("Class: %s - \cuCacos' ShadowSplit --- (Level / RequiredLvl: %d / %d) splittype2: %d, splittype: %d\c-", GetClassName(), user_monsterlevel, minlevel, splittype2, splittype);
	}

	const DEFSKULLSPEED = 20;
	
	void A_SkullAttack(double skullspeed = DEFSKULLSPEED)
	{
		if (target == null) return;

		if (skullspeed <= 0) skullspeed = DEFSKULLSPEED;

		bSkullfly = true;
		A_StartSound(AttackSound, CHAN_VOICE);
		A_FaceTarget();
		VelFromAngle(skullspeed);
		Vel.Z = (target.pos.Z + target.Height/2 - pos.Z) / DistanceBySpeed(target, skullspeed);
	}

	void A_BetaSkullAttack(int basedmg = 1, int randmin = 1, int randmax = 8)
	{
		if (target == null || target.GetSpecies() == self.GetSpecies()) return;
		A_StartSound(AttackSound, CHAN_WEAPON);
		A_FaceTarget();
		
		int damage = 0;
		double dmgfct = 1.0;
		if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 1024))
		{
			//Console.Printf("BetaSoul [1024 Unit Attack]");
			if (random(1,16) <= 15) dmgfct = 1.0;
												 else dmgfct = frandom(0.25,0.5);
		}
		else
		{
			if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 4096))
			{
				//Console.Printf("BetaSoul [4096 Unit Attack]");
				if (random(1,4) <= 1) dmgfct = frandom(0.25,0.5);
												 else dmgfct = 0.0;
			}
		}

		if (exex_monsterlevelenabledflags)
		{
			double inits = frandompick(0.05,0.0625,0.0625,0.075,0.075,0.075,0.075,0.075,0.0875,0.0875,0.10);
			damage += (CountInv("MonsterLevel") * ((inits * 0.875) * random(randmin,randmax)));
			if (exex_monsterlevelenabledflags)
			{
				if (CountInv("MonsterLevel") >= 40) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 80) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 120) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
				if (CountInv("MonsterLevel") >= 160) damage += (CountInv("MonsterLevel") * ((inits * 0.1875) * random(randmin,randmax)));
			}
			damage *= (1.0 + (CountInv("MonsterLevel") * frandom(0.00625,0.009375)));
		}
		damage *= dmgfct;
		
		if (damage > 0) 
		{
			target.DamageMobj(self, self, damage, 'PSI');
		}
		else
		{
			string comblog;
			comblog.AppendFormat("\c[red]*\c- ");
			if (exex_combatlog && target)
			{
				if (PlayerPawn(target))
				{
					target.A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				}
				else
				{
					target.A_StopSound(14);
					target.A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
				}
				comblog.AppendFormat("\c[red]%s\c- took \c[purple]no damage\c- from", target.GetTag());
				comblog.AppendFormat(" \c[purple]%s's", GetTag());
				comblog.AppendFormat(" \c[red]psychic attack!\c-!");
				comblog.AppendFormat(" [\c[lightblue]PSI\c-]");
				if (dydudebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				Console.Printf(comblog);
			}
		}
	}
	
	const PAF_INDIVIDUALLIMIT = 256;
	const PAF_LIMITCOUNTALLTYPES = 512;
	void A_PainShootSkull(Class<Actor> spawntype, double angle, int flags = 0, int limit = -1)
	{
		// Don't spawn if we get massacred.
		if (DamageType == 'Massacre') return;

		if (spawntype == null) spawntype = "LostSoul";

		// [RH] check to make sure it's not too close to the ceiling
		if (pos.z + height + 8 > ceilingz)
		{
			if (bFloat)
			{
				Vel.Z -= 2;
				bInFloat = true;
				bVFriction = true;
			}
			return;
		}

		// [RH] make this optional
		if (limit < 0 && (Level.compatflags & COMPATF_LIMITPAIN))
		{
			if (!flags & PAF_INDIVIDUALLIMIT) limit = 21;
			else limit = 10;
		}

		if (limit > 0)
		{
			// count total number of skulls currently on the level
			// if there are already 21 skulls on the level, don't spit another one
			int count = limit;
			if (flags & PAF_LIMITCOUNTALLTYPES && flags & PAF_INDIVIDUALLIMIT)
			{
				ThinkerIterator it = ThinkerIterator.Create("LostSoulNew");
				Thinker othink;
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}

				it = ThinkerIterator.Create("LostSoulAnnoying");
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				
				it = ThinkerIterator.Create("BetaLostSoul");
				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				if (dydudebug_monsterspecialai) Console.Printf("[A_PainShootSkull %p (PAF_LIMITCOUNTALLTYPES)] count: %d / %d", self, count, limit);
			}
			else
			{
				ThinkerIterator it = ThinkerIterator.Create(spawntype);
				Thinker othink;

				while ( (othink = it.Next ()) )
				{
					if (flags & PAF_INDIVIDUALLIMIT)
					{
						actor othink2;
						othink2 = actor(othink);
						if (othink2 && othink2.master == self)
						{
							if (--count == 0)
								return;
						}
					}
					else
					{
						if (--count == 0)
							return;
					}
				}
				//if (dydudebug_monsterspecialai)
				Console.Printf("[A_PainShootSkull (%s) - %p] count: %d / %d", spawntype.GetClassName(), self, count, limit);
			}
		}

		// okay, there's room for another one
		double otherradius = GetDefaultByType(spawntype).radius;
		double prestep = 4 + (radius + otherradius) * 1.5;

		Vector2 move = AngleToVector(angle, prestep);
		Vector3 spawnpos = pos + (0,0,8);
		Vector3 destpos = spawnpos + move;

		Actor other = Spawn(spawntype, spawnpos, ALLOW_REPLACE);

		// Now check if the spawn is legal. Unlike Boom's hopeless attempt at fixing it, let's do it the same way
		// P_XYMovement solves the line skipping: Spawn the Lost Soul near the PE's center and then use multiple
		// smaller steps to get it to its intended position. This will also result in proper clipping, but
		// it will avoid all the problems of the Boom method, which checked too many lines that weren't even touched
		// and despite some adjustments never worked with portals.

		if (other != null)
		{
			EECreature SpawnedSoul;
			SpawnedSoul = EECreature(other);
			if (SpawnedSoul != null) 
			{
				if (LostSoulNew(SpawnedSoul) ||
						LostSoulAnnoying(SpawnedSoul) ||
						ForgottenOne(SpawnedSoul) ||
						BetaLostSoul(SpawnedSoul)) SpawnedSoul.isPEspawned = true;
				
				if (HadesSphere(SpawnedSoul)) SpawnedSoul.isHEspawned = true;
				if (HSOverlord(SpawnedSoul)) SpawnedSoul.isHOspawned = true;
			}

			double maxmove = other.radius - 1;

			if (maxmove <= 0) maxmove = 16;

			double xspeed = abs(move.X);
			double yspeed = abs(move.Y);

			int steps = 1;

			if (xspeed > yspeed)
			{
				if (xspeed > maxmove)
				{
					steps = int(1 + xspeed / maxmove);
				}
			}
			else
			{
				if (yspeed > maxmove)
				{
					steps = int(1 + yspeed / maxmove);
				}
			}

			Vector2 stepmove = move / steps;
			bool savedsolid = bSolid;
			bool savednoteleport = other.bNoTeleport;
			
			// make the PE nonsolid for the check and the LS non-teleporting so that P_TryMove doesn't do unwanted things.
			bSolid = false;
			other.bNoTeleport = true;
			for (int i = 0; i < steps; i++)
			{
				Vector2 ptry = other.pos.xy + stepmove;
				double oldangle = other.angle;
				if (!other.TryMove(ptry, 0))
				{
					// kill it immediately
					other.ClearCounters();
					other.DamageMobj(self, self, TELEFRAG_DAMAGE, 'None');
					bSolid = savedsolid;
					other.bNoTeleport = savednoteleport;
					return;
				}

				if (other.pos.xy != ptry)
				{
					// If the new position does not match the desired position, the player
					// must have gone through a portal.
					// For that we need to adjust the movement vector for the following steps.
					double anglediff = deltaangle(oldangle, other.angle);

					if (anglediff != 0)
					{
						stepmove = RotateVector(stepmove, anglediff);
					}
				}

			}
			bSolid = savedsolid;
			other.bNoTeleport = savednoteleport;

			// [RH] Lost souls hate the same things as their pain elementals
			other.CopyFriendliness (self, !(flags & PAF_NOTARGET));
			
			// Inherit the PE's Master if they have a IoS master
			if (master && BossBrainNew(master)) other.master = master;
			else other.master = self; // otherwise set the Lost Soul's master to be the PE [to help enforce individual PE limits].

			if (dydudebug_bossbraininfo2 && other.master)
			{
				Console.Printf("%s Master: \c[gold]%p\c-", other.GetClassName(), other.master);
			}

			if (!(flags & PAF_NOSKULLATTACK))
			{
				other.A_SkullAttack();
			}
		}
	}
	
	void A_PainAttack(class<Actor> spawntype = "LostSoul", double addangle = 0, int flags = 0, int limit = -1)
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + addangle, flags, limit);
		}
	}
	
	void A_DualPainAttack(class<Actor> spawntype = "LostSoul", double addangle = 45, int flags = 0, int limit = -1)
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + addangle, flags, limit);
			A_PainShootSkull(spawntype, angle - addangle, flags, limit);
		}
	}
	
	void A_PainDie(class<Actor> spawntype = "LostSoul")
	{
		if (target && IsFriend(target))
		{ // And I thought you were my friend!
			bFriendly = false;
		}
		A_NoBlocking();
		A_PainShootSkull(spawntype, angle + 90);
		A_PainShootSkull(spawntype, angle + 180);
		A_PainShootSkull(spawntype, angle + 270);
	}
	
	
	void A_CheckIfTargetDead(statelabel statel = null)
	{
		if (!target)
		{
			if (dydudebug_monsterspecialai) Console.Printf("NoTarget");
			SetStateLabel(statel);
		}
		else
		{
			if (target.health <= 0)
			{
				if (dydudebug_monsterspecialai) Console.Printf("TargetDead");
				target = null;
				SetStateLabel(statel);
			}
		}
	}
	
	// Nightmare Stuff
	void A_NightmarePhaseOut()
	{
		bSHOOTABLE = false;
		bNORADIUSDMG = true;
		bNOPAIN = true;
		bNOBLOOD = true; 
		A_UnSetShootable();
	}
	
	void A_NightmarePhaseIn()
	{
		bSHOOTABLE = true;
		bNORADIUSDMG = false;
		bNOPAIN = false;
		bNOBLOOD = false;
		A_SetShootable();
	}
	
	void A_GetHSHealthPreExp()
	{
		hsexphealth = health;
	}

	void A_HETeleport(statelabel tele = "TeleportChoose")
	{
		if (!CountInv("HadesTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 180) { if (random(1,256) <= 144) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 120) { if (random(1,256) <= 120) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60) { if (random(1,256) <= 96) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") <= 60) { if (random(1,256) <= 72) { SetStateLabel(tele); } }
			else { if (random(1,256) <= 72) { SetStateLabel(tele); } }
		}
	}

	void A_HOTeleport(statelabel tele = "TeleportChoose")
	{
		if (!CountInv("HadesTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 90) { if (random(1,256) <= 68) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60) { if (random(1,256) <= 56) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 30) { if (random(1,256) <= 44) { SetStateLabel(tele); } }
			else if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") <= 30) { if (random(1,256) <= 32) { SetStateLabel(tele); } }
			else { if (random(1,256) <= 32) { SetStateLabel(tele); } }
		}
	}

	void A_HadesSphereTeleport(statelabel tele = "Teleport", int chance = 128, int chancemax = 1024)
	{
		if (!CountInv("HSphereTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (random(1,chancemax) <= chance) { SetStateLabel(tele); }
			if (dydudebug_monsterspecialai) Console.Printf("HSTele: Target - %s (%d / %d)", target.GetClassName(), chance, chancemax);
		}
	}
	
	// Shielding Hell Warrior
	void A_HellWarShieldOff()
	{
		bNOBLOOD = false;
		bNOPAIN = false;
		bREFLECTIVE = false;
		bINVULNERABLE = false;
		A_SetInventory("HWShieldDefense",0);
		A_SetInventory("HWShieldDefenseExtra",0);
	}

	void A_HellWarShieldOn()
	{
		bNOBLOOD = true;
		bNOPAIN = true;
		bREFLECTIVE = true;
		bINVULNERABLE = true;
		A_SetInventory("HWShieldDefense",1);
		A_SetInventory("HWShieldDefenseExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);
		
		if (random(1,4) == 1) 
		{
			A_SetInventory("HWShieldDefenseExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		}
	}
	
	// Shielding Blasted/Vel Factor (makes shielding enemies who've been blasted slow down and occasionally can clear the BLASTED flag)
	void A_ShieldBlastVelFactor(double xmul = 0.5, double ymul = 0.5, int maxunblastchance = 16, int unblastchance = 1)
	{
		xmul = clamp(xmul, 0.0, 1.0);
		ymul = clamp(ymul, 0.0, 1.0);
		if (bBLASTED && (vel.x != 0.0 || vel.y != 0.0))
		{
			vel.x *= xmul;
			vel.y *= ymul;
			if (random(1,maxunblastchance) <= unblastchance) 
			{
				bBLASTED = false;
			}
			else
			{
				if ((vel.x >= -0.125 && vel.x <= 0.125) && (vel.y >= -0.125 && vel.y <= 0.125)) bBLASTED = false;
			}
		}
	}
	
	void A_MonsterStatsHP_ATK_DEF_SPD(int type = 0, int extraflags = 0)
	{
	}
	
	int A_CheckMeleeDestroyProj(int type = 0)
	{
		int TruePlayerLevel = CountInv("MonsterLevel");

		int debugmelee = dydudebug_meleeinformation;
		int MeleeDestroyProjectiles = 0;
		double MaxCheck = 16;
		double checkvalfactor = frandom(0.075,0.125);
		checkvalfactor *= 0.5;
		if (type == 0) // Punch
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.5;
		}
		if (type == 1) // Uppercut
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= 0.875;
		}
		if (type == 2) // Kick
		{
			if (skill <= 0) checkvalfactor = frandom(0.09,0.15);
			if (skill == 1) checkvalfactor = frandom(0.0825,0.1375);
			if (skill == 2) checkvalfactor = frandom(0.075,0.125);
			if (skill == 3) checkvalfactor = frandom(0.0675,0.1125);
			if (skill >= 4) checkvalfactor = frandom(0.06,0.10);
			checkvalfactor *= frandompick(0.875,1,1.125);
		}
		checkvalfactor *= 1.5;
		if (CountInv("MAManual")) checkvalfactor *= 1.5;
		if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) checkvalfactor *= frandompick(3,3.5,3.5,4.0,4.0,4.0,4.375,4.375,4.375,4.375,4.375,4.75,4.75,4.75,5.125,5.125,5.5);
		if (CountInv("DinahTrueIPState")) 
		{
			if (CountInv("MAManual"))
			{
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxCheck = (randompick(0,0,0,0,0,0,0,0,1) - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																																 else MaxCheck = (randompick(0,0,0,0,0,0,1,1,1) - ((TruePlayerLevel+1) * checkvalfactor));
			}
			else
			{
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxCheck = (randompick(0,0,0,1,1) - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																																 else MaxCheck = (randompick(1,1,1,2,2) - ((TruePlayerLevel+1) * checkvalfactor));
			}
		}
		else 
		{
			if (CountInv("MAManual"))
			{
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxCheck = (0.666675 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																																 else MaxCheck = (4 - ((TruePlayerLevel+1) * checkvalfactor));
			}
			else
			{
				if (CountInv("PowerStrength") || CountInv("PowerStrengthDD")) MaxCheck = (2.6667 - (((TruePlayerLevel+1) * checkvalfactor) * 6));
																																 else MaxCheck = (16 - ((TruePlayerLevel+1) * checkvalfactor));
			}
		}

		if (MaxCheck <= 0.01) MaxCheck = 0.01;
		double randomroll = frandom(0.1,MaxCheck);
		if (randomroll <= 1.0) MeleeDestroyProjectiles = 1;
		if (debugmelee) Console.Printf("\c[green]MeleeDestroyProjectiles [actors]:\c- type: %d, RandomRoll / MaxCheck: %.4f / %.4f, MeleeDestroyProjectiles: %d, checkvalfactor: %.4f (\c[gold]%.4f\c-)", type, randomroll, MaxCheck, MeleeDestroyProjectiles, checkvalfactor, (checkvalfactor * (TruePlayerLevel+1)));

		return MeleeDestroyProjectiles;
	}

	// Used to Create Multiple "Shields" for Punches/Melee
	action void A_MeleeShieldPiece(string attackname = "", int spawnheight = 32, int spawndistance = 0)
	{
		A_SpawnItemEx(attackname, cos(-pitch) * spawndistance, 0, spawnheight + (sin(-pitch) * spawndistance), 0, 0, 0, 0, SXF_SETMASTER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
	}
	
	void A_HandMotherChase()
	{
		if (random(1,32) <= (1 + (CountInv("MonsterLevel") * 0.083334))) A_EEChase("Melee","Missile",CHF_FASTCHASE,1,3,1,1);
		else A_EEChase("Melee","Missile",0,1,3,1,1);
	}
	
	const FATSPREAD = 90./8;
	void A_FatAttack1(class<Actor> spawntype = "FatShot")
	{
		if (target)
		{
			A_FaceTarget();
			A_SpawnProjectile(spawntype,32,0,FATSPREAD,ptr:AAPTR_TARGET);
			A_SpawnProjectile(spawntype,32,0,0,ptr:AAPTR_TARGET);
		}
	}
	
	void A_FatAttack2(class<Actor> spawntype = "FatShot")
	{
		if (target)
		{
			A_FaceTarget ();
			A_SpawnProjectile(spawntype,32,0,-FATSPREAD,ptr:AAPTR_TARGET);
			A_SpawnProjectile(spawntype,32,0,0,ptr:AAPTR_TARGET);
		}
	}
	
	void A_FatAttack3(class<Actor> spawntype = "FatShot")
	{
		if (target)
		{
			A_FaceTarget();
			A_SpawnProjectile(spawntype,32,0,(-FATSPREAD*0.5),ptr:AAPTR_TARGET);
			A_SpawnProjectile(spawntype,32,0,(FATSPREAD*0.5),ptr:AAPTR_TARGET);
		}
	}
	
	void A_ChookAtk(string shottype, double zheight = 0, double xyvel = 0, double zvel = 0, bool useammo = false, int divider = 30)
	{
		user_tempvar2 = frandompick(7.5,10.25,10.25,10.25,15,15,15,15,15,15,15,18.75,18.75,18.75,22.5);
		if (exex_monsterlevelenabledflags)
		{
			if (CountInv("MonsterLevel") >= (divider*4))
			{
				A_SetAngle(angle-(user_tempvar2*2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle-(user_tempvar2*2));
			}
			else
			if (CountInv("MonsterLevel") >= (divider*3))
			{
				A_SetAngle(angle-(user_tempvar2*1.5));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle-(user_tempvar2*1.5));
			}
			else
			if (CountInv("MonsterLevel") >= (divider*2))
			{
				A_SetAngle(angle-(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle-(user_tempvar2));
			}
			else
			if (CountInv("MonsterLevel") >= divider)
			{
				A_SetAngle(angle-(user_tempvar2*0.5));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle+(user_tempvar2));
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
				A_SetAngle(angle-(user_tempvar2*0.5));
			}
			else
			{
				A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
			}
		}
		else
		{
			A_ThrowGrenade(shottype,zheight,xyvel,zvel,useammo);
		}
	}
	
	// Shielding Centaur
	void A_CentaurShieldOff()
	{
		user_defendtimer = 0;
		user_defendcycles = 0;
		bNOBLOOD = 0;
		bNOPAIN = 0;
		bREFLECTIVE = 0;
		A_SetInventory("CentaurShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("CentaurShieldDefendExtra",0);
	}

	void A_CentaurShieldOn()
	{
		bNOBLOOD = 1;
		bNOPAIN = 1;
		bREFLECTIVE = 1;
		A_SetInventory("CentaurShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("CentaurShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("CentaurShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		} 
	}

	// Shielding Slaughtaur
	void A_SlaughtaurShieldOff()
	{
		user_defendtimer = 0;
		user_defendcycles = 0;
		bNOBLOOD = false;
		bNOPAIN = false;
		bREFLECTIVE = false;
		A_SetInventory("SlaughtaurShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("SlaughtaurShieldDefendExtra",0);
	}

	void A_SlaughtaurShieldOn()
	{
		bNOBLOOD = true;
		bNOPAIN = true;
		bREFLECTIVE = true;
		A_SetInventory("SlaughtaurShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("SlaughtaurShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("SlaughtaurShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		}
	}
	
	void A_GargDashCheck()
	{
		if (!target) { SetStateLabel("See"); }
	}
	
	void A_GargDashCheck2()
	{
		if (!target) 
		{ 
			SetStateLabel("See"); 
		}
		else
		{
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 45) 
			{
				if (!A_JumpIfTargetInLOS("See", frandom(77.5,82.5)))
				{
					A_Stop();
					SetStateLabel("See"); 
				}
			}
			else
			{
				if (random(1,8) <= 1)
				{
					if (!A_JumpIfTargetInLOS("See", frandom(77.5,82.5)))
					{
						A_Stop();
						SetStateLabel("See"); 
					}
				}
			}
		}
	}

	//**************************
	//*HERETIC-UNIQUE FUNCTIONS*
	//**************************
	// Gargoyle
	void A_ImpMsAttack()
	{
		if (!target || random[ImpMSAtk]() > 64)
		{
			SetState (SeeState);
			return;
		}
		A_SkullAttack(12);
	}

	void A_ImpExplode()
	{
		Actor chunk;

		bNoGravity = false;

		chunk = Spawn("HereticImpChunk1", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}

		chunk = Spawn("HereticImpChunk2", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}
		
		if (extremecrash)
		{
			SetStateLabel ("XCrash");
		}
	}

 	void A_ImpDeath()
	{
		bSolid = false;
		bFloorClip = true;
	}

	void A_ImpXDeath1()
	{
		bSolid = false;
		bFloorClip = true;
		bNoGravity = true;
		extremecrash = true;
	}
	
	//************************
	//*HEXEN-UNIQUE FUNCTIONS*
	//************************
	
	// Centaur
	void A_CentaurDefend()
	{
		A_FaceTarget ();
		if (CheckMeleeRange() && random[CentaurDefend]() < 32)
		{
			// This should unset REFLECTIVE as well
			// (unless you want the Centaur to reflect projectiles forever!)
			bReflective = false;
			bInvulnerable = false;
			SetState(MeleeState);
		}
	}

    // Afrit
	private void A_FiredSpawnRock ()
	{
		Actor mo;
		class<Actor> rtype;

		switch (random[FireDemonRock](0, 4))
		{
			case 0:
				rtype = "FireDemonRock1";
				break;
			case 1:
				rtype = "FireDemonRock2";
				break;
			case 2:
				rtype = "FireDemonRock3";
				break;
			case 3:
				rtype = "FireDemonRock4";
				break;
			case 4:
			default:
				rtype = "FireDemonRock5";
				break;
		}

		double xo = (random[FireDemonRock]() - 128) / 16.;
		double yo = (random[FireDemonRock]() - 128) / 16.;
		double zo = random[FireDemonRock]() / 32.;
		mo = Spawn (rtype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.target = self;
			mo.Vel.X = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Y = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Z = (random[FireDemonRock]() / 64.);
			mo.special1 = 2;		// Number bounces
		}

		// Initialize fire demon
		fdstrafecount = 0;
		bJustAttacked = false;
	}

	void A_FiredRocks()
	{
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
	}

	void A_FiredAttack()
	{
		if (target == null)	return;
		Actor mo = SpawnMissile (target, "FireDemonMissile");
		if (mo) A_StartSound("FireDemonAttack", CHAN_BODY);
	}

	void A_FireDChase(int minheight = 64, int strafecnt = 3, int strafechance = 30, int atkchance = 20, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap
			if (value6 <= 0) value6 = 8; // move/thrust strength

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_FireDChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int weaveindex = special1;
		double ang;
		double dist;

		if (reactiontime) reactiontime--;
		if (threshold) threshold--;

		// Float up and down
		AddZ(BobSin(weaveindex));
		special1 = (weaveindex + 2) & 63;

		// Ensure it stays above certain height
		if (pos.Z < floorz + minheight)
		{
			AddZ(2);
		}

		if (!target || !target.bShootable)
		{
			// Invalid target
			LookForPlayers (true);
			return;
		}

		// Strafe
		if (fdstrafecount > 0)
		{
			fdstrafecount--;
		}
		else
		{
			fdstrafecount = 0;
			Vel.X = Vel.Y = 0;
			dist = Distance2D(target);
			if (dist < FIREDEMON_ATTACK_RANGE)
			{
				if (random[FiredChase]() < strafechance)
				{
					ang = AngleTo(target);
					if (random[FiredChase]() < 128)
						ang += 90;
					else
						ang -= 90;
					Thrust(value6, ang); // value6 = thrust [8]
					fdstrafecount = strafecnt;	// strafe time
				}
			}
		}

		FaceMovementDirection ();

		// Normal movement
		if (!fdstrafecount)
		{
			if ((movecount -= 1) < 0 || !MonsterMove ())
			{
				NewChaseDir ();
			}
		}

		// Do missile attack
		if (!bJustAttacked)
		{
			if (CheckMissileRange () && (random[FiredChase]() < 20))
			{
				if (!target || !target.bShootable || target.health < 1)
				{
					// Invalid target
					LookForPlayers (true);
					return;
				}
				else
				{
					SetState (MissileState);
					bJustAttacked = true;
					return;
				}
			}
		}
		else
		{
			bJustAttacked = false;
		}

		// make active sound
		if (random[FiredChase]() < 3)
		{
			PlayActiveSound ();
		}
	}

	void A_FiredSplotch()
	{
		Actor mo;

		mo = Spawn ("FireDemonSplotch1", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
		mo = Spawn ("FireDemonSplotch2", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
	}
	
	// Bishop
	void A_BishopAttack(int meleedmg = 4, int missilenum = 5)
	{
		if (!target)
		{
			return;
		}
		A_StartSound(AttackSound, CHAN_BODY);
		if (CheckMeleeRange())
		{
			int damage = meleedmg;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		missilecount = missilenum;
	}

	void A_BishopAttack2(string missiletype = "BishopFX")
	{
		string atktype = missiletype;

		if (!target || !missilecount)
		{
			missilecount = 0;
			SetState (SeeState);
			return;
		}
		Actor mo = SpawnMissile (target, atktype);
		if (mo != null)
		{
			mo.tracer = target;
		}
		missilecount--;
		return;
	}
	
	void A_BishopDecide()
	{
		if (!target) { return; }

		if (random[BishopDecide]() >= 220)
		{
			SetStateLabel ("Blur");
		}
	}

	void A_BishopDoBlur(int blurrand = 3, int blurnum = 3, double thrustamt = 11.0)
	{
		if (!target) { return; }

		missilecount = (random[BishopDoBlur]() & blurrand) + blurnum; // Random number of blurs
		if (random[BishopDoBlur]() <= 224)
		{
			if (random(1,2) == 1)
			{
				Thrust(thrustamt, Angle + 90);
			}
			else
			{
				Thrust(thrustamt, Angle - 90);
			}
		}
		else
		{
			if (random(1,2) == 1)
			{
				// Thrust Backwards
				Thrust(thrustamt, Angle - 180);
			}
			else
			{
				// Thrust forward
				Thrust(thrustamt, Angle + 0);
			}
		}
		A_StartSound("BishopBlur", CHAN_BODY);
	}

	void A_BishopSpawnBlur(int seestatechance = 96)
	{
		if (!--missilecount)
		{
			Vel.XY = (0,0);// = Vel.Y = 0;
			if (random[BishopSpawnBlur]() > seestatechance)
			{
				SetState (SeeState);
			}
			else
			{
				SetState (MissileState);
			}
		}
		Actor mo = Spawn ("BishopBlur", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	void A_BishopChase(int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_BishopChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}

		double newz = pos.z - BobSin(bobstate) / 2.;
		bobstate = (bobstate + 4) & 63;
		newz += BobSin(bobstate) / 2.;
		SetZ(newz);
	}

	void A_BishopPainBlur(int chance = 64, double xveldiv = 16.0, double yveldiv = 16.0, double zveldiv = 32.0)
	{
		if (random[BishopPainBlur]() <= chance)
		{
			SetStateLabel ("Blur");
			return;
		}
		double xo = random2[BishopPainBlur]() / xveldiv;
		double yo = random2[BishopPainBlur]() / yveldiv;
		double zo = random2[BishopPainBlur]() / zveldiv;
		Actor mo = Spawn ("BishopPainBlur", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	// Stalker
	void A_SerpentUnHide()
	{
		bInvisible = false;
		Floorclip = 24;
	}
	void A_SerpentHide()
	{
		bInvisible = true;
		Floorclip = 0;
	}

	void A_SerpentRaiseHump()
	{
		Floorclip -= 4;
	}
	void A_SerpentLowerHump()
	{
		Floorclip += 4;
	}
	void A_SerpentHumpDecide()
	{
		if (MissileState != NULL)
		{
			if (random[SerpentHump]() > 30)
			{
				return;
			}
			else if (random[SerpentHump]() < 40)
			{
				// Missile attack
				SetState (MeleeState);
				return;
			}
		}
		else if (random[SerpentHump]() > 3)
		{
			return;
		}
		if (!CheckMeleeRange ())
		{
			// The hump shouldn't occur when within melee range
			if (MissileState != NULL && random[SerpentHump]() < 128)
			{
				SetState (MeleeState);
			}
			else
			{
				SetStateLabel("Hump");
				A_StartSound("SerpentActive", CHAN_BODY);
			}
		}
	}
	
	void A_SerpentCheckForAttack()
	{
		if (!target)
		{
			return;
		}
		if (MissileState != NULL)
		{
			if (!CheckMeleeRange ())
			{
				SetStateLabel ("Attack");
				return;
			}
		}
		if (CheckMeleeRange2 ())
		{
			SetStateLabel ("Walk");
		}
		else if (CheckMeleeRange ())
		{
			if (random[SerpentAttack]() < 32)
			{
				SetStateLabel ("Walk");
			}
			else
			{
				SetStateLabel ("Attack");
			}
		}
	}

	void A_SerpentChooseAttack()
	{
		if (!target || CheckMeleeRange())
		{
			return;
		}
		if (MissileState != NULL)
		{
			SetState (MissileState);
		}
	}

	void A_SerpentMeleeAttack()
	{
		if (!target)
		{
			return;
		}
		if (CheckMeleeRange ())
		{
			int damage = random[SerpentAttack](1, 8) * 5;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			A_StartSound("SerpentMeleeHit", CHAN_BODY);
		}
		if (random[SerpentAttack]() < 96)
		{
			A_SerpentCheckForAttack();
		}
	}

	void A_SerpentSpawnGibs()
	{
		static const class<Actor> GibTypes[] =
		{
			"SerpentGib3",
			"SerpentGib2",
			"SerpentGib1"
		};

		for (int i = 2; i >= 0; --i)
		{
			double x = (random[SerpentGibs]() - 128) / 16.;
			double y = (random[SerpentGibs]() - 128) / 16.;

			Actor mo = Spawn (GibTypes[i], Vec2OffsetZ(x, y, floorz + 1), ALLOW_REPLACE);
			if (mo)
			{
				mo.Vel.X = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Vel.Y = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Floorclip = 6;
			}
		}
	}
	
	// Disciple
	void A_GhostOff()
	{
		A_SetRenderStyle(1.0, STYLE_Normal);
		bGhost = false;
	}

	void A_WizAtk1()
	{
		A_FaceTarget();
		A_GhostOff();
	}

	void A_WizAtk2()
	{
		A_FaceTarget();
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
		bGHOST = true;
	}

	// Disciple Shot [Heretic]
	void A_WizAtk3(string missiletype = "WizardFX1New", int meleedamage = 4)
	{
		A_GhostOff();
		if (!target) return;
		A_StartSound(AttackSound, CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = meleedamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		
		Actor mo = SpawnMissile (target, missiletype);
		if (mo != null)
		{
			SpawnMissileAngle(missiletype, mo.Angle - 45. / 8, mo.Vel.Z);
			SpawnMissileAngle(missiletype, mo.Angle + 45. / 8, mo.Vel.Z);
		}
	}
	
	// Iron Lich
	void A_LichAttack (int fireshots = 5, int tornados = 1, int meleedamage = 6, string icemissile = "HeadFX1New", string firemissile = "HeadFX3New", string twistermissile = "WhirlwindNew")
	{
		static const int atkResolve1[] = { 50, 150 };
		static const int atkResolve2[] = { 150, 200 };

		// Ice ball		(close 20% : far 60%)
		// Fire column	(close 40% : far 20%)
		// Whirlwind	(close 40% : far 20%)
		// Distance threshold = 8 cells

		if (target == null)
		{
			return;
		}
		A_FaceTarget();
		if (CheckMeleeRange())
		{
			int damage = meleedamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		int dist = Distance2D(target) > 8 * 64;
		int randAttack = random[LichAttack]();
		if (randAttack < atkResolve1[dist])
		{
			// Ice ball
			SpawnMissile (target, icemissile); 
			A_StartSound("ironlich/attack2", CHAN_BODY);
		}
		else if (randAttack < atkResolve2[dist])
		{
			// Fire column
			string firetype = firemissile;
			Actor baseFire = SpawnMissile (target, firetype);
			if (baseFire != null)
			{
				baseFire.SetStateLabel("NoGrow");
				for (int i = 0; i < fireshots; i++)
				{
					Actor fire = Spawn(firetype, baseFire.Pos, ALLOW_REPLACE);
					if (i == 0)
					{
						A_StartSound("ironlich/attack1", CHAN_BODY);
					}
					if (fire != null)
					{
						fire.target = baseFire.target;
						fire.angle = baseFire.angle;
						fire.Vel = baseFire.Vel;
						fire.SetDamage(0);
						fire.health = (i+1) * 2;
						fire.CheckMissileSpawn (radius);
					}
				}
			}
		}
		else
		{
			// Whirlwind
			for (int i = 0; i < tornados; i++)
			{
				string twistertype = twistermissile;
				Actor mo = SpawnMissile (target, twistertype);
				if (mo != null)
				{
					mo.AddZ(-32+(i*16));
					mo.tracer = target;
					mo.health = 20*TICRATE; // Duration
					A_StartSound("ironlich/attack3", CHAN_BODY);
				}
			}
		}
	}
	
	// Reiver
	void A_WraithInit()
	{
		AddZ(48);

		// [RH] Make sure the wraith didn't go into the ceiling
		if (pos.z + height > ceilingz)
		{
			SetZ(ceilingz - Height);
		}

		WeaveIndexZ = 0;			// index into floatbob
	}

	void A_WraithChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_WraithChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int weaveindex = WeaveIndexZ;
		AddZ(BobSin(weaveindex));
		WeaveIndexZ = (weaveindex + 2) & 63;
		A_Chase(melee,missile,flags);
		A_WraithFX4 ();
	}

	void A_WraithFX3()
	{
		int numdropped = random[WraithFX3](0,14);

		while (numdropped-- > 0)
		{
			double xo = (random[WraithFX3]() - 128) / 32.;
			double yo = (random[WraithFX3]() - 128) / 32.;
			double zo = random[WraithFX3]() / 64.;

			Actor mo = Spawn("WraithFX3", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}

	void A_WraithFX4 ()
	{
		int chance = random[WraithFX4]();
		bool spawn4, spawn5;

		if (chance < 10)
		{
			spawn4 = true;
			spawn5 = false;
		}
		else if (chance < 20)
		{
			spawn4 = false;
			spawn5 = true;
		}
		else if (chance < 25)
		{
			spawn4 = true;
			spawn5 = true;
		}
		else
		{
			spawn4 = false;
			spawn5 = false;
		}

		if (spawn4)
		{
			double xo = (random[WraithFX4]() - 128) / 16.;
			double yo = (random[WraithFX4]() - 128) / 16.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX4", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
		if (spawn5)
		{
			double xo = (random[WraithFX4]() - 128) / 32.;
			double yo = (random[WraithFX4]() - 128) / 32.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX5", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}
	
	void A_WraithMelee(int drainamount)
	{
		int maxdrain;
		if (drainamount == 0) drainamount = random[StealHealth](1,8)*2;

		if (user_MaxHP <= 0) maxdrain = spawnhealth(); else maxdrain = user_MaxHP;
		// Steal health from target and give to self
		if (CheckMeleeRange() && (random[StealHealth]() < maxdrain))
		{
			int amount = drainamount;
			amount = target.DamageMobj (self, self, amount, 'Melee');
			if (health < maxdrain && target.bINVULNERABLE == 0)
			{
				health += (amount * frandom(0.45,0.65));
				health = clamp(health, health, maxdrain);
			}
		}
	}

	void A_WraithRaiseInit()
	{
		bInvisible = false;
		bNonShootable = false;
		bDontBlast = false;
		bShootable = true;
		bSolid = true;
		Floorclip = Height;
	}

	void A_WraithRaise()
	{
		if (RaiseMobj (2))
		{
			// Reached it's target height
			// [RH] Once a buried wraith is fully raised, it should be
			// morphable, right?
			bDontMorph = false;
			bSpecialFloorClip = false;
			SetStateLabel ("Chase");
			// [RH] Reset PainChance to a normal wraith's.
			PainChance = GetDefaultByType("Wraith").PainChance;
		}

		SpawnDirt (radius);
	}

	// Wendigo
	private void SpawnWisp()
	{
		static const class<Actor> WispTypes[] = { "IceGuyWisp1", "IceGuyWisp2" };

		double dist = (random[IceGuyLook]() - 128) * radius / 128.;
		double an = angle + 90;
		Actor mo = Spawn(WispTypes[random[IceGuyLook]() & 1], Vec3Angle(dist, an, 60.), ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel = Vel;
			mo.target = self;
		}
	}

	void A_IceGuyLook()
	{
		A_Look();
		if (random[IceGuyLook]() < 64) SpawnWisp();
	}

	void A_IceGuyChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_IceGuyChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		A_Chase(melee,missile,flags);
		if (random[IceGuyLook]() < 128) SpawnWisp();
	}

	void A_IceGuyAttack(string missiletype = "IceGuyFXNew")
	{
		if (!target) 
		{
			return;
		}
		string specialmissile = missiletype;

		SpawnMissileXYZ(Vec3Angle(radius / 2, angle + 90, 40.), target, specialmissile);
		SpawnMissileXYZ(Vec3Angle(radius / 2, angle - 90, 40.), target, specialmissile);
		A_StartSound(AttackSound, CHAN_WEAPON);
	}
	
	// Death Wyvern
	private void DragonSeek (double thresh, double turnMax, int meleedamage, string missiletype = "DragonFireball")
	{
		double dist;
		double delta;
		Actor targ;
		int i;
		double bestAngle;
		double angleToSpot, angleToTarget;
		Actor mo;

		targ = tracer;
		if (targ == null)
		{
			return;
		}

		double diff = deltaangle(angle, AngleTo(targ));
		delta = abs(diff);

		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (diff > 0)
		{
			// Turn clockwise
			angle = angle + delta;
		}
		else
		{
			// Turn counter clockwise
			angle = angle - delta;
		}
		VelFromAngle();

		dist = DistanceBySpeed(targ, Speed);
		if (pos.z + height < targ.pos.z || targ.pos.z + targ.height < pos.z)
		{
			Vel.Z = (targ.pos.z - pos.z) / dist;
		}
		if (targ.bShootable && random[DragonSeek]() < 64)
		{
			// attack the destination mobj if it's attackable
			Actor oldTarget;
			
			if (absangle(angle, AngleTo(targ)) < 22.5)
			{
				oldTarget = target;
				target = targ;
				if (CheckMeleeRange ())
				{
					int basedmg = meleedamage;

					int damage = basedmg;
					int newdam = target.DamageMobj (self, self, damage, 'Melee');
					target.TraceBleed (newdam > 0 ? newdam : damage, self);
					A_StartSound(AttackSound, CHAN_WEAPON);
				}
				else if (random[DragonSeek]() < 128 && CheckMissileRange())
				{
					string atktype = missiletype;
					SpawnMissile(targ, atktype);		
					A_StartSound(AttackSound, CHAN_WEAPON);
				}
				target = oldTarget;
			}
		}
		if (dist < 4)
		{
			// Hit the target thing
			if (target && random[DragonSeek]() < 200)
			{
				Actor bestActor = null;
				bestAngle = 360.;
				angleToTarget = AngleTo(target);
				for (i = 0; i < 5; i++)
				{
					if (!targ.args[i])
					{
						continue;
					}
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					mo = iter.Next ();
					if (mo == null)
					{
						continue;
					}
					angleToSpot = AngleTo(mo);
					double diff = absangle(angleToSpot, angleToTarget);
					if (diff < bestAngle)
					{
						bestAngle = diff;
						bestActor = mo;
					}
				}
				if (bestActor != null)
				{
					tracer = bestActor;
				}
			}
			else
			{
				// [RH] Don't lock up if the dragon doesn't have any
				// targs defined
				for (i = 0; i < 5; ++i)
				{
					if (targ.args[i] != 0)
					{
						break;
					}
				}
				if (i < 5)
				{
					do
					{
						i = (random[DragonSeek]() >> 2) % 5;
					} while(!targ.args[i]);
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					tracer = iter.Next ();
				}
			}
		}
	}
	
	void A_DragonInitFlight()
	{
		ActorIterator iter = Level.CreateActorIterator(tid);
		
		do
		{
			// find the first tid identical to the dragon's tid
			tracer = iter.Next();
			if (tracer == null)
			{
				SetState (SpawnState);
				return;
			}
		} while (tracer == self);
		RemoveFromHash();
	}

	void A_DragonFlight(double thresh = 4., double turnMax = 8., int meleedamage = 10, string missiletype = "DragonFireball")
	{
		double ang;

		DragonSeek (thresh, turnMax, meleedamage, missiletype);
		if (target)
		{
			if (!target.bShootable)
			{
				// target died
				target = null;
				return;
			}
			ang = absangle(angle, AngleTo(target));
			if (ang < 22.5 && CheckMeleeRange())
			{
				int basedmg = meleedamage;

				int damage = basedmg;
				int newdam = target.DamageMobj (self, self, damage, 'Melee');
				target.TraceBleed (newdam > 0 ? newdam : damage, self);
				A_StartSound(AttackSound, CHAN_WEAPON);
			}
			else if (ang <= 20)
			{
				SetState(MissileState);
				A_StartSound(AttackSound, CHAN_WEAPON);
			}
		}
		else
		{
			LookForPlayers(true);
		}
	}

	void A_DragonFlap(double thresh = 4., double turnMax = 8., int meleedamage = 10, string missiletype = "DragonFireball")
	{
		A_DragonFlight(thresh,turnMax,meleedamage,missiletype);
		if (random[DragonFlight]() < 240)
		{
			A_StartSound("DragonWingflap", CHAN_BODY);
		}
		else
		{
			PlayActiveSound ();
		}
	}

	void A_DragonAttack(string missiletype = "DragonFireball", double angle = 0.0)
	{
		string atktype = missiletype;
		Actor mo = SpawnMissile (target, atktype);
		if (mo != null && exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 90)
		{
			SpawnMissileAngle(atktype, mo.Angle - 45. / 8, mo.Vel.Z);
			SpawnMissileAngle(atktype, mo.Angle + 45. / 8, mo.Vel.Z);
		}
	}

	void A_DragonPain()
	{
		A_Pain();
		if (!tracer)
		{
			// no destination spot yet
			SetState (SeeState);
		}
	}

	void A_DragonCheckCrash()
	{
		if (pos.z <= floorz)
		{
			SetStateLabel ("Crash");
		}
	}
	
	// Traductus
	void A_ClericAttack(string missiletype = "HolyMissile")
	{
		string atktype = missiletype;
		if (!target) return;
		
		Actor missile = SpawnMissileZ (pos.z + 40., target, atktype);
		if (missile != null) missile.tracer = null;	// No initial target
		A_StartSound("HolySymbolFire", CHAN_WEAPON);
	}
	
	// Menelkir	
	void MStaffSpawn2 (double angle, string missiletype = "MageStaffFX2")
	{
		string atktype = missiletype;

		Actor mo = SpawnMissileAngleZ (pos.z + 40, atktype, angle, 0.);
		if (mo)
		{
			mo.target = self;
			mo.tracer = RoughMonsterSearch(10, true, true);
		}
	}
	void A_MageAttack(string missiletype = "MageStaffFX2")
	{
		if (!target) return;
		
		MStaffSpawn2(angle,missiletype);
		MStaffSpawn2(angle-5,missiletype);
		MStaffSpawn2(angle+5,missiletype);
		A_StartSound("MageStaffFire", CHAN_WEAPON);
	}

	// Zedek
	void A_FighterAttack(string missiletype = "FSwordMissile")
	{
		string atktype = missiletype;

		if (!target) return;

		SpawnMissileAngle(atktype, Angle + (45. / 4), 0);
		SpawnMissileAngle(atktype, Angle + (45. / 8), 0);
		SpawnMissileAngle(atktype, Angle, 0);
		SpawnMissileAngle(atktype, Angle - (45. / 8), 0);
		SpawnMissileAngle(atktype, Angle - (45. / 4), 0);
		A_StartSound("FighterSwordFire", CHAN_WEAPON);
	}
	
	//*************************
	//*STRIFE-UNIQUE FUNCTIONS*
	//*************************
	// Acolyte
	void A_AcolyteDie ()
	{
		// [RH] Disable translucency here.
		A_SetRenderStyle(1, STYLE_Normal);

		// Only the Blue Acolyte does extra stuff on death.
		if (self is "AcolyteBlue")
		{
			int i;
			// Make sure somebody is still alive
			for (i = 0; i < MAXPLAYERS; ++i)
			{
				if (playeringame[i] && players[i].health > 0)
					break;
			}
			if (i == MAXPLAYERS)
				return;

			// Make sure all the other blue acolytes are dead, but do this only once in case of simultaneous kills.
			if (CheckBossDeath() && !players[i].mo.FindInventory("QuestItem7"))
			{
				players[i].mo.GiveInventoryType ("QuestItem7");
				players[i].SetLogNumber (14);
				A_StopSound (CHAN_VOICE);
				A_StartSound("svox/voc14", CHAN_VOICE);
			}
		}
	}

	void A_BeShadowy()
	{
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
	}

	void A_BeShadowyFoe()
	{
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
		if (bFriendly) bFriendly = false;
	}

	void A_AcolyteBits()
	{
		if (SpawnFlags & MTF_SHADOW)
		{
			A_BeShadowy();
		}
		if (SpawnFlags & MTF_ALTSHADOW)
		{
			if (bShadow)
			{
				// I dunno.
			}
			else
			{
				A_SetRenderStyle(0, STYLE_None);
			}
		}
	}
	
	// Shielding Acolytes
	void A_AcolyteShieldOff()
	{
		bNOBLOOD = 0;
		bNOPAIN = 0;
		A_SetInventory("AcolyteShieldDefend",0); // A_UnSetInvulnerable
		A_SetInventory("AcolyteShieldDefendExtra",0);
	}
	
	void A_AcolyteShieldOn()
	{
		if (random(1,2) == 1)
		{
			bNOPAIN = 1;
			bNOBLOOD = 1;
		}
		else
		{
			bNOPAIN = 0;
			bNOBLOOD = 0;
		}
		A_SetInventory("AcolyteShieldDefend",1); // A_SetInvulnerable
		A_SetInventory("AcolyteShieldDefendExtra",0);
		A_ShieldBlastVelFactor(0.8375,0.8375,24,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("AcolyteShieldDefendExtra",1); 
			A_ShieldBlastVelFactor(0.8375,0.8375,6,1);
		}
	}
	
	void A_DropFire(string missiletype = "FireDroplet", int expdmg = 64, int exprad = 64, int expflags = XF_NOSPLASH, string type = "Fire")
	{
		Actor drop = Spawn(missiletype, pos + (0,0,24), ALLOW_REPLACE);
		if (drop != null)
		{
			drop.Vel.Z = -1.;
		}
		A_Explode(expdmg, exprad, expflags, damagetype: type);
	}	
	
	void A_GiveGold(int basegold)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int goldamt = CountInv("Coin",AAPTR_DEFAULT);
		user_golddrop = basegold;
		if (goldamt < 1) user_golddrop += goldamt;
		
		int LDLMulti = 2; // 2 = 100%
		if (user_legendaryevolved) LDLMulti = random(4,6);
		user_golddrop = (user_golddrop * LDLMulti) / 2;

		int PlayerLuck;
		if (MiscItem) PlayerLuck = MiscItem.PlayerLUCK;
		int extragold;
		int extragold2;
		int luckbonus;
		int bonuspart1;
		int bonuspart2;
		int bonusgold;
		int bonusgold2;
		int basecoins = user_golddrop;

		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			luckbonus = PlayerLuck / 4;
			luckbonus = (luckbonus * LDLMulti) / 4;
			bonusgold2 = (100 + luckbonus);
			user_golddrop = user_golddrop * (bonusgold2) / 100;

			extragold2 = PlayerLuck / 32;
			if (extragold < 0) extragold2 = 0;
			extragold2 = (extragold2 * LDLMulti) / 4;

			user_golddrop += extragold2;
		}
		int lowcap = (basegold / random(2,3));
		if (user_golddrop < lowcap) user_golddrop = lowcap;

		A_GiveToTarget("Coin",user_golddrop);
		A_TakeInventory("Coin",goldamt,0,AAPTR_DEFAULT);
		
		/*
		if (playpawn) 
		{
			if (dydudebug_coindropdisplays) Console.Printf("Gained \cy%d\c- [lowcap: %d] Coins! [bonusdft%: %d, extra2: %d, bonus%: %d, extra: %d, base2: %d, base1: %d, LDLMulti: \cx%d\c- / 2]", user_golddrop, lowcap, bonusgold2, extragold2, bonusgold, extragold, basecoins, basegold, LDLMulti);
																else Console.Printf("Gained %d Coins!", user_golddrop);
		}
		*/
	}

	states
	{
		DeathCC:
			TNT1 A 1
			{
				string nm = "CCards_Actor_HauntBuff";
				if (CountInv(nm)) { }
				else Destroy();
			}
			loop;
	}
}

class EECardSummon : EECreature
{
	default
	{
		health 15;
		mass 5000000;
		+DONTTHRUST;
	}
	int det;
	override void Tick()
	{
		Super.Tick();
		if (target && target.health <= 0 || !target)
		{
			if (det <= 0)
			{
				state dthstate = FindState("Death");
				if (dthstate != null) SetState(dthstate);
				det++;
			}
		}
	}
}

class EEHelperFriend : EECreature
{
}

class EEUniqueBoss : EECreature abstract
{
}

class MaulotaurBase : EECreature
{
 const MAULATORTICS = 25 * TICRATE;
 const MNTR_CHARGE_SPEED =13.;
 const MINOTAUR_LOOK_DIST = 16*54.;
	
	void MinotaurSlam (Actor target)
	{
		double ang = AngleTo(target);
		double thrust = 16 + random[MinotaurSlam]() / 64.;
		target.VelFromAngle(ang, thrust);
		int damage = random[MinotaurSlam](1, 8) * (bSummonedMonster? 4 : 6);
		int newdam = target.DamageMobj (null, null, damage, 'Melee');
		target.TraceBleedAngle (newdam > 0 ? newdam : damage, ang, 0.);
		if (target.player)
		{
			target.reactiontime = random[MinotaurSlam](14, 21);
		}
	}

	override void Tick ()
	{
		Super.Tick ();
		
		// The unfriendly Minotaur (Heretic's) is invulnerable while charging
		if (!bSummonedMonster)
		{
			bInvulnerable = bSkullFly;
		}
	}

	override bool Slam (Actor thing)
	{
		// Slamming minotaurs shouldn't move non-creatures
		if (!thing.bIsMonster && !thing.player)
		{
			return false;
		}
		return Super.Slam (thing);
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		damage = Super.DoSpecialDamage (target, damage, damagetype);
		if (damage != -1 && bSkullFly)
		{
			// Slam only when in charge mode
			MinotaurSlam (target);
			return -1;
		}
		return damage;
	}

	void A_MinotaurAtk1(int atkdamage = 4, int squishamount = -16)
	{
		if (!target)
		{
			return;
		}
		A_StartSound("minotaur/melee", CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = atkdamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			PlayerInfo player = target.player;
			if (player != null && player.mo == target)
			{
				// Squish the player
				player.deltaviewheight = squishamount;
			}
		}
	}

	void A_MinotaurDecide()
	{
		bool friendly = bSummonedMonster;

		if (!target)
		{
			return;
		}
		if (!friendly)
		{
			A_StartSound("minotaur/sight", CHAN_WEAPON);
		}
		double dist = Distance2D(target);
		if (target.pos.z + target.height > pos.z
			&& target.pos.z + target.height < pos.z + height
			&& dist < (friendly ? 16*64. : 8*64.)
			&& dist > 1*64.
			&& random[MinotaurDecide]() < 150)
		{
			// Charge attack
			// Don't call the state function right away
			SetStateLabel("Charge", true);
			bSkullFly = true;
			if (!friendly)
			{
				// Heretic's Minotaur is invulnerable during charge attack
				// bInvulnerable = true;
				A_SetInventory("MaulotaurChargeDefense",1);
				bNoPain = true;
				bNoBlood = true;
			}
			A_FaceTarget ();
			VelFromAngle(MNTR_CHARGE_SPEED);
			special1 = TICRATE/2; // Charge duration
		}
		else if (target.pos.z == target.floorz
				&& dist < 9*64.
				&& random[MinotaurDecide]() < (friendly ? 100 : 220))
		{
			// Floor fire attack
			SetStateLabel("Hammer");
			special2 = 0;
		}
		else
		{
			// Swing attack
			A_FaceTarget ();
			// Don't need to call P_SetMobjState because the current state
			// falls through to the swing attack
		}
	}
	
	void A_MinotaurCharge()
	{
		if (target == null)
		{
			return;
		}
		if (special1 > 0)
		{
			Class<Actor> type;

			if (gameinfo.gametype == GAME_Heretic)
			{
				type = "PhoenixPuff";
			}
			else
			{
				type = "PunchPuff";
			}
			Actor puff = Spawn (type, Pos, ALLOW_REPLACE);
			if (puff != null) puff.Vel.Z = 2;
			special1--;
		}
		else
		{
			bSkullFly = false;
			bInvulnerable = false;
			A_SetInventory("MaulotaurChargeDefense",0);
			bNoPain = false;
			bNoBlood = false;
			SetState (SeeState);
		}
	}

	void A_MinotaurAtk2(string missiletype = "MinotaurFX1", int meleedamage = 5, int friendlymeleedamage = 3)
	{
		bool friendly = bSummonedMonster;

		int actualmeleedmg = meleedamage;
		if (friendly == 1) actualmeleedmg = friendlymeleedamage;
		string actualmissile = missiletype;
		
		if (target == null)
		{
			return;
		}
		A_StartSound("minotaur/attack2", CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = actualmeleedmg;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		double z = pos.z + 40;
		Class<Actor> fx = actualmissile;
		Actor mo = SpawnMissileZ (z, target, fx);
		if (mo != null)
		{
			//S_Sound (mo, CHAN_WEAPON, "minotaur/attack2", 1, ATTN_NORM);
			double vz = mo.Vel.Z;
			double ang = mo.angle;
			SpawnMissileAngleZ (z, fx, ang-(45./8), vz);
			SpawnMissileAngleZ (z, fx, ang+(45./8), vz);
			SpawnMissileAngleZ (z, fx, ang-(45./16), vz);
			SpawnMissileAngleZ (z, fx, ang+(45./16), vz);
		}
	}

	void A_MinotaurAtk3(int atkdamage = 4, int squishamount = -16, string missiletype = "MinotaurFX2New")
	{
		string attacktype = missiletype;

		if (!target)
		{
			return;
		}
		A_StartSound("minotaur/attack3", CHAN_VOICE);
		if (CheckMeleeRange())
		{
			int damage = atkdamage;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			PlayerInfo player = target.player;
			if (player != null && player.mo == target)
			{
				// Squish the player
				player.deltaviewheight = squishamount;
			}
		}
		else
		{
			if (Floorclip > 0 && compat_minotaur)
			{
				// only play the sound. 
				A_StartSound("minotaur/fx2hit", CHAN_WEAPON);
			}
			else
			{
				Actor mo = SpawnMissile (target, attacktype);
				if (mo != null)
				{
					mo.A_StartSound("minotaur/attack1", CHAN_WEAPON);
				}
			}
		}
		if (random[MinotaurAtk3]() < 192 && special2 == 0)
		{
			SetStateLabel ("HammerLoop");
			special2 = 1;
		}
	}

	void A_MinotaurDeath()
	{
		if (Wads.CheckNumForName ("MNTRF1", Wads.ns_sprites) < 0 &&
			Wads.CheckNumForName ("MNTRF0", Wads.ns_sprites) < 0)
			SetStateLabel("FadeOut");
	}

	void A_MinotaurRoam()
	{
		// In case pain caused him to skip his fade in.
		A_SetRenderStyle(1, STYLE_Normal);

		let mf = MinotaurFriend(self);
		if (mf)
		{
			if (mf.StartTime >= 0 && (level.maptime - mf.StartTime) >= MAULATORTICS)
			{
				DamageMobj (null, null, TELEFRAG_DAMAGE, 'None', 0, 0.0);
				return;
			}
		}

		if (random[MinotaurRoam]() < 30)
			A_MinotaurLook();		// adjust to closest target

		if (random[MinotaurRoam]() < 6)
		{
			//Choose new direction
			movedir = random[MinotaurRoam]() % 8;
			FaceMovementDirection ();
		}
		if (!MonsterMove())
		{
			// Turn
			if (random[MinotaurRoam]() & 1)
				movedir = (movedir + 1) % 8;
			else
				movedir = (movedir + 7) % 8;
			FaceMovementDirection ();
		}
	}

	void A_MinotaurLook()
	{
		if (!(self is "MinotaurFriend"))
		{
			A_Look();
			return;
		}

		Actor mo = null;
		PlayerInfo player;
		double dist;
		Actor master = tracer;

		target = null;
		if (deathmatch)					// Quick search for players
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (!playeringame[i]) continue;
				player = players[i];
				mo = player.mo;
				if (mo == master) continue;
				if (mo.health <= 0) continue;
				dist = Distance2D(mo);
				if (dist > MINOTAUR_LOOK_DIST) continue;
				target = mo;
				break;
			}
		}

		if (!target)				// Near player monster search
		{
			if (master && (master.health > 0) && (master.player))
				mo = master.RoughMonsterSearch(20);
			else
				mo = RoughMonsterSearch(20);
			target = mo;
		}

		if (!target)				// Normal monster search
		{
			ThinkerIterator it = ThinkerIterator.Create("Actor");

			while ((mo = Actor(it.Next())) != null)
			{
				if (!mo.bIsMonster) continue;
				if (mo.health <= 0) continue;
				if (!mo.bShootable) continue;
				dist = Distance2D(mo);
				if (dist > MINOTAUR_LOOK_DIST) continue;
				if (mo == master || mo == self) continue;
				if (mo.bSummonedMonster && mo.tracer == master) continue;
				target = mo;
				break;			// Found actor to attack
			}
		}

		if (target)
		{
			SetState (SeeState, true);
		}
		else
		{
			SetStateLabel ("Roam", true);
		}
	}

	void A_MinotaurChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		let mf = MinotaurFriend(self);
		if (!mf)
		{
			A_EEChase(melee,missile,flags,type,value1,value2,value3,value4,value5,value6);
			return;
		}

		// In case pain caused him to skip his fade in.
		A_SetRenderStyle(1, STYLE_Normal);

		if (mf.StartTime >= 0 && (level.maptime - mf.StartTime) >= MAULATORTICS)
		{
			DamageMobj (null, null, TELEFRAG_DAMAGE, 'None', 0, 0.0);
			return;
		}

		if (random[MinotaurChase]() < 30)
			A_MinotaurLook();		// adjust to closest target

		if (!target || (target.health <= 0) || !target.bShootable)
		{
			// look for a new target
			SetIdle();
			return;
		}

		FaceMovementDirection ();
		reactiontime = 0;

		// Melee attack
		if (MeleeState && CheckMeleeRange ())
		{
			if (AttackSound)
			{
				A_StartSound(AttackSound, CHAN_WEAPON);
			}
			SetState (MeleeState);
			return;
		}

		// Missile attack
		if (MissileState && CheckMissileRange())
		{
			SetState (MissileState);
			return;
		}

		// chase towards target
		if (!MonsterMove ())
		{
			NewChaseDir ();
			FaceMovementDirection ();
		}

		// Active sound
		if (random[MinotaurChase]() < 6)
		{
			PlayActiveSound ();
		}
	}
}
class MaulotaurFriendBase : MaulotaurBase
{
	int StartTime;

	override void BeginPlay ()
	{
		Super.BeginPlay ();
		StartTime = -1;
	}

	override void Die (Actor source, Actor inflictor, int dmgflags)
	{
		Super.Die (source, inflictor, dmgflags);

		if (tracer && tracer.health > 0 && tracer.player)
		{
			// Search thinker list for minotaur
			ThinkerIterator it = ThinkerIterator.Create("MaulotaurFriendBase");
			MinotaurFriend mo;

			while ((mo = MinotaurFriend(it.Next())) != null)
			{
				if (mo.health <= 0) continue;
				// [RH] Minotaurs can't be morphed, so this isn't needed
				//if (!(mo.flags&MF_COUNTKILL)) continue;		// for morphed minotaurs
				if (mo.bCorpse) continue;
				if (mo.StartTime >= 0 && (level.maptime - StartTime) >= MAULATORTICS) continue;
				if (mo.tracer != null && mo.tracer.player == tracer.player) break;
			}

			if (mo == null)
			{
				Inventory power = tracer.FindInventory("PowerMinotaur");
				if (power != null)
				{
					power.Destroy ();
				}
			}
		}
	}
}


// A subclass for the DD/AFD unique monsters
class DDOrigCreature : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
	
	override void Tick()
	{
		if (GetAge() <= 35)
		{
			if (!(DDOrigBoss(self) || SugarSnake(self) || MiniSugarSnake(self)))
			{
				actor player = players[0].mo;
				if (A_CheckDDGame()) bLOOKALLAROUND = false;
			}
		}
		super.Tick();
	}
}

class CoSForsaken : EECreature abstract
{
	double prevalpha, prevalpha2, prevalpha3, prevalpha4;
	default
	{
		+LOOKALLAROUND;
		+NOFEAR;
		Species "ForsakenOnes";
		+DONTHARMSPECIES;
		+NOINFIGHTSPECIES;
		+THRUSPECIES;
		+MTHRUSPECIES;
	}
	
	override void Tick()
	{
		if (health > 0 && !A_CheckDDGame())
		{
			A_SetInventory("ForsakenCloakResist",1);
			if (dydudebug_forsakencloaks) Console.Printf("(%s) visdir: %d, Cloak: %d, alpha: %.8f (prev: %.8f) (prev2: %.8f) (prev3: %.8f) (prev4: %.8f) [tic: %d]", GetClassName(), visdir, CountInv("ForsakenCloakResist"), alpha, prevalpha, prevalpha2, prevalpha3, prevalpha4, gametic);
		}
		
		EECreature.Tick();
		prevalpha4 = prevalpha3;
		prevalpha3 = prevalpha2;
		prevalpha2 = prevalpha;
		prevalpha = alpha;
	}
	
	void A_ForSpawnCloud(int type = 0)
	{
		bool doit = true;
		if (random(1,8) <= 7 && A_CheckIfCCIllusion() == true) doit = false;

		if (doit)
		{
			if (type == 0)
			{
				A_SpawnItemEx("GhostCloud", 0, 0, 30, random(-2, 2), random(-2, 2), random(-1, 1), 0.0, SXF_CLIENTSIDE|SXF_SETTRACER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
				if (random(1,16) <= 6) A_SpawnItemEx("GhostCloud", 0, 0, 30, random(-2, 2), random(-2, 2), random(-1, 1), 0.0, SXF_CLIENTSIDE|SXF_SETTRACER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
			}
			if (type == 1)
			{
				A_SpawnItemEx("GhostCloud", 0, 0, 30, random(-2, 2), random(-2, 2), random(-1, 1), 0.0, SXF_CLIENTSIDE|SXF_SETTRACER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
				if (random(1,16) <= random(5,7)) A_SpawnItemEx("GhostCloud", 0, 0, 30, random(-2, 2), random(-2, 2), random(-1, 1), 0.0, SXF_CLIENTSIDE|SXF_SETTRACER|SXF_TRANSFERPOINTERS|SXF_NOCHECKPOSITION);
			}
		}
	}
}

// A subclass for the DD/AFD unique monsters
class DDAFDNPC : EECreature abstract
{
	default
	{
		MONSTER;
		+FLOORCLIP;
		+NOINFIGHTING;
		+NOBLOOD;
		+DONTTHRUST;
		+NODAMAGETHRUST;
		+LOOKALLAROUND;
		+NOICEDEATH;
		-COUNTKILL;
	}
}

class DDMiniTank : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
		-COUNTKILL;
	}
}

class DDHoganTarget : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

// A subclass for the DD/AFD unique boss-class enemies
class DDOrigBoss : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
		+NOICEDEATH;
	}
}

class DDMorphedCreature : MorphedMonster abstract
{
}

class ShieldPartBase : EEBaseZSC
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
		+DONTSPLASH;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (dydudebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}
		
		int olddmg = damage;
		damage = 1;
		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		EEProjectile UniqueProjectile;
		EEFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = EEProjectile(other);
		UniqueProjectileFast = EEFastProjectile(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPartBase [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			if (playpawn) return false; // Player Checking

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (dydudebug_shieldcollision) Console.Printf("\cyShieldPartBase (gametic %d):\c- UniqueProjectile: %s", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;

				//Console.Printf("BFGShot (%d)", passive);
				if (JackShotShieldPart(self) || JackShotShieldPartFoe(self))
				{
					if (dydudebug_shieldcollision) Console.Printf("\cyShieldPartBase BFGShot Dispersal (gametic %d):\c- UniqueProjectile: %s", gametic, UniqueProjectile.GetClassName());
					BFGBallBase bfgshot;
					bfgshot = BFGBallBase(other);
					if (bfgshot && !bREFLECTIVE)
					{
						bfgshot.bMISSILE = false;
						bfgshot.A_ScaleVelocity(0);
						bfgshot.SetStateLabel("ShotDown");
						bfgshot.A_SetScale(bfgshot.scale.x*0.5,bfgshot.scale.y*0.5);
						return false;
					}
				}
			}
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
			}

			if (other)
			{
				if (HealBall(other) || HealBallEE(other)) return false;
				if (PopperPuff1(other) && playpawn) return false;
				if (PopperPuff2(other) && playpawn) return false;
				if (BarrierBeam(other)) return false;
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					if (dydudebug_shieldcollision) Console.Printf("Found Monster (%s) [passive side]", other.GetClassName());
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
						// Swing Shields
						if (WhipShieldPart(self) || WhipShieldPartNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("WhipShieldPart[NoReflect] (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (KickShieldReflect(self) || KickShieldNoReflect(self) ||
								EvilKickShieldReflect(self) || EvilKickShieldNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("KickShield[No]Reflect (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (ScramblerSwingShieldPart(self) || ScramblerSwingPartNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("ScramblerSwingShieldPart (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (AppleJackSwingShieldPart(self) || AppleJackSwingPartNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("AppleJackSwingShieldPart (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (CricketSwingShieldPart(self) || CricketSwingPartNoReflect(self) ||
								CricketSwingShieldShort(self) || CricketSwingShortNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("CricketSwingShield[Part/Short] (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (ShieldPartMeleeReflect(self) || ShieldPartMeleeNoReflect(self))
						{
							if (dydudebug_shieldcollision) Console.Printf("ShieldPartMelee (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (other)
			{
				if (HealBall(other) || HealBallEE(other)) return false;
				if (EvilWarriorShieldBall(other) || EvilWarriorShieldBall(other)) return false;
			}
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPartMelee (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class NoItemSpawn : EEBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : EEPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	
	override void PostBeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("PlayingDoom64")) { A_SetSize((radius*1.2),(height*1.2),false); }
		super.PostBeginPlay();
	}
	
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
			
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cySwingShieldPartNoReflect (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			if (playpawn) return false; // Player Checking
			
			if (other)
			{
				if (other.bMISSILE)
				{
					//
					return true;
				}
				if (other.bISMONSTER)
				{
					//
					return false;
				}
			}
			
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class PlayerWhistle : EEBaseZSC
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	
	int A_GetPlayerLvlProj(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvlProj - PlayerWhistle)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = A_GetPlayerLvlProj(1);
						if (TruePlayerLevel >= 25) 
						{
							dmg = random(2,4);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 50) 
						{
							dmg = random(3,4);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 75) 
						{
							dmg = random(4,5);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 100) 
						{
							dmg = random(5,6);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 125) 
						{
							dmg = random(6,7);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 150) 
						{
							dmg = random(7,7);
							dmg += random(0,2);
						}
						if (TruePlayerLevel >= 175) 
						{
							dmg = random(8,9);
							dmg += random(0,1);
						}
						if (TruePlayerLevel >= 200) 
						{
							dmg = random(9,10);
							dmg += random(0,2);
						}
						
						dmg += (TruePlayerLevel * frandompick(0.09375,0.125,0.15625));
						if (TruePlayerLevel >= 50) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 100) dmg += (TruePlayerLevel * frandompick(0.046875,0.0625,0.078125));
						if (TruePlayerLevel >= 150) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						if (TruePlayerLevel >= 200) dmg += (TruePlayerLevel * frandompick(0.0234375,0.03125,0.0390625));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("PowerStrengthDD")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				if (target.GetClassName() == "DinahPlayer")
				{
					A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
					A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
				}
			}
			TNT1 A 1 
			{
				if (target && target.GetClassName() == "DinahPlayer")
				{
					A_AlertMonsters();
				}
			}
			stop;
	}
}

class BatNew : EEBaseZSC replaces Bat
{
	Default
	{
		Speed 5;
		Radius 3;
		Height 3;
		+NOBLOCKMAP +NOGRAVITY +MISSILE
		+NOTELEPORT +CANPASS
	}

	States
	{
		Spawn:
			ABAT ABC 2 A_BatMove;
			Loop;
		Death:
			ABAT A 2;
			Stop;
	}
	
	void A_BatMove()
	{
		if (special2 < 0)
		{
			SetStateLabel ("Death");
		}
		special2 -= 2;		// Called every 2 tics

		double newangle;
		if (random[BatMove]() < 128)
		{
			newangle = Angle + args[4];
		}
		else
		{
			newangle = Angle - args[4];
		}

		// Adjust velocity vector to new direction
		VelFromAngle(Speed, newangle);

		if (random[BatMove]() < 15)
		{
			A_StartSound ("BatScream", CHAN_VOICE, CHANF_DEFAULT, 1, ATTN_IDLE);
		}

		// Handle Z movement
		if (target)
		{
			SetZ(target.pos.Z + 2 * BobSin(args[0]));
			args[0] = (args[0] + 3) & 63;	
		}
	}
}

class PoisonCloudEE : EEBaseZSC replaces PoisonCloud
{
	Default
	{
		Tag "Poisonous Mushroom Bog";
		Radius 20;
		Height 30;
		Mass 0x7fffffff;
		+NOBLOCKMAP;
		+NOGRAVITY;
		+DROPOFF;
		+NODAMAGETHRUST;
		+DONTSPLASH;
		+FOILINVUL;
		+CANBLAST;
		+BLOODLESSIMPACT;
		+BLOCKEDBYSOLIDACTORS;
		+FORCEZERORADIUSDMG;
		+OLDRADIUSDMG;
		RenderStyle "Translucent";
		Alpha 0.6;
		DeathSound "PoisonShroomDeath";
		DamageType "PoisonCloud";
	}

	States
	{
		Spawn:
			PSBG D 1;
			PSBG D 1 A_Scream();
			PSBG DEEEFFFGGGHHHII 2 A_PoisonBagDamage;
			PSBG I 2 A_PoisonBagCheck;
			PSBG I 1 A_PoisonBagCheck;
			Goto Spawn + 3;
		Death:
			PSBG HG 7;
			PSBG FD 6;
			Stop;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override void BeginPlay ()
	{
		Vel.X = MinVel; // missile objects must move to impact other objects
		special1 = random[PoisonCloud](24, 31);
		special2 = 0;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim.player)
		{
			DDPlayerPawn playpawn;
			playpawn = DDPlayerPawn(victim);
			bool mate = (target != null && victim.player != target.player && victim.IsTeammate (target));
			bool dopoison;
			
			if (!mate)
			{
				dopoison = victim.player.poisoncount < 4;
			}
			else
			{
				dopoison = victim.player.poisoncount < (int)(4. * level.teamdamage);
			}

			if (dopoison)
			{
				damage = random[PoisonCloud](15, 30);
				if (mate)
				{
					damage = (int)(damage * level.teamdamage);
				}
				// Handle passive damage modifiers (e.g. PowerProtection)
				damage = victim.GetModifiedDamage(damagetype, damage, true);
				// Modify with damage factors
				damage = victim.ApplyDamageFactor(damagetype, damage);
				if (damage > 0)
				{
					victim.player.PoisonDamage (self, random[PoisonCloud](15, 30), false); // Don't play painsound

					// If successful, play the poison sound.
					if (victim.player.PoisonPlayer (self, self.target, 50))
					{
						if (playpawn) playpawn.A_DDPain();
						else victim.A_StartSound ("*poison", CHAN_VOICE);
					}
				}
			}	
			return -1;
		}
		else if (!victim.bIsMonster)
		{ // only damage monsters/players with the poison cloud
			return -1;
		}
		return damage;
	}
	
	//===========================================================================
	//
	// A_PoisonBagCheck
	//
	//===========================================================================

	void A_PoisonBagCheck()
	{
		if (--special1 <= 0)
		{
			SetStateLabel("Death");
		}
	}

	//===========================================================================
	//
	// A_PoisonBagDamage
	//
	//===========================================================================

	void A_PoisonBagDamage()
	{
		A_Explode(4, 40);
		AddZ(BobSin(special2) / 16);
		special2 = (special2 + 1) & 63;
	}
}

// Practice Target
class PracticeTarget : EECreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : EECreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class ItemFallSpot : Actor
{
	default
	{
		height 1;
		radius 1;
		+NOINTERACTION;
	}
	states
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				int attn = ATTN_NORM;
				if (dydudebug_itempitfalls) attn = ATTN_NONE;
				A_StartSound("fall/quick",CHAN_AUTO,CHANF_DEFAULT,frandom(0.8,1.2),attn,frandom(0.8,1.2));
			}
			TNT1 A 18;
			stop;
	}
}

class TeleGlitterGenerator1Ex : TeleGlitterGenerator1
{
}
class TeleGlitterGenerator2Ex : TeleGlitterGenerator2
{
}

class STGrenade : EEProjectile
{
	default
	{
		Tag "Grenade";
		Radius 8;
		Height 8;
		Speed 25;
		DamageType "Explosive";
		DamageFunction (20 * random(1,8));
		Scale 1.125;
		Gravity 0.50;
		Projectile;
		BounceCount 0;
		BounceFactor 0.8;
		WallBounceFactor 0.8;
		-NOGRAVITY;
		+DEHEXPLOSION;
		+GRENADETRAIL;
		+BOUNCEONWALLS;
		+BOUNCEONFLOORS;
		+BOUNCEONCEILINGS;
		+EXPLODEONWATER;
		//+DONTREFLECT;
		SeeSound "Weapons/GrBnce";
		BounceSound "Weapons/GrBnce";
		WallBounceSound "Weapons/GrBnce";
	}
	
	States
	{
		Spawn:
			SGRN A 0 Bright NoDelay
			{
				user_fusemax = random(95,115);
				A_StartSound("Weapons/GrenLF");
			}
		Idle:
			SGRN A 1 Bright 
			{
				user_fuse += 1;
				if (user_fuse >= user_fusemax) { return resolvestate("Death"); }
				return resolvestate(null);
			}
			loop;

		Death:
			TNT1 A 0 
			{
				A_StartSound("Weapons/GrenLX",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
			}
			MISL B 0 Bright 
			{
				bNOGRAVITY = true;
				A_ScaleVelocity(0);
				A_SetScale(1.0);
			}
			MISL B 8 Bright A_Explode(128,128,XF_HURTSOURCE,false,0,0,10,"BulletPuff","Explosive");
			MISL C 6 Bright;
			MISL D 4 Bright;
			stop;
	}
}

class STGrenadeNoAOE : STGrenade
{
	default
	{
		DamageType "Explosive";
	}

	States
	{
		Spawn:
			SGRN A 0 Bright NoDelay
			{
				user_fusemax = random(95,115);
				A_StartSound("Weapons/GrenLF");
			}
		Idle:
			SGRN A 1 Bright 
			{
				user_fuse += 1;
				if (user_fuse >= user_fusemax) { return resolvestate("Death"); }
				return resolvestate(null);
			}
			loop;

		Death:
			TNT1 A 0 
			{
				A_StartSound("Weapons/GrenLX",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
			}
			MISL B 0 Bright 
			{
				bNOGRAVITY = true;
				A_ScaleVelocity(0);
				A_SetScale(1.0);
			}
			MISL B 8 Bright A_Explode(128,128,0,false,0,0,10,"BulletPuff","Explosive");
			MISL C 6 Bright;
			MISL D 4 Bright;
			stop;
	}
}

class STGrenadeMonster : STGrenade
{
	default
	{
		Tag "Grenade";
		Radius 8;
		Height 8;
		Speed 25;
		DamageType "Explosive";
		DamageFunction (20 * random(1,8));
		Scale 1.0;
		Gravity 0.50;
		Projectile;
		BounceCount 0;
		BounceFactor 0.8;
		WallBounceFactor 0.8;
		-NOGRAVITY
		+DEHEXPLOSION
		+GRENADETRAIL;
		+BOUNCEONWALLS;
		+BOUNCEONFLOORS;
		+BOUNCEONCEILINGS;
		+EXPLODEONWATER;
		//+DONTREFLECT
		SeeSound "Weapons/GrBnce";
		BounceSound "Weapons/GrBnce";
		WallBounceSound "Weapons/GrBnce";
	}
	
	States
	{
		Spawn:
			SGRN A 0 Bright NoDelay
			{
				user_fusemax = random(95,115);
				A_StartSound("Weapons/GrenLF");
			}
		Idle:
			SGRN A 1 Bright 
			{
				user_fuse += 1;
				if (user_fuse >= user_fusemax) { return resolvestate("Death"); }
				return resolvestate(null);
			}
			loop;

		Death:
			TNT1 A 0 
			{
				A_StartSound("Weapons/GrenLX",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
			}
			MISL B 0 Bright 
			{
				bNOGRAVITY = true;
				A_ScaleVelocity(0);
				A_SetScale(1.0);
			}
			MISL B 8 Bright A_Explode(128,128,XF_HURTSOURCE,false,0,0,10,"BulletPuff","Explosive");
			MISL C 6 Bright;
			MISL D 4 Bright;
			Stop;
	}
}
class ArchvileFlame : SingleDamageRipper
{
	default
	{
		Tag "Flame Jet";
		Radius 2;
		Height 2;
		Speed 20;
		DamageFunction (randompick(7,8));
		RenderStyle "Add";
		Alpha 0.5;
		Scale 0.75;
		PROJECTILE;
		+FLOORHUGGER;
		+RIPPER;
		+BLOODLESSIMPACT;
		+NODAMAGETHRUST;
		Damagetype "Fire";
	}
	
	States
	{
		Spawn:
		Idle:
			FIRE A 1 bright
			{
			}
			FIRE A 1 bright
			{
				A_SpawnProjectile("ArchvileFlameTrail",0,0,0);
				A_Explode(randompick(26,26,26,27),randompick(52,53),0,0,random(7,8));
			}
			Loop; 
		Death:
			FIRE BCBCDEFGH 1 bright
			{
				A_Explode(randompick(13,13,13,13,13,13,14,14),randompick(78,79),0,0,random(21,24));
			}
			Stop;
	}
}

class ArchvileFlameTrail : EEBaseZSC
{
	default
	{
		Radius 2;
		Height 2;
		RenderStyle "Add";
		Alpha 0.7;
		Scale 0.925;
		+NOCLIP;
		+CLIENTSIDEONLY;
		+NOINTERACTION;
	}
	
	States
	{
		Spawn:
			FIRE BCBCDEFGH 2 bright
			{
				A_FadeOut(frandom(0.06,0.10));
				A_SetScale(scale.x-frandom(0.06,0.10),scale.y-frandom(0.06,0.10));
			}
			Stop;
		Death:
			TNT1 A 1;
			Stop;
	}
}

