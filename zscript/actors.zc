// Base class [for later use]
class DDBaseZSC : Actor abstract
{
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	int CharacterClass;
	
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double oldVelZ;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);

		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Bap') { }
		if (damagetype == 'Cricket') { }
		if (damagetype == 'Bonk') { }
		if (damagetype == 'Lead') { }
		if (damagetype == 'Chop') { }
		if (damagetype == 'Breakfast') { }
		if (damagetype == 'Zap') { }
		if (damagetype == 'Suck') { }
		if (damagetype == 'Dust') { }
		if (damagetype == 'Musak') { }
		if (damagetype == 'Fire') { }
		if (damagetype == 'CherryBomb') { }
		if (damagetype == 'Spinner') { }
		if (damagetype == 'BRocket') { }
		if (damagetype == 'Popper') { }
		if (damagetype == 'Tank') { }
		if (damagetype == 'Boiling') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}

	action state A_CheckSolidFooting(StateLabel label, int flags = CSF_ALL)
	{
		// small optimization: if our z-vel has changed, we aren't standing on something
		if (invoker.oldVelZ != vel.z)
				return null;
		
		// are we standing on solid ground?
		if (abs(pos.z - GetZAt()) <= 1)
		{
				if (flags & CSF_SOLIDGROUND)
						return ResolveState(label);
		}
		
		// are we standing on an actor?
		bool ok; Actor below;
		[ok, below] = TestMobjZ(true);
		if (below)
		{
				if (flags & CSF_SOLIDACTORS)
						return ResolveState(label);
		}
		
		// has our z-velocity not changed?
		if (vel.z == invoker.oldVelZ && (flags & CSF_SOLIDGROUND))
				return ResolveState(label);
		
		// we aren't standing on anything
		return null;
	}

	void A_Destroy()
	{
		self.Destroy();
	}
}

// Base Projectile Class
class DDProjectile : DDBaseZSC abstract
{
	mixin InvWeaponShare;
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;

	int xyspreadtime;
	int zspreadtime;
	int ipprojid;
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	bool IPattack;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem) PlayerLevel = MiscItem.PlayerLevel;
		}
	}

	override void Tick()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (dydudebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		/*
		user_sparksizelevel = MartialArtsMastery + BerserkerFit;
		if (user_sparksizelevel <= 0) { A_SetScale(0.3125); A_FadeTo(0.6875); }
		if (user_sparksizelevel == 1) { A_SetScale(0.375); A_FadeTo(0.75); }
		if (user_sparksizelevel == 2) { A_SetScale(0.4375); A_FadeTo(0.8125); }
		if (user_sparksizelevel == 3) { A_SetScale(0.5); A_FadeTo(0.875); }
		if (user_sparksizelevel == 4) { A_SetScale(0.5625); A_FadeTo(0.9375); }
		if (user_sparksizelevel >= 5) { A_SetScale(0.625); A_FadeTo(1.0); }
		*/
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		//user_sparkscalemulti = (StamUpPerkLevel * 0.05) + (StamUpEXPerkLevel * 0.125);
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("PowerStrengthDD")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	int A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		bool debugsigilatkinfo;
		int result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		int perkfactor = 10000;
		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				BaseSigilMaxHealth = MiscItem.BaseStartMaxHealth;
				MaxHealthTrue =  MiscItem.MaxHealthTrue;
			}
			else return 32;
		}
		else
		{
			return 32;
		}
		
		if (attacktype == 0) // SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 32;
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 300 + random(-150,150); // 150 to 450
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 150 + random(-75,75); // 75 to 225
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 6) // SpectralLightningH2New
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 25 + random(-12,12); // 13 to 37
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 325 + random(-162,162); // 163 to 387
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		double minerror = 0.67;
		double maxerror = 1.34;

		if (radiustype == 0) // Direct Damage is randomized a lot
		{
			minerror = 0.67;
			maxerror = 1.34;
			if (playpawn) // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (debugsigilatkinfo) Console.Printf("Player Sigil Shot [damage] (%s), %d", AttackerName, attacktype);
				
				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.125); // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.275); // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.45); // +45% damage
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.65); // +65% damage
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.875); // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 2.125); // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 2.4); // +140% damage
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 2.7); // +170% damage
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 3.025); // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 3.375); // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.0625); // +6.25% damage
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.1375); // +13.75% damage
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.225); // +22.5% damage
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.325); // +32.5% damage
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.4375); // +43.75% damage
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.5625); // +56.25% damage
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.70); // +70% damage
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.85); // +85% damage
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 2.0125); // +101.25% damage
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 2.1875); // +118.75% damage
				
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (debugsigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugsigilatkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = result;
				finaldmg = result;
				if (attacktype != 0) finaldmg = floor(finaldmg * random(1,4)); // +STRIFEDAMAGE calculation
				nm = "EntityBoss"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecond"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 2.25);

				if (debugsigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}
		else // Radius is not randomized nearly as much
		{
			minerror = 0.925;
			maxerror = 1.075;
			if (playpawn)
			{
				if (debugsigilatkinfo) Console.Printf("Player Sigil Shot [radius] (%s), %d", AttackerName, attacktype);
				
				if (attacktype != 0)
				{
					if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
					{
						result *= 1.5;
						extradmg1 *= 1.5;
						extradmg2 *= 1.5;
						extradmg3 *= 1.5;
						extradmg4 *= 1.5;
						extradmg5 *= 1.5;
						extradmg6 *= 1.5;
					}
					if (attacktype == 6) // SpectralLightningH2New
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
					{
						result *= 0.75;
						extradmg1 *= 0.75;
						extradmg2 *= 0.75;
						extradmg3 *= 0.75;
						extradmg4 *= 0.75;
						extradmg5 *= 0.75;
						extradmg6 *= 0.75;
					}
					if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
					{
						result *= 2.5;
						extradmg1 *= 2.5;
						extradmg2 *= 2.5;
						extradmg3 *= 2.5;
						extradmg4 *= 2.5;
						extradmg5 *= 2.5;
						extradmg6 *= 2.5;
					}
				}

				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);

				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.03125);
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.06875);
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.1125);
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.1625);
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.21875); 
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 1.28125); 
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 1.35);
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 1.425);
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 1.50625); 
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 1.59375);
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.015625);
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.034375);
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.05625);
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.08125);
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.109375);
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.140625);
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.175);
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.2125);
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 1.253125);
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 1.296875);
				
				if (CharacterClass == 0) finaldmg = floor(finaldmg * 1.09375);
				if (CharacterClass == 1) finaldmg = floor(finaldmg * 1.03125);
				if (CharacterClass == 2) finaldmg = floor(finaldmg * 1.15625);
				if (CharacterClass == 8) finaldmg = floor(finaldmg * 1.125);
				if (CharacterClass == 9) finaldmg = floor(finaldmg * 1.0625);

				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 20;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;

				if (debugsigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugsigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}

		if (radiustype == 0) 
		{
			if (debugsigilatkinfo) Console.Printf("\cxSigil Damage Total: %d\c-", finaldmg);
			return finaldmg;
		}
		if (radiustype == 1) 
		{
			if (debugsigilatkinfo) Console.Printf("\cxSigil Radius Total: %d\c-", finaldmg);
			return finaldmg;
		}
		return 32;
	}
	
	// Handle Fractal Egg Split Offs
	void A_EggGrenades(string eggname = "EggGrenade", double zheight = 2, double zheightadd = 35, double xyvelmin = 6, double xyvelmax = 6, double zvelmin = 6, double zvelmax = 12)
	{
		bool success;
		actor EggShots;
		actor player = players[0].mo;
		if (hitaceiling) { [success, EggShots] = A_ThrowGrenadeAngle(eggname,-zheight,-zheightadd,random(xyvelmin,xyvelmax),random(-zvelmax,-zvelmin),checkspawn:false); }
								else { [success, EggShots] = A_ThrowGrenadeAngle(eggname,zheight,0,random(xyvelmin,xyvelmax),random(zvelmin,zvelmax),checkspawn:false); }
		if (dydudebug_eggfractals) Console.Printf("\c[blue]success [%s]:\c- %d", GetClassName(), success);
		if (EggShots) // && success) 
		{
			EggShots.target = player; // EggShots.target = self.target;
			if (IPAttack)
			{
				DDProjectile IPCompat; 
				IPCompat = DDProjectile(EggShots);
				if (IPCompat)
				{
					IPCompat.target = player;
					IPCompat.IPattack = true;
				}
			}
			if (EggShots.target && dydudebug_eggfractals) Console.Printf("EggShots.\c[fire]target [\c[sapphire]%s\c-]:\c- %s", GetClassName(), EggShots.target.GetClassName());
		}
	}
	
	// Sigil
	void A_SpectralLightning()
	{
		DDProjectile flash2;

		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = "SpectralLightningV2New";
		else cls = "SpectralLightningV1New";

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = DDProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}

		flash = Spawn("SpectralLightningV2New", (pos.xy, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = DDProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}
	}
	
	void A_SpectralLightningTail()
	{
		Actor foo = Spawn("SpectralLightningHTailNew", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			if (target) foo.Target = Target;
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}
	
	void A_SpectralBigBallLightning()
	{
		Actor foo;
		DDProjectile foo2;
		Class<Actor> cls = "SpectralLightningH3New";
		if (cls)
		{
			angle += 90.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = DDProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle += 180.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = DDProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle -= 270.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = DDProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
		}
	}
}

// Base FastProjectile Class
class DDFastProjectile : DDProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (target.GetClassName() == "DinahPlayer")
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel ();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : DDProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : DDFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class DDPuff : DDProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (target.GetClassName() == "DinahPlayer")
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class DDVisualAImage : DDBaseZSC abstract
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 0.85;
		RenderStyle "Add";
		+NOGRAVITY
		+THRUACTORS
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	States
	{
		Spawn:
			TNT1 AA 1 Bright;
			Stop;
	}
}

class DDProp : DDBaseZSC abstract
{
}

class DDCreature : DDBaseZSC abstract
{
	mixin MonsterCollider;
	int bossdeathactivate;
	bool IPAttackSummon;
}

// A subclass for the DD/AFD unique monsters
class DDOrigCreature : DDCreature abstract
{
}

// A subclass for the DD/AFD unique boss-class enemies
class DDOrigBoss : DDCreature abstract
{
}

class DDMorphedCreature : MorphedMonster abstract
{
}

class ShieldPartBase : DDBaseZSC
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID;
		//+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (dydudebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}

		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class NoItemSpawn : DDBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : DDPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				A_StartSound("CricketBat/ShieldHit", CHAN_WEAPON);
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class PlayerWhistle : DDBaseZSC
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						if (MiscItem.PlayerLevel >= 25) dmg = random(2,4);
						if (MiscItem.PlayerLevel >= 50) dmg = random(3,4);
						if (MiscItem.PlayerLevel >= 75) dmg = random(4,5);
						if (MiscItem.PlayerLevel >= 100) dmg = random(5,5);
						if (MiscItem.PlayerLevel >= 125) dmg = random(6,7);
						if (MiscItem.PlayerLevel >= 150) dmg = random(7,7);
						if (MiscItem.PlayerLevel >= 175) dmg = random(8,9);
						if (MiscItem.PlayerLevel >= 200) dmg = random(9,9);
						dmg += (MiscItem.PlayerLevel * frandompick(0.1875,0.25,0.3125));
						
						range = 64;
						range += (MiscItem.PlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("PowerStrengthDD")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 A_AlertMonsters();
			stop;
	}
}

class BatNew : DDBaseZSC replaces Bat
{
	Default
	{
		Speed 5;
		Radius 3;
		Height 3;
		+NOBLOCKMAP +NOGRAVITY +MISSILE
		+NOTELEPORT +CANPASS
	}

	States
	{
		Spawn:
			ABAT ABC 2 A_BatMove;
			Loop;
		Death:
			ABAT A 2;
			Stop;
	}
	
	void A_BatMove()
	{
		if (special2 < 0)
		{
			SetStateLabel ("Death");
		}
		special2 -= 2;		// Called every 2 tics

		double newangle;
		if (random[BatMove]() < 128)
		{
			newangle = Angle + args[4];
		}
		else
		{
			newangle = Angle - args[4];
		}

		// Adjust velocity vector to new direction
		VelFromAngle(Speed, newangle);

		if (random[BatMove]() < 15)
		{
			A_StartSound ("BatScream", CHAN_VOICE, CHANF_DEFAULT, 1, ATTN_IDLE);
		}

		// Handle Z movement
		if (target)
		{
			SetZ(target.pos.Z + 2 * BobSin(args[0]));
			args[0] = (args[0] + 3) & 63;	
		}
	}
}

class PoisonCloudEE : DDBaseZSC replaces PoisonCloud
{
	Default
	{
		Tag "Poisonous Mushroom Bog";
		Radius 20;
		Height 30;
		Mass 0x7fffffff;
		+NOBLOCKMAP +NOGRAVITY +DROPOFF
		+NODAMAGETHRUST
		+DONTSPLASH +FOILINVUL +CANBLAST +BLOODLESSIMPACT +BLOCKEDBYSOLIDACTORS +FORCEZERORADIUSDMG +OLDRADIUSDMG
		RenderStyle "Translucent";
		Alpha 0.6;
		DeathSound "PoisonShroomDeath";
		DamageType "PoisonCloud";
	}

	States
	{
		Spawn:
			PSBG D 1;
			PSBG D 1 A_Scream;
			PSBG DEEEFFFGGGHHHII 2 A_PoisonBagDamage;
			PSBG I 2 A_PoisonBagCheck;
			PSBG I 1 A_PoisonBagCheck;
			Goto Spawn + 3;
		Death:
			PSBG HG 7;
			PSBG FD 6;
			Stop;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override void BeginPlay ()
	{
		Vel.X = MinVel; // missile objects must move to impact other objects
		special1 = random[PoisonCloud](24, 31);
		special2 = 0;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim.player)
		{
			DDPlayerPawn playpawn;
			playpawn = DDPlayerPawn(victim);
			bool mate = (target != null && victim.player != target.player && victim.IsTeammate (target));
			bool dopoison;
			
			if (!mate)
			{
				dopoison = victim.player.poisoncount < 4;
			}
			else
			{
				dopoison = victim.player.poisoncount < (int)(4. * level.teamdamage);
			}

			if (dopoison)
			{
				damage = random[PoisonCloud](15, 30);
				if (mate)
				{
					damage = (int)(damage * level.teamdamage);
				}
				// Handle passive damage modifiers (e.g. PowerProtection)
				damage = victim.GetModifiedDamage(damagetype, damage, true);
				// Modify with damage factors
				damage = victim.ApplyDamageFactor(damagetype, damage);
				if (damage > 0)
				{
					victim.player.PoisonDamage (self, random[PoisonCloud](15, 30), false); // Don't play painsound

					// If successful, play the poison sound.
					if (victim.player.PoisonPlayer (self, self.target, 50))
					{
						if (playpawn) playpawn.A_DDPain();
						else victim.A_StartSound ("*poison", CHAN_VOICE);
					}
				}
			}	
			return -1;
		}
		else if (!victim.bIsMonster)
		{ // only damage monsters/players with the poison cloud
			return -1;
		}
		return damage;
	}
	
	//===========================================================================
	//
	// A_PoisonBagCheck
	//
	//===========================================================================

	void A_PoisonBagCheck()
	{
		if (--special1 <= 0)
		{
			SetStateLabel("Death");
		}
	}

	//===========================================================================
	//
	// A_PoisonBagDamage
	//
	//===========================================================================

	void A_PoisonBagDamage()
	{
		A_Explode(4, 40);
		AddZ(BobSin(special2) / 16);
		special2 = (special2 + 1) & 63;
	}
}

// Practice Target
class PracticeTarget : DDCreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright;
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) targetdummyhitcooldown--;
				if (targetdummyhitcooldown == 0) { A_EEHealThing(10000000, SpawnHealth(), 1); }
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : DDCreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category EE Monsters
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+SOLID;
		+NOPAIN;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright;
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) targetdummyhitcooldown--;
				if (targetdummyhitcooldown == 0) { A_EEHealThing(10000000, SpawnHealth(), 1); }
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}