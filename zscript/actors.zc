// Base class [for later use]
class DDBaseZSC : Actor abstract
{
	mixin DmgCalc;
	mixin CollisionChecker;
	int CharacterClass;
	
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	double oldVelZ;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);

		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Bap') { }
		if (damagetype == 'Cricket') { }
		if (damagetype == 'Bonk') { }
		if (damagetype == 'Lead') { }
		if (damagetype == 'Chop') { }
		if (damagetype == 'Breakfast') { }
		if (damagetype == 'Zap') { }
		if (damagetype == 'Suck') { }
		if (damagetype == 'Dust') { }
		if (damagetype == 'Musak') { }
		if (damagetype == 'Fire') { }
		if (damagetype == 'CherryBomb') { }
		if (damagetype == 'Spinner') { }
		if (damagetype == 'BRocket') { }
		if (damagetype == 'Popper') { }
		if (damagetype == 'Tank') { }
		if (damagetype == 'Boiling') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}

	action state A_CheckSolidFooting(StateLabel label, int flags = CSF_ALL)
	{
		// small optimization: if our z-vel has changed, we aren't standing on something
		if (invoker.oldVelZ != vel.z)
				return null;
		
		// are we standing on solid ground?
		if (abs(pos.z - GetZAt()) <= 1)
		{
				if (flags & CSF_SOLIDGROUND)
						return ResolveState(label);
		}
		
		// are we standing on an actor?
		bool ok; Actor below;
		[ok, below] = TestMobjZ(true);
		if (below)
		{
				if (flags & CSF_SOLIDACTORS)
						return ResolveState(label);
		}
		
		// has our z-velocity not changed?
		if (vel.z == invoker.oldVelZ && (flags & CSF_SOLIDGROUND))
				return ResolveState(label);
		
		// we aren't standing on anything
		return null;
	}

	void A_Destroy()
	{
		self.Destroy();
	}
}

// Base Projectile Class
class DDProjectile : DDBaseZSC abstract
{
	bool hitawall;
	bool hitaceiling;
	bool hitafloor;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/

	override void Tick()
	{
		if (target)
		{
			if (target.GetClassName() == "DinahPlayer")
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	int A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		bool debugsigilatkinfo;
		int result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		int perkfactor = 10000;
		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				BaseSigilMaxHealth = MiscItem.BaseStartMaxHealth;
				MaxHealthTrue =  MiscItem.MaxHealthTrue;
			}
			else return 32;
		}
		else
		{
			return 32;
		}
		
		if (attacktype == 0) // SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 32;
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 300 + random(-150,150); // 150 to 450
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 150 + random(-75,75); // 75 to 225
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 6) // SpectralLightningH2New
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 25 + random(-12,12); // 13 to 37
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 325 + random(-162,162); // 163 to 387
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		double minerror = 0.67;
		double maxerror = 1.34;

		if (radiustype == 0) // Direct Damage is randomized a lot
		{
			minerror = 0.67;
			maxerror = 1.34;
			if (playpawn) // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (debugsigilatkinfo) Console.Printf("Player Sigil Shot [damage] (%s), %d", AttackerName, attacktype);
				
				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.125); // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.275); // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.45); // +45% damage
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.65); // +65% damage
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.875); // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 2.125); // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 2.4); // +140% damage
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 2.7); // +170% damage
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 3.025); // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 3.375); // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.0625); // +6.25% damage
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.1375); // +13.75% damage
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.225); // +22.5% damage
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.325); // +32.5% damage
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.4375); // +43.75% damage
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.5625); // +56.25% damage
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.70); // +70% damage
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.85); // +85% damage
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 2.0125); // +101.25% damage
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 2.1875); // +118.75% damage
				
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (debugsigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugsigilatkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = result;
				finaldmg = result;
				if (attacktype != 0) finaldmg = floor(finaldmg * random(1,4)); // +STRIFEDAMAGE calculation
				nm = "EntityBoss"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecond"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 2.25);

				if (debugsigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}
		else // Radius is not randomized nearly as much
		{
			minerror = 0.925;
			maxerror = 1.075;
			if (playpawn)
			{
				if (debugsigilatkinfo) Console.Printf("Player Sigil Shot [radius] (%s), %d", AttackerName, attacktype);
				
				if (attacktype != 0)
				{
					if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
					{
						result *= 1.5;
						extradmg1 *= 1.5;
						extradmg2 *= 1.5;
						extradmg3 *= 1.5;
						extradmg4 *= 1.5;
						extradmg5 *= 1.5;
						extradmg6 *= 1.5;
					}
					if (attacktype == 6) // SpectralLightningH2New
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
					{
						result *= 0.75;
						extradmg1 *= 0.75;
						extradmg2 *= 0.75;
						extradmg3 *= 0.75;
						extradmg4 *= 0.75;
						extradmg5 *= 0.75;
						extradmg6 *= 0.75;
					}
					if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
					{
						result *= 2.5;
						extradmg1 *= 2.5;
						extradmg2 *= 2.5;
						extradmg3 *= 2.5;
						extradmg4 *= 2.5;
						extradmg5 *= 2.5;
						extradmg6 *= 2.5;
					}
				}

				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);

				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.03125);
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.06875);
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.1125);
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.1625);
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.21875); 
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 1.28125); 
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 1.35);
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 1.425);
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 1.50625); 
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 1.59375);
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.015625);
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.034375);
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.05625);
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.08125);
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.109375);
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.140625);
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.175);
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.2125);
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 1.253125);
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 1.296875);
				
				if (CharacterClass == 0) finaldmg = floor(finaldmg * 1.09375);
				if (CharacterClass == 1) finaldmg = floor(finaldmg * 1.03125);
				if (CharacterClass == 2) finaldmg = floor(finaldmg * 1.15625);
				if (CharacterClass == 8) finaldmg = floor(finaldmg * 1.125);
				if (CharacterClass == 9) finaldmg = floor(finaldmg * 1.0625);

				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 20;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;

				if (debugsigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugsigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}

		if (radiustype == 0) 
		{
			if (debugsigilatkinfo) Console.Printf("\cxSigil Damage Total: %d\c-", finaldmg);
			return finaldmg;
		}
		if (radiustype == 1) 
		{
			if (debugsigilatkinfo) Console.Printf("\cxSigil Radius Total: %d\c-", finaldmg);
			return finaldmg;
		}
		return 32;
	}
	
}

// Base FastProjectile Class
class DDFastProjectile : DDProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (target.GetClassName() == "DinahPlayer")
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}

		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel ();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : DDProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : DDFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class DDPuff : DDBaseZSC abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (target.GetClassName() == "DinahPlayer")
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: DDPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class DDVisualAImage : DDBaseZSC abstract
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 0.85;
		RenderStyle "Add";
		+NOGRAVITY
		+THRUACTORS
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	States
	{
		Spawn:
			TNT1 AA 1 Bright;
			Stop;
	}
}

class DDProp : DDBaseZSC abstract
{
}

class DDCreature : DDBaseZSC abstract
{
	mixin MonsterCollider;
}
	
class DDMorphedCreature : MorphedMonster abstract
{
}

class ShieldPartBase : DDBaseZSC
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID;
		//+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (dydudebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}

		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other)
			{
				if (other.bISMONSTER)
				{
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class NoItemSpawn : DDBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE 
		+AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				A_StartSound("CricketBat/ShieldHit", CHAN_WEAPON);
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
				//if (CountInv("PlayingDoom64")) { A_SetSize(19,19); }
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class PlayerWhistle : DDBaseZSC
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						if (MiscItem.PlayerLevel >= 25) dmg = random(2,4);
						if (MiscItem.PlayerLevel >= 50) dmg = random(3,4);
						if (MiscItem.PlayerLevel >= 75) dmg = random(4,5);
						if (MiscItem.PlayerLevel >= 100) dmg = random(5,5);
						if (MiscItem.PlayerLevel >= 125) dmg = random(6,7);
						if (MiscItem.PlayerLevel >= 150) dmg = random(7,7);
						if (MiscItem.PlayerLevel >= 175) dmg = random(8,9);
						if (MiscItem.PlayerLevel >= 200) dmg = random(9,9);
						dmg += (MiscItem.PlayerLevel * frandompick(0.1875,0.25,0.3125));
						
						range = 64;
						range += (MiscItem.PlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("PowerStrengthDD")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
				A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
			}
			TNT1 A 1 A_AlertMonsters();
			stop;
	}
}

class BatNew : DDBaseZSC replaces Bat
{
	Default
	{
		Speed 5;
		Radius 3;
		Height 3;
		+NOBLOCKMAP +NOGRAVITY +MISSILE
		+NOTELEPORT +CANPASS
	}

	States
	{
		Spawn:
			ABAT ABC 2 A_BatMove;
			Loop;
		Death:
			ABAT A 2;
			Stop;
	}
	
	void A_BatMove()
	{
		if (special2 < 0)
		{
			SetStateLabel ("Death");
		}
		special2 -= 2;		// Called every 2 tics

		double newangle;
		if (random[BatMove]() < 128)
		{
			newangle = Angle + args[4];
		}
		else
		{
			newangle = Angle - args[4];
		}

		// Adjust velocity vector to new direction
		VelFromAngle(Speed, newangle);

		if (random[BatMove]() < 15)
		{
			A_StartSound ("BatScream", CHAN_VOICE, CHANF_DEFAULT, 1, ATTN_IDLE);
		}

		// Handle Z movement
		if (target)
		{
			SetZ(target.pos.Z + 2 * BobSin(args[0]));
			args[0] = (args[0] + 3) & 63;	
		}
	}
}