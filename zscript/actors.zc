// Base class [for later use]
class EEBaseZSC : Actor abstract
{
	mixin DmgCalc;
	mixin CollisionChecker;
	mixin InvWeaponShare;
	
	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;
	
	int user_MaxHP;
	int hsexphealth;
	double oldVelZ;
	int user_random;
	int user_randompain;
	int finaldamagedealt;
	int finaldamagedealt2;
	
	int nightmarephasetimer;
	int nightmarephaserand;
	int nightmarealphatimeroffset;
	
	default
	{
		+CASTSPRITESHADOW;
		-NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		// add the following line to your actor's Tick() method
		oldVelZ = vel.z;
		
		super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEBaseZSC, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);

		string vict = "";
		if (target) vict = target.GetClassName();
		// New Code goes here
		if (damagetype == 'Bap') { }
		if (damagetype == 'Cricket') { }
		if (damagetype == 'Bonk') { }
		if (damagetype == 'Lead') { }
		if (damagetype == 'Chop') { }
		if (damagetype == 'Breakfast') { }
		if (damagetype == 'Zap') { }
		if (damagetype == 'Suck') { }
		if (damagetype == 'Dust') { }
		if (damagetype == 'Musak') { }
		if (damagetype == 'Fire') { }
		if (damagetype == 'CherryBomb') { }
		if (damagetype == 'Spinner') { }
		if (damagetype == 'BRocket') { }
		if (damagetype == 'Popper') { }
		if (damagetype == 'Tank') { }
		if (damagetype == 'Boiling') { }
		if (damagetype == 'Sigil') { }
		if (damagetype == 'SpectralLow') { }
		return damage;
	}
	
	action int A_GetArmorAmt()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		name armorclasstype = "KGArmor";
		
		int amt = 0;
		if (player) amt = player.CountInv(armorclasstype);

		return amt;
	}

	void A_NightmarePhase()
	{
		if (GetRenderStyle() == STYLE_Subtract)
		{
			double alphavar = 0.00;
			double alphavarbase = frandom(0.0375,0.0425);
			if (health > 0)
			{
				alphavarbase = frandom(0.0375,0.0425);
			}
			else
			{
				alphavarbase = frandom(0.00375,0.00425);
			}
			nightmarephasetimer = ((level.time + random(-nightmarephaserand,nightmarephaserand)) % 35);
			if (nightmarephasetimer == 0) alphavar = (alphavarbase * 0);
			if (nightmarephasetimer == 1 || nightmarephasetimer == 34) alphavar = (alphavarbase * 1);
			if (nightmarephasetimer == 2 || nightmarephasetimer == 33) alphavar = (alphavarbase * 2);
			if (nightmarephasetimer == 3 || nightmarephasetimer == 32) alphavar = (alphavarbase * 3);
			if (nightmarephasetimer == 4 || nightmarephasetimer == 31) alphavar = (alphavarbase * 4);
			if (nightmarephasetimer == 5 || nightmarephasetimer == 30) alphavar = (alphavarbase * 5);
			if (nightmarephasetimer == 6 || nightmarephasetimer == 29) alphavar = (alphavarbase * 6);
			if (nightmarephasetimer == 7 || nightmarephasetimer == 28) alphavar = (alphavarbase * 7);
			if (nightmarephasetimer == 8 || nightmarephasetimer == 27) alphavar = (alphavarbase * 8);
			if (nightmarephasetimer == 9 || nightmarephasetimer == 26) alphavar = (alphavarbase * 9);
			if (nightmarephasetimer == 10 || nightmarephasetimer == 25) alphavar = (alphavarbase * 10);
			if (nightmarephasetimer == 11 || nightmarephasetimer == 24) alphavar = (alphavarbase * 11);
			if (nightmarephasetimer == 12 || nightmarephasetimer == 23) alphavar = (alphavarbase * 12);
			if (nightmarephasetimer == 13 || nightmarephasetimer == 22) alphavar = (alphavarbase * 13);
			if (nightmarephasetimer == 14 || nightmarephasetimer == 21) alphavar = (alphavarbase * 14);
			if (nightmarephasetimer == 15 || nightmarephasetimer == 20) alphavar = (alphavarbase * 15);
			if (nightmarephasetimer == 16 || nightmarephasetimer == 19) alphavar = (alphavarbase * 16);
			if (nightmarephasetimer == 17 || nightmarephasetimer == 18) alphavar = (alphavarbase * 17);
			A_SetRenderStyle((0.7-alphavar),STYLE_Subtract);
			if (dydudebug_nightmarevisuals) Console.Printf("[%s] alphavar: %.2f (%.2f), nightmarephasetimer: %d", GetClassName(), alpha, alphavar, nightmarephasetimer);
		} 
	}
	
	action state A_CheckSolidFooting(StateLabel label, int flags = CSF_ALL)
	{
		// small optimization: if our z-vel has changed, we aren't standing on something
		if (invoker.oldVelZ != vel.z)
				return null;
		
		// are we standing on solid ground?
		if (abs(pos.z - GetZAt()) <= 1)
		{
				if (flags & CSF_SOLIDGROUND)
						return ResolveState(label);
		}
		
		// are we standing on an actor?
		bool ok; Actor below;
		[ok, below] = TestMobjZ(true);
		if (below)
		{
				if (flags & CSF_SOLIDACTORS)
						return ResolveState(label);
		}
		
		// has our z-velocity not changed?
		if (vel.z == invoker.oldVelZ && (flags & CSF_SOLIDGROUND))
				return ResolveState(label);
		
		// we aren't standing on anything
		return null;
	}
	
	void A_Feathers(string type = "Feather")
	{
		int count;

		if (health > 0)
		{ // Pain
			count = random[Feathers]() < 32 ? 2 : 1;
		}
		else
		{ // Death
			count = 5 + (random[Feathers](0, 3));
		}
		for (int i = 0; i < count; i++)
		{
			Actor mo = Spawn(type, pos + (0, 0, 20), NO_REPLACE);
			if (mo != null)
			{
				mo.target = self;
				mo.Vel.X = Random2[Feathers]() / 256.;
				mo.Vel.Y = Random2[Feathers]() / 256.;
				mo.Vel.Z = 1. + random[Feathers]() / 128.;
				mo.SetState (mo.SpawnState + (random[Feathers](0, 7)));
			}
		}
	}
	
	void A_Destroy()
	{
		self.Destroy();
	}
}

class EECustomGib : EEBaseZSC abstract
{
	int deathcounter;
	int fadecounter;
	int ownedgib;

	override void Tick()
	{
		if (GetAge() >= 0 && GetAge() <= 4) { if (target != null) ownedgib = 1; }
		if (ownedgib)
		{
			if (target && target.health > 0) A_FadeOut(0.0625);

			if (exex_gibswillfade)
			{
				int maxage;
				if (exex_gibswillfade > 0) maxage = exex_gibswillfade;
				if (exex_gibswillfade < 0) maxage = exex_gibswillfade * 35;
				if (GetAge() >= maxage)
				{
					fadecounter++;
					A_FadeOut((1.0/random(32,38)),FTF_REMOVE);
					if (fadecounter > 39) Destroy();
					if (dydudebug_deathgibfadedisplays) Console.Printf("\cy%s\c- alpha: \cx%.8f\c- - fadecounter: %d / 40", GetClassName(), alpha, fadecounter);
				}
				else
				{
					if (dydudebug_deathgibfadedisplays) Console.Printf("\cy%s\c- deathcounter: \cx%d\c-", GetClassName(), GetAge());
				}
			}
		}

		//This space for rent.
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}

// Custom Powerups/Items that obey the effect of "AetheriusTimeFreezer" that might be used for monsters [buffs/debuffs/cooldowns]
class EEPowerup : Powerup
{
	override void Tick()
	{
		// Powerups cannot exist outside an inventory
		if (Owner == NULL)
		{
			Destroy();
		}

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("PowerTimeFreezer") ||
				player.CountInv("DDMiscTimeFreezer") ||
				player.CountInv("DebugTimeFreezer") ||
				player.CountInv("TimePotionTimeFreezer") ||
				!player.player.timefreezer)
		{
			//Console.Printf("EffectTics: %d", EffectTics);
			EffectTics--;
		}
		if (EffectTics <= 0)
		{
			Destroy();
		}
	}
}

// Base Projectile Class
class EEProjectile : EEBaseZSC abstract
{
	float user_ignoreaoeimmunity;
	int saveddmg; // Save damage from things like A_CustomPunch for puffs
	int user_canafflict;
	int user_ailmentmaxchance;
	mixin InvWeaponShare;
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;
	int user_noseektimer;
	
	double bonusmultiplier;
	
	int xyspreadtime;
	int zspreadtime;
	int ipprojid;
	double basespreadspeed;

	bool hitawall;
	bool hitaceiling;
	bool hitafloor;
	
	bool IPattack;

	int timesrippedoverall;
	int maxtimesrippedoverall;
	
	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int stamdamagefactor;
	int accudamagefactor;
	
	int PlayerLevel;
	PlayerPawn playpawn;
	
	private class<Inventory> iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4, iDTech1Check5, iDTech1Check6, iDTech1Check7, iDTech1Check8;

	default
	{
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (bonusmultiplier <= 0.0) bonusmultiplier = 1.0;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem) PlayerLevel = MiscItem.TruePlayerLevel;
		}
	}

	override void Tick()
	{
		if (target)
		{
			if (PlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
						if (dydudebug_timefreezedebugaffectproj) bNOTIMEFREEZE = false;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_projectilecollisions && (other.bSHOOTABLE && other != target)) Console.Printf("\c[brick]Collision:\c- %s (%p @ %.2f, %.2f, %.2f) vs %s (%p @ %.2f, %.2f, %.2f) [%d, f: %d]", GetClassName(), self, pos.x, pos.y, pos.z, other.GetClassName(), other, other.pos.x, other.pos.y, other.pos.z, GetAge(), frame);

			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers()) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1()) return false;
				}
			}
			else 
			{
			}
		}
		
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEProjectile, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
	
	void A_HitSparkGetSize()
	{
		A_SetScale(0.3125); A_FadeTo(0.6875);
		/*
		user_sparksizelevel = MartialArtsMastery + BerserkerFit;
		if (user_sparksizelevel <= 0) { A_SetScale(0.3125); A_FadeTo(0.6875); }
		if (user_sparksizelevel == 1) { A_SetScale(0.375); A_FadeTo(0.75); }
		if (user_sparksizelevel == 2) { A_SetScale(0.4375); A_FadeTo(0.8125); }
		if (user_sparksizelevel == 3) { A_SetScale(0.5); A_FadeTo(0.875); }
		if (user_sparksizelevel == 4) { A_SetScale(0.5625); A_FadeTo(0.9375); }
		if (user_sparksizelevel >= 5) { A_SetScale(0.625); A_FadeTo(1.0); }
		*/
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		//user_sparkscalemulti = (StamUpPerkLevel * 0.05) + (StamUpEXPerkLevel * 0.125);
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;
		if (target)
		{
			if (target.GetClassName() == "UppercutPuff") base *= frandom(1.5,1.75);
			if (target.GetClassName() == "KickPuff" || GetClassName() == "KickPuffNoThrust") base *= frandom(2.0,2.25);
			if (target.target && target.target.CountInv("PowerStrength") || target.target.CountInv("PowerStrengthDD")) base *= frandom(1.5,2.25);
		}

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		if (dydudebug_miscdisplays1) Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	void A_CheckHitCeiling()
	{
		if (pos.Z + height >= ceilingz) hitaceiling = true;
		//Console.Printf("pos.z: %d, height: %d, ceilingz: %d, hitceiling: %d", pos.z, height, ceilingz, hitaceiling);
	}
	
	int A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		int result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			let MiscItem = PlayerStatItem(playpawn.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				BaseSigilMaxHealth = MiscItem.BaseStartMaxHealth;
				MaxHealthTrue =  MiscItem.MaxHealthTrue;
			}
			else return 32;
		}
		else
		{
			return 32;
		}
		
		if (attacktype == 0) // SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 32;
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 300 + random(-150,150); // 150 to 450
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 150 + random(-75,75); // 75 to 225
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 175 + random(-87,87); // 88 to 242
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 6) // SpectralLightningH2New
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 50 + random(-25,25); // 25 to 75
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 25 + random(-12,12); // 13 to 37
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
		{
			if (radiustype == 0) // Damage Calculation
			{
				result = 325 + random(-162,162); // 163 to 387
			}
			else // Radius Calculation
			{
				result = 32; 
			}
		}
		
		if (dydudebug_sigilatkinfo)
		{
			if (radiustype == 0) Console.Printf("Damage Result: %d", result);
			if (radiustype == 1) Console.Printf("Radius Result: %d", result);
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		double minerror = 0.67;
		double maxerror = 1.34;

		if (radiustype == 0) // Direct Damage is randomized a bit
		{
			minerror = 0.8334;
			maxerror = 1.1667;
			if (playpawn) // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [damage] (%s), %d", AttackerName, attacktype);
				
				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.125); // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.275); // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.45); // +45% damage
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.65); // +65% damage
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.875); // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 2.125); // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 2.4); // +140% damage
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 2.7); // +170% damage
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 3.025); // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 3.375); // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.0625); // +6.25% damage
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.1375); // +13.75% damage
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.225); // +22.5% damage
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.325); // +32.5% damage
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.4375); // +43.75% damage
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.5625); // +56.25% damage
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.70); // +70% damage
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.85); // +85% damage
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 2.0125); // +101.25% damage
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 2.1875); // +118.75% damage
				
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 20);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = result;
				finaldmg = result;
				if (attacktype != 0) finaldmg = floor(finaldmg * random(1,4)); // +STRIFEDAMAGE calculation
				nm = "EntityBoss"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecond"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 1.5);
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = floor(finaldmg * 2.25);

				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}
		else // Radius is not randomized nearly as much
		{
			minerror = 0.9625;
			maxerror = 1.0375;
			if (playpawn)
			{
				if (dydudebug_sigilatkinfo) Console.Printf("Player Sigil Shot [radius] (%s), %d", AttackerName, attacktype);
				
				if (attacktype != 0)
				{
					if (attacktype == 1) // SpectralLightningBall1New [shots from the Player's Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 2) // SpectralLightningBall2New [shots from monsters' Sigil 3 fire mode]
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 3) // SpectralLightningV1New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 4) // SpectralLightningV2New [from the player's Sigil 1 node]
					{
						result *= 1.25;
						extradmg1 *= 1.25;
						extradmg2 *= 1.25;
						extradmg3 *= 1.25;
						extradmg4 *= 1.25;
						extradmg5 *= 1.25;
						extradmg6 *= 1.25;
					}
					if (attacktype == 5) // SpectralLightningH1New [from the Player's Sigil 2 mode]
					{
						result *= 1.5;
						extradmg1 *= 1.5;
						extradmg2 *= 1.5;
						extradmg3 *= 1.5;
						extradmg4 *= 1.5;
						extradmg5 *= 1.5;
						extradmg6 *= 1.5;
					}
					if (attacktype == 6) // SpectralLightningH2New
					{
						result *= 1.125;
						extradmg1 *= 1.125;
						extradmg2 *= 1.125;
						extradmg3 *= 1.125;
						extradmg4 *= 1.125;
						extradmg5 *= 1.125;
						extradmg6 *= 1.125;
					}
					if (attacktype == 7) // SpectralLightningH3New [from the side/ahead shots of the player's Sigil 5 main shot]
					{
						result *= 0.75;
						extradmg1 *= 0.75;
						extradmg2 *= 0.75;
						extradmg3 *= 0.75;
						extradmg4 *= 0.75;
						extradmg5 *= 0.75;
						extradmg6 *= 0.75;
					}
					if (attacktype == 8) // SpectralLightningBigBall1New [the main shot of the Player's Sigil 5 mode]
					{
						result *= 2.5;
						extradmg1 *= 2.5;
						extradmg2 *= 2.5;
						extradmg3 *= 2.5;
						extradmg4 *= 2.5;
						extradmg5 *= 2.5;
						extradmg6 *= 2.5;
					}
				}

				rand1 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * minerror);
				rand2 = floor((extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * maxerror);
				finaldmg = result + random(rand1,rand2);

				
				if (stamdamagefactor == 1) finaldmg = floor(finaldmg * 1.03125);
				if (stamdamagefactor == 2) finaldmg = floor(finaldmg * 1.06875);
				if (stamdamagefactor == 3) finaldmg = floor(finaldmg * 1.1125);
				if (stamdamagefactor == 4) finaldmg = floor(finaldmg * 1.1625);
				if (stamdamagefactor == 5) finaldmg = floor(finaldmg * 1.21875); 
				if (stamdamagefactor == 6) finaldmg = floor(finaldmg * 1.28125); 
				if (stamdamagefactor == 7) finaldmg = floor(finaldmg * 1.35);
				if (stamdamagefactor == 8) finaldmg = floor(finaldmg * 1.425);
				if (stamdamagefactor == 9) finaldmg = floor(finaldmg * 1.50625); 
				if (stamdamagefactor == 10) finaldmg = floor(finaldmg * 1.59375);
			
				if (accudamagefactor == 1) finaldmg = floor(finaldmg * 1.015625);
				if (accudamagefactor == 2) finaldmg = floor(finaldmg * 1.034375);
				if (accudamagefactor == 3) finaldmg = floor(finaldmg * 1.05625);
				if (accudamagefactor == 4) finaldmg = floor(finaldmg * 1.08125);
				if (accudamagefactor == 5) finaldmg = floor(finaldmg * 1.109375);
				if (accudamagefactor == 6) finaldmg = floor(finaldmg * 1.140625);
				if (accudamagefactor == 7) finaldmg = floor(finaldmg * 1.175);
				if (accudamagefactor == 8) finaldmg = floor(finaldmg * 1.2125);
				if (accudamagefactor == 9) finaldmg = floor(finaldmg * 1.253125);
				if (accudamagefactor == 10) finaldmg = floor(finaldmg * 1.296875);

				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 20;
				int hpextradmg3 = ((hpextradmg + hpextradmg2) - 5);
				finaldmg = (finaldmg * hpextradmg3) / 100;

				if (dydudebug_sigilatkinfo) Console.Printf("\cy(%s) (attacktype: %d)\c- (radiustype: %d): BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), attacktype, radiustype, result, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (dydudebug_sigilatkinfo) Console.Printf("[non-player] \cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), result, prefinaldmg, finaldmg);
			}
		}

		if (radiustype == 0) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Damage Total: %d\c-", finaldmg);
			finaldamagedealt = finaldmg;
			return finaldmg;
		}
		if (radiustype == 1) 
		{
			if (dydudebug_sigilatkinfo) Console.Printf("\cxSigil Radius Total: %d\c-", finaldmg);
			finaldamagedealt2 = finaldmg;
			return finaldmg;
		}
		return 32;
	}
	
	// Handle Fractal Egg Split Offs
	void A_EggGrenades(string eggname = "EggGrenade", double zheight = 2, double zheightadd = 35, double xyvelmin = 6, double xyvelmax = 6, double zvelmin = 6, double zvelmax = 12)
	{
		bool success;
		actor EggShots;
		actor player = players[0].mo;
		if (hitaceiling) { [success, EggShots] = A_ThrowGrenadeAngle(eggname,-zheight,-zheightadd,random(xyvelmin,xyvelmax),random(-zvelmax,-zvelmin),checkspawn:false); }
								else { [success, EggShots] = A_ThrowGrenadeAngle(eggname,zheight,zheightadd,random(xyvelmin,xyvelmax),random(zvelmin,zvelmax),checkspawn:false); }
		if (dydudebug_eggfractals) Console.Printf("\c[blue]success [%s]:\c- %d", GetClassName(), success);
		if (EggShots) // && success) 
		{
			EggShots.target = player; // EggShots.target = self.target;
			if (IPAttack)
			{
				EEProjectile IPCompat; 
				IPCompat = EEProjectile(EggShots);
				if (IPCompat)
				{
					IPCompat.target = player;
					IPCompat.IPattack = true;
				}
			}
			if (EggShots.target && dydudebug_eggfractals) Console.Printf("EggShots.\c[fire]target [\c[sapphire]%s\c-]:\c- %s", GetClassName(), EggShots.target.GetClassName());
		}
	}
	
	// Sigil
	void A_SpectralLightning()
	{
		EEProjectile flash2;

		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = "SpectralLightningV2New";
		else cls = "SpectralLightningV1New";

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}

		flash = Spawn("SpectralLightningV2New", (pos.xy, ONCEILINGZ), ALLOW_REPLACE);
		if (flash != null)
		{
			flash2 = EEProjectile(flash);
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
			if (flash2) flash2.IPAttack = true;
		}
	}
	
	void A_SpectralLightningTail()
	{
		Actor foo = Spawn("SpectralLightningHTailNew", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			if (target) foo.Target = Target;
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}
	
	void A_SpectralBigBallLightning(string spawntype = "SpectralLightningH3")
	{
		Actor foo;
		EEProjectile foo2;
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle += 180.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
			angle -= 270.;
			foo = SpawnSubMissile(cls, target);
			if (foo != null)
			{
				foo2 = EEProjectile(foo);
				if (target) foo.Target = Target;
				foo.FriendPlayer = FriendPlayer;
				if (foo2) foo2.IPAttack = true;
			}
		}
	}
	
	// Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + MiscItem.TruePlayerLevel;
		double radius;
		double radiuserror;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			radius = 12;
			radius += (PlayerSTR * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			radius = 12;
			radius += (PlayerSTR * 0.0833333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			radius = 20;
			radius += (PlayerSTR * 0.1333333333333333);
			radiuserror = frandom(0.9334,1.0666);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16;
			radius += (PlayerSTR * 0.125);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24;
			radius += (PlayerSTR * 0.166667);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24;
			radius += (PlayerSTR * 0.25);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36;
			radius += (PlayerSTR * 0.3334);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		radius = radius * (random(16,17) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);

		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (player.CountInv("PlayingDoom64"))
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}
		
		return radius;
	}
	

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + MiscItem.TruePlayerLevel;
		int intensity;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0227272727272727);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0227272727272727);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			intensity = randompick(0,0,0,0,1);
			intensity += (PlayerSTR * 0.033334);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.03125);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0416666666666667);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0;
			intensity += (PlayerSTR * 0.0833333333333333);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		intensity = intensity * random(8,9) / 8;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) 
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + MiscItem.TruePlayerLevel;
		int duration;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerSTR * 0.0178571428571429);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			duration = randompick(1,1,1,2);
			duration += (PlayerSTR * 0.0178571428571429);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			duration = random(4,5);
			duration += (PlayerSTR * 0.0625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration += (PlayerSTR * 0.025);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration += (PlayerSTR * 0.0357142857142857);
		}
		else
		if (attacktype == 5) // ?
		{
			duration = 6;
			duration += (PlayerSTR * 0.0714285714285714);
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration += (PlayerSTR * 0.05);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration += (PlayerSTR * 0.0714285714285714);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;

		duration = duration * random(8,9) / 8;
		int charduration = duration;
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, bersduration, duration);
		}
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		if (MiscItem) PlayerSTR = MiscItem.TruePlayerATK + MiscItem.TruePlayerLevel;
		int tremrad;
		int debugmelee = dydudebug_meleeinformation;

		if (attacktype == 0) // Cricket Bat Swing
		{
			tremrad = 224;
			tremrad += (PlayerSTR * 0.875);
		}
		else
		if (attacktype == 1) // Applejack Swing
		{
			tremrad = 224;
			tremrad += (PlayerSTR * 0.875);
		}
		else
		if (attacktype == 2) // Scrambler Bash
		{
			tremrad = 288;
			tremrad += (PlayerSTR * 1.125);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad += (PlayerSTR);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad += (PlayerSTR * 1.25);
		}
		else
		if (attacktype == 5) // ?
		{
		}
		else
		if (attacktype == 6) // ?
		{
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad += (PlayerSTR * 1.75);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad += (PlayerSTR * 3.5);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		tremrad = tremrad * random(8,9) / 8;
		int chartremrad = tremrad;
		
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [DivineAvatar]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, berstremrad, tremrad);
		}
		return tremrad;
	}
	
	void A_HadesSphereExplode(int basedmg = 112, int baserad = 112)
	{
		int newdmg = basedmg;
		int newrad = baserad;
		if (target)
		{
			int maxhp;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp = (target.SpawnHealth() + target.Stamina);
			else maxhp = target.SpawnHealth();
			maxhp *= (1.0 + (target.CountInv("MonsterLevel") * 0.0111111112)); // +100% damage every ~90 levels
			maxhp *= 0.25; // +100% damage every ~180 levels
			newdmg += maxhp;
			EECreature HSFound;
			HSFound = EECreature(target);
			int healthleft;
			if (HSFound) healthleft = HSFound.hsexphealth;
			healthleft *= (1.0 + (target.CountInv("MonsterLevel") * 0.0222222223)); // +100% damage every ~45 levels
			healthleft *= 0.5;
			newdmg += healthleft;

			int maxhp2;
			if ((target.SpawnHealth() + target.Stamina) > 0) maxhp2 = (target.SpawnHealth() + target.Stamina);
			else maxhp2 = target.SpawnHealth();
			maxhp2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.005555556)); // +100% radius every ~180 levels
			maxhp2 *= 0.125;
			newrad += maxhp2;
			HSFound = EECreature(target);
			int healthleft2;
			if (HSFound) healthleft2 = HSFound.hsexphealth;
			healthleft2 *= (1.0 + (target.CountInv("MonsterLevel") * 0.011111112)); // +100% radius every ~90 levels
			healthleft2 *= 0.25;
			newrad += healthleft2;
			
			//if (dvdsdebug_showmiscdmginformation) Console.Printf("NewDmg: %d (%d), NewRad: %d (%d), MaxHP: %d, HealthLeft: %d, MaxHP2: %d, HealthLeft2: %d", newdmg, basedmg, newrad, baserad, maxhp, healthleft, maxhp2, healthleft2);
		}
		A_Explode(newdmg,newrad,0,(newrad*0.334));
	}
	

	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}

	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the “retarget” parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If ≤ 0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}

	void A_EESeekerBounce(int timerset = 6, int randomset = 0, bool clearpointers = false)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			if (clearpointers) A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}
	
	void A_EESeekerMissile(int threshold, int turnmax, int flags = 0, int chance = 50, int distance = 10)
	{
		if (user_noseektimer > 0) user_noseektimer--;
		if (user_noseektimer <= 0) A_SeekerMissile(threshold,turnmax,flags,chance,distance);
	}
}

class EEFireworksProj : EEProjectile
{
	int user_explosion;
	int expflags;
	int TruePlayerLevel;
	
	void A_GetPlayerLevel()
	{
		TruePlayerLevel = 0;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		if (exex_expenabled && MiscItem) TruePlayerLevel = MiscItem.PlayerLevel;
	}
	
	double A_CalcTrueExpDmg(double basedmg, double basemul = 0.02, double tier1 = 0.5, double tier2 = 0.5, double tier3 = 0.5, double tier4 = 0.5)
	{
		if (TruePlayerLevel) basedmg *= (1.0 + (TruePlayerLevel * basemul));
		if (TruePlayerLevel > 25) basedmg *= (1.0 + ((TruePlayerLevel - 25) * (basemul * tier1)));
		if (TruePlayerLevel > 50) basedmg *= (1.0 + ((TruePlayerLevel - 50) * (basemul * tier2)));
		if (TruePlayerLevel > 75) basedmg *= (1.0 + ((TruePlayerLevel - 75) * (basemul * tier3)));
		if (TruePlayerLevel > 100) basedmg *= (1.0 + ((TruePlayerLevel - 100) * (basemul * tier4)));
		if (dydudebug_rangedmg) Console.Printf("ExpDamage [%s]: %d", GetClassName(), basedmg);
		return basedmg;
	}
}

class EEEffectProjectile : EEProjectile
{
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));

		user_ailmentmaxchance = basechance;
		if (master && master == player)
		{
			if (player.CountInv("EWShieldIdleMode") > 0) 
			{
				if (player.CountInv("EWShieldDefendMode") > 0)
				{
					if (player.CountInv("EWShieldDefendModeExtra") > 0) user_ailmentmaxchance * 20;
																												 else user_ailmentmaxchance * 12;
				}
				else
				{
					user_ailmentmaxchance * 4;
				}
			}
		}

		user_canafflict = 1;
		if (master)
		{
			if (master.health <= 0) user_canafflict = 0;

			if (master.CountInv("EvadeAnAttack") > 0 || 
					master.CountInv("PlayerDashing") > 0) 
					{
						user_canafflict = 0;
					}
		}

		DDPlayerPawn playpawn;
		if (master)
		{
			playpawn = DDPlayerPawn(master);
			if (playpawn)
			{
				if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE || playpawn.bINVULNERABLE) user_canafflict = 0;
			}
			else
			{
				if (master.bINVULNERABLE) user_canafflict = 0;
			}
		}
	}
}

// Base FastProjectile Class
class EEFastProjectile : EEProjectile abstract
{
	Default
	{
		Projectile;
		MissileHeight 0;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		
		ClearInterpolation();
		double oldz = pos.Z;

		if (isFrozen())
			return;

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		bool ismoved = Vel != (0, 0, 0)
			// Check Z position set during previous tick.
			// It should be strictly equal to the argument of SetZ() function.
			|| (   (pos.Z != floorz           ) /* Did it hit the floor?   */
				&& (pos.Z != ceilingz - Height) /* Did it hit the ceiling? */ );

		if (ismoved)
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				VelFromAngle(MinVel);
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, false, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
                    Destructible.ProjectileHitPlane(self, SECPART_Floor);
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
                    Destructible.ProjectileHitPlane(self, SECPART_Ceiling);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

class CFlameMissileNew : EEFastProjectile
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : EEProjectile
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 128, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : EEProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : EEFastProjectile abstract
{
	default
	{
		Projectile;
		+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		DDPlayerPawn playpawn;
		DDPlayerPawn playpawn2;
		Actor DDActor;
		Actor DDActor2;
		playpawn = DDPlayerPawn(target);
		playpawn2 = DDPlayerPawn(other);
		DDActor = Actor(target);
		DDActor2 = Actor(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer(self)) return false;
					if (A_CheckFriendCollisionProjTypePlayer2(self)) return false;
				}
			}
			else
			if (DDActor && DDActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

// Base Puff Class
class EEPuff : EEProjectile abstract
{
	default
	{
		+PUFFGETSOWNER
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	
	override void Tick()
	{
		if (target)
		{
			if (DDPlayerPawn(target))
			{
				if (target.CountInv("PowerTimeFreezer") ||
						target.CountInv("DDMiscTimeFreezer") ||
						target.CountInv("DebugTimeFreezer") ||
						target.CountInv("TimePotionTimeFreezer") ||
						target.CountInv("DashTimeFreezer") ||
						!target.player.timefreezer)
				{
					if (target.CountInv("DebugTimeFreezer"))
					{
						if (!dydudebug_timefreezedebugaffectproj && !bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
					else
					{
						if (!bNOTIMEFREEZE) bNOTIMEFREEZE = true;
					}
				}
				else
				{
					if (bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
			else
			{
				if (!bNOTIMEFREEZE)
				{
					if (target && target.bNOTIMEFREEZE) bNOTIMEFREEZE = true;
				}
				else
				{
					if (target && !target.bNOTIMEFREEZE) bNOTIMEFREEZE = false;
				}
			}
		}
		Super.Tick();
	}
	
	override int DoSpecialDamage(Actor target, int damage, Name damagetype)
	{
		//Console.Printf("DoSpecialDamage: EEPuff, target: %s, damage: %d, damagetype: %s", target.GetClassName(), damage, damagetype);
		damage = super.DoSpecialDamage(target, damage, damagetype);
		// New Code goes here
		return damage;
	}
}

class EEFireworksPuff : EEPuff
{
	int user_explosion;
	int expflags;
	int TruePlayerLevel;
	
	void A_GetPlayerLevel()
	{
		TruePlayerLevel = 0;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		if (exex_expenabled && MiscItem) TruePlayerLevel = MiscItem.PlayerLevel;
	}
	
	double A_CalcTrueExpDmg(double basedmg, double basemul = 0.02, double tier1 = 0.5, double tier2 = 0.5, double tier3 = 0.5, double tier4 = 0.5)
	{
		if (TruePlayerLevel) basedmg *= (1.0 + (TruePlayerLevel * basemul));
		if (TruePlayerLevel > 25) basedmg *= (1.0 + ((TruePlayerLevel - 25) * (basemul * tier1)));
		if (TruePlayerLevel > 50) basedmg *= (1.0 + ((TruePlayerLevel - 50) * (basemul * tier2)));
		if (TruePlayerLevel > 75) basedmg *= (1.0 + ((TruePlayerLevel - 75) * (basemul * tier3)));
		if (TruePlayerLevel > 100) basedmg *= (1.0 + ((TruePlayerLevel - 100) * (basemul * tier4)));
		if (dydudebug_rangedmg) Console.Printf("ExpDamage [%s]: %d", GetClassName(), basedmg);
		return basedmg;
	}
}

class RocketBase : EEProjectile
{
	default
	{
		Tag "Rocket";
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		Projectile;
		+RANDOMIZE;
		+DEHEXPLOSION;
		+ROCKETTRAIL;
		SeeSound "weapons/rocklf";
		DeathSound "weapons/rocklx";
		Obituary "$OB_MPROCKET"; // "%o rode %k's rocket.";
	}
	States
	{
		Spawn:
			MISL A 1 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/rocklx",CHAN_7);
				A_Quake(1, 4, 0, 512, "nosound/silent");
				A_Quake(4, 4, 0, 256, "nosound/silent");
			}
			MISL B 8 Bright A_Explode();
			MISL C 6 Bright;
			MISL D 4 Bright;
			Stop;
	}
}

class BFGBallBase : EEProjectile
{
	double user_radiusdmg; 
	double user_radiussize; 
	int user_detonationtimer;
	
	default
	{
		Radius 13;
		Height 8;
		Speed 25;
		DamageFunction 100;
		Projectile;
		+RANDOMIZE;
		RenderStyle "Add";
		Alpha 0.75;
		DeathSound "weapons/bfgx";
		Obituary "$OB_MPBFG_BOOM";
	}
	
	States
	{
		Spawn:
			BFS1 AB 4 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/bfgx",CHAN_7);
				A_Quake(1, 12, 0, 768, "");
				A_Quake(5, 12, 0, 512, "");
			}
			BFE1 AB 8 Bright;
			BFE1 C 8 Bright A_BFGSpray();
			BFE1 DEF 8 Bright;
			Stop;
		
		ShotDown:
			TNT1 A 0 
			{
				A_ScaleVelocity(0);
				A_StartSound("weapons/bfgx",CHAN_7, CHANF_DEFAULT, 0.5);
				A_Quake(1, 12, 0, 384, "");
				A_Quake(5, 12, 0, 256, "");
			}
			BFE1 ABCDEF 4 Bright;
			Stop;
	}
}

class EEVisualAImage : EEBaseZSC abstract
{
	default
	{
		Radius 16;
		Height 8;
		Scale 0.8;
		Alpha 0.85;
		RenderStyle "Add";
		+NOGRAVITY
		+THRUACTORS
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}
	States
	{
		Spawn:
			TNT1 AA 1 Bright;
			Stop;
	}
}

class EEProp : EEBaseZSC abstract
{
}

class EECreature : EEBaseZSC abstract
{
	int user_deathcounter, user_truekill;
	int user_charmed;
	int user_pelletsfired;
	int user_HPXDeathRange2;
	int user_ressurrectstr, user_resurrectedtimes, user_autorestimer;
	int user_barragecounter, user_shotsfired, user_shotsfiredmax;
	float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
	float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
	float user_randominaccuracy, user_randominaccuracy2;
	int specialspeed1;
	mixin MonsterCollider;
	int bossdeathactivate;
	bool IPAttackSummon;
	double gravitypulsetimer;
	int user_gravitytype;
	
	bool waspartinvis;
	double initalpha;
	int initrenderstyle;
	int user_fastchasetimer, user_fastchasetimermax;
	int user_walksound;
	int user_painreacttimer;
	int user_attacktype;
	int user_attacks;
	int user_attackmax;
	float user_tempvar1, user_tempvar2, user_tempvar3;
	int user_hyperlvl1, user_hyperlvl2;
	int user_fastchasechance, user_fastchaseextra, user_painfastchase;
	int AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	name MonsterFamily;
	
	property AggressionLevelThreshold: AggressionLevelThreshold1, AggressionLevelThreshold2, AggressionLevelThreshold3;
	property ActorFamily: MonsterFamily;

	default
	{
		EECreature.AggressionLevelThreshold 75, 150, 225;
	}
	/*
	override void Tick()
	{
		super.Tick();
	}
	*/
	
	void A_DDAFDOrigBossDie()
	{
		actor player = players[0].mo;
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite"))
		{
			ACS_Execute(911,0,0,0,0);
		}
	}
	
	void A_DynamicMusic()
	{
		actor player = players[0].mo;
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite"))
		{
			ACS_Execute(102,0,0,0,0); // Uses the ACS-Based system within the original DD/AFD maps for the dynamic music, as originally coded
		}
		else
		{
			// To be coded eventually V: :V
		}
	}
	
	void A_DiabHealProj(double anglevec = 0.0, double anglevec2 = 0.0)
	{
		if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 60)
		{
			A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 72+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 144+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 216+anglevec, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 288+anglevec, 0);
		}
		else
		if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") > 20)
		{
			A_SpawnProjectile("ReviveProj2", 0, 0, 0+anglevec2, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 120+anglevec2, 0);
			A_SpawnProjectile("ReviveProj2", 0, 0, 240+anglevec2, 0);
		}
	}
	
	// Diabloist Gravity Attack
	void A_DiabloistGravityCheck()
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer = 0;
		Actor targ = target;
		if (targ)
		{
			if (random(1,8) <= 3) user_gravitytype = 3;
											 else user_gravitytype = random(1,2);

			Actor playertarg = DDPlayerPawn(target);
			/*if (!playertarg && user_gravitytype != 0)*/ user_gravitytype = 1;
			//Console.Printf("user_gravitytype: %d", user_gravitytype);

			targ.A_StartSound("diabloistgravitystart", CHAN_7);
			bNOTARGETSWITCH = true;
			if (random(1,256) <= (21.3335 + (user_monsterlevel/1.5))) bNOPAIN = true;
			bQUICKTORETALIATE = false;
		}
	}
	
	void A_DiabloistSpawnGravityNodes()
	{
		int user_monsterlevel = CountInv("MonsterLevel");

		gravitypulsetimer = 0;
		if (user_gravitytype == 1 || user_gravitytype == 3) 
		{
			//A_Log("HP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 120) { A_VileTarget("DiabloistGravityHPTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityHPTargeter2"); }
			else { A_VileTarget("DiabloistGravityHPTargeter"); }
		}
		if (user_gravitytype == 2 || user_gravitytype == 3)
		{
			//A_Log("MP Targetter");
			if (exex_monsterlevelenabledflags && user_monsterlevel > 120) { A_VileTarget("DiabloistGravityManaTargeter3"); }
			else if (exex_monsterlevelenabledflags && user_monsterlevel > 40) { A_VileTarget("DiabloistGravityManaTargeter2"); }
			else { A_VileTarget("DiabloistGravityManaTargeter"); }
		}
		bNOTARGETSWITCH = true;
		bQUICKTORETALIATE = false;
	}
	
	void A_DiabloistGravityPulse(double speed)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		gravitypulsetimer += speed;
		
		if ((level.time % 3) == 0)
		{
			if (bNOPAIN)
			{
				if (random (1,256) <= (8+(user_monsterlevel/(33.4*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null,CHF_FASTCHASE);
				}
			}
			else
			{
				if (random (1,256) <= (32+(user_monsterlevel/(25*0.334))))
				{
					if (random (1,256) <= (64+(user_monsterlevel/(12.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (53.3335+(user_monsterlevel/(15*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (42.66675+(user_monsterlevel/(18.75*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (32+(user_monsterlevel/(25*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (21.3335+(user_monsterlevel/(37.5*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
					if (random (1,256) <= (10.66675+(user_monsterlevel/(50*0.334)))) A_Chase(null,null, CHF_FASTCHASE);
				}
			}
		}
		
		if (gravitypulsetimer > 22.5)
		{
			gravitypulsetimer -= 22.5;
			A_StartSound("diabloistgravitypulse", CHAN_7);
		}
	}
	
	void A_DiabloistGravity(int gravitytype)
	{
		actor player = players[0].mo;
		gravitypulsetimer = 0;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue, LevelFactor;
		int basedmgratio;
		int AffectedStat, MultFactor, THEEffect;
		int InvulnerabilityTimer;
		let InvulnItem = PowerInvulnDD(player.FindInventory("PowerInvulnDD"));
		if (!InvulnItem)
		{
			let InvulnItem = PowerInvulnerable(player.FindInventory("PowerInvulnerable"));
		}
		if (InvulnItem) InvulnerabilityTimer = InvulnItem.EffectTics;
		int PrevHealth, PrevMana, PrevInvulnTimer;
		int healthdiff;
		int ptemp1, ptemp2;

		Actor targ = target;
		if (targ && targ.health > 0)
		{
			DDPlayerPawn playertarg;
			playertarg = DDPlayerPawn(target);
			EECreature actortarg;
			actortarg = EECreature(target);
			DDPlayerPawn playerculprit;
			playerculprit = DDPlayerPawn(self);
			EECreature actorculprit;
			actorculprit = EECreature(self);

			/*gravitytype -= 1;
			if (!playertarg && gravitytype != 0)*/ gravitytype = 0;

			A_FaceTarget();
			if (!CheckSight(targ, 0)) return;
			if (playertarg && playertarg.CountInv("PlayerDashing")) return;
			targ.A_StartSound("diabloistgravityend", CHAN_7);

			if (playertarg)
			{
				if (InvulnItem && InvulnerabilityTimer > 0)
				{
					//Console.Printf("gravitytype: %d [Invulnerable]", gravitytype);

					if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.03125;
					if (skill == SKILL_EASY) GravityEffectFactor = 0.0625;
					if (skill == SKILL_NORMAL) GravityEffectFactor = 0.1250;
					if (skill == SKILL_HARD) GravityEffectFactor = 0.1875;
					if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.21875;
					if (gravitytype == 2) GravityEffectFactor *= 2;
					if (random(1,16) == 16) GravityEffectFactor *= 2;

					FinalGravityFactor = 1.000 - GravityEffectFactor;
					GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
					if (GravityEffectFactor > 0.000)
					{
						double PrevInvulnTime = InvulnerabilityTimer;
						PropertyValue = InvulnerabilityTimer;
						PropertyValue = PropertyValue * FinalGravityFactor;
						
						if (PropertyValue < 1) PropertyValue = 1;
						InvulnItem.EffectTics = PropertyValue;
						if (playertarg) playertarg.A_SetBlend("C0 C0 C0",1.25,random(39,40));
						PrevInvulnTime -= PropertyValue;
						PrevInvulnTime /= 35;
						if (playertarg) playertarg.A_Print(String.Format("%1f second[s] of your invulnerablity were sapped!", PrevInvulnTime));
					}
				}
				else
				{
					//Console.Printf("gravitytype: %d", gravitytype);

					if (gravitytype == 0) // HP only
					{
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							/*
							ptemp1 = (630*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("HPPenaltyTimeAdd: %d", ptemp1);
							// HPRegenBonPenTimer
							*/

							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
							if (playertarg) playertarg.A_SetBlend("C0 00 00",1.25,random(39,40));
						}
					}
					/*
					else
					if (gravitytype == 1) // Mana only
					{
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PropertyValue = CallACS("StatCheck",14);
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (630*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("MPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",93,ptemp1,2); // MPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							CallACS("OtherVarSetDECORATE",2,PropertyValue);
							if (playertarg) playertarg.A_SetBlend("00 00 C0",1.25,random(39,40));
						}
					}
					else
					if (gravitytype == 2) // HP & Mana
					{
						// HP Damage
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PrevHealth = targ.health;
							PropertyValue = PrevHealth;
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (420*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("HPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",92,ptemp1,2); // HPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							targ.health = PropertyValue;
							healthdiff = (PrevHealth - PropertyValue);
						}
						
						// MP Damage
						if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
						if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
						if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
						if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
						if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;
						if (random(1,16) != 16) GravityEffectFactor /= 2;
						FinalGravityFactor = 1.000 - GravityEffectFactor;
						GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
						if (GravityEffectFactor > 0.000)
						{
							PropertyValue = CallACS("StatCheck",14);
							PropertyValue = PropertyValue * FinalGravityFactor;
							
							ptemp1 = (420*FinalGravityFactor);
							if (dvdsdebug_regenpenaltydisplay) Console.Printf("MPPenaltyTimeAdd: %d", ptemp1);
							CallACS("MiscVarSetDECORATE",93,ptemp1,2); // MPRegenBonPenTimer
							
							if (PropertyValue < 1) PropertyValue = 1;
							CallACS("OtherVarSetDECORATE",2,PropertyValue);
						}
						if (playertarg) playertarg.A_SetBlend("C0 00 C0",1.25,random(39,40));
					}
					// Inflict Possible Blindness
					if (playertarg && random(1,32) <= 1) ACS_NamedExecuteAlways("BuffTimer",0,8,19,random(17,51));
					*/
				}
			}
			else
			{
				if (skill <= SKILL_VERY_EASY) GravityEffectFactor = 0.0625;
				if (skill == SKILL_EASY) GravityEffectFactor = 0.1250;
				if (skill == SKILL_NORMAL) GravityEffectFactor = 0.2500;
				if (skill == SKILL_HARD) GravityEffectFactor = 0.3750;
				if (skill >= SKILL_VERY_HARD) GravityEffectFactor = 0.4375;

				LevelFactor = 128;
				if (exex_monsterlevelenabledflags) LevelFactor = 128 - CountInv("MonsterLevel");
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 128;

				FinalGravityFactor = 1.000 - GravityEffectFactor;
				GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
				if (GravityEffectFactor > 0.000)
				{
					PrevHealth = targ.health;
					PropertyValue = PrevHealth;
					PropertyValue *= FinalGravityFactor;
				
					if (PropertyValue < 1) PropertyValue = 1;
					targ.health = PropertyValue;
					healthdiff = (PrevHealth - PropertyValue);
				}
			}
			
			// Print Outs
			if (healthdiff)
			{
				string culprit = GetClassName();
				string victim;
				
				string friendmsg = " \cn(F)\c-";
				string charmmsg = " \cx(C)\c-";
				
				if ((playertarg && (exex_playerdmglog & 1)) || (actortarg && (exex_combatlog & 2)))
				{
					if (playertarg) victim = playertarg.GetClassName();
					if (actortarg) victim = actortarg.GetClassName();

						culprit = GetTag("");
						if (playertarg) victim = playertarg.GetTag("");
						if (actortarg) victim = actortarg.GetTag("");

					string DamageMessage = " \c[white]* ";
					DamageMessage.AppendFormat("\cy%d\c- ", healthdiff);
					DamageMessage.AppendFormat("\c[purple]Gravity\c- ");
					DamageMessage.AppendFormat("\c[red]Damage\c-");
					DamageMessage.AppendFormat(" dealt to \cx%s\c-", victim);
					if (actortarg)
					{
						if (actortarg.health > 0) DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
																 else DamageMessage.AppendFormat(" \cx[L%d]\c-", actortarg.CountInv("MonsterLevel"));
					}
					if (actortarg && actortarg.bFRIENDLY) 
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" by \cw%s's\c-", culprit);
					if (actorculprit && actorculprit.CountInv("MonsterLevel") >= 0) DamageMessage.AppendFormat(" \cw[L%d]\c-", actorculprit.CountInv("MonsterLevel"));
					if (actorculprit && actorculprit.bFRIENDLY)
					{
						DamageMessage.AppendFormat(friendmsg);
					}
					DamageMessage.AppendFormat(" \czGraviton Glare\c-!");
					if (dydudebug_showgametic) DamageMessage.AppendFormat(" (%d)", gametic);
					
					Console.Printf("%s", DamageMessage);
				}
			}
		}
		bQUICKTORETALIATE = true;
		bNOPAIN = false;
		bNOTARGETSWITCH = false;
	}
	
	
	//============================================================================
	//
	// DragonSeek
	//
	//============================================================================

	private void DragonSeek (double thresh, double turnMax)
	{
		double dist;
		double delta;
		Actor targ;
		int i;
		double bestAngle;
		double angleToSpot, angleToTarget;
		Actor mo;

		targ = tracer;
		if(targ == null)
		{
			return;
		}

		double diff = deltaangle(angle, AngleTo(targ));
		delta = abs(diff);

		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (diff > 0)
		{ // Turn clockwise
			angle = angle + delta;
		}
		else
		{ // Turn counter clockwise
			angle = angle - delta;
		}
		VelFromAngle();

		dist = DistanceBySpeed(targ, Speed);
		if (pos.z + height < targ.pos.z || targ.pos.z + targ.height < pos.z)
		{
			Vel.Z = (targ.pos.z - pos.z) / dist;
		}
		if (targ.bShootable && random[DragonSeek]() < 64)
		{ // attack the destination mobj if it's attackable
			Actor oldTarget;
			
			if (absangle(angle, AngleTo(targ)) < 22.5)
			{
				oldTarget = target;
				target = targ;
				if (CheckMeleeRange ())
				{
					int damage = random[DragonSeek](1, 8) * 10;
					int newdam = targ.DamageMobj (self, self, damage, 'Melee');
					targ.TraceBleed (newdam > 0 ? newdam : damage, self);
					A_StartSound (AttackSound, CHAN_WEAPON);
				}
				else if (random[DragonSeek]() < 128 && CheckMissileRange())
				{
					SpawnMissile(targ, "DragonFireball");		
					A_StartSound (AttackSound, CHAN_WEAPON);
				}
				target = oldTarget;
			}
		}
		if (dist < 4)
		{ // Hit the target thing
			if (target && random[DragonSeek]() < 200)
			{
				Actor bestActor = null;
				bestAngle = 360.;
				angleToTarget = AngleTo(target);
				for (i = 0; i < 5; i++)
				{
					if (!targ.args[i])
					{
						continue;
					}
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					mo = iter.Next ();
					if (mo == null)
					{
						continue;
					}
					angleToSpot = AngleTo(mo);
					double diff = absangle(angleToSpot, angleToTarget);
					if (diff < bestAngle)
					{
						bestAngle = diff;
						bestActor = mo;
					}
				}
				if (bestActor != null)
				{
					tracer = bestActor;
				}
			}
			else
			{
				// [RH] Don't lock up if the dragon doesn't have any
				// targs defined
				for (i = 0; i < 5; ++i)
				{
					if (targ.args[i] != 0)
					{
						break;
					}
				}
				if (i < 5)
				{
					do
					{
						i = (random[DragonSeek]() >> 2) % 5;
					} while(!targ.args[i]);
					ActorIterator iter = Level.CreateActorIterator(targ.args[i]);
					tracer = iter.Next ();
				}
			}
		}
	}

	//============================================================================
	//
	// A_DragonInitFlight
	//
	//============================================================================

	void A_DragonInitFlight()
	{
		ActorIterator iter = Level.CreateActorIterator(tid);

		do
		{ // find the first tid identical to the dragon's tid
			tracer = iter.Next ();
			if (tracer == null)
			{
				SetState (SpawnState);
				return;
			}
		} while (tracer == self);
		RemoveFromHash ();
	}

	//============================================================================
	//
	// A_DragonFlight
	//
	//============================================================================

	void A_DragonFlight()
	{
		double ang;

		DragonSeek (4., 8.);
		let targ = target;
		if (targ)
		{
			if(!target.bShootable)
			{ // target died
				target = null;
				return;
			}
			ang = absangle(angle, AngleTo(target));
			if (ang <22.5 && CheckMeleeRange())
			{
				int damage = random[DragonFlight](1, 8) * 8;
				int newdam = targ.DamageMobj (self, self, damage, 'Melee');
				targ.TraceBleed (newdam > 0 ? newdam : damage, self);
				A_StartSound (AttackSound, CHAN_WEAPON);
			}
			else if (ang <= 20)
			{
				SetState (MissileState);
				A_StartSound (AttackSound, CHAN_WEAPON);
			}
		}
		else
		{
			LookForPlayers (true);
		}
	}

	//============================================================================
	//
	// A_DragonFlap
	//
	//============================================================================

	void A_DragonFlap()
	{
		A_DragonFlight();
		if (random[DragonFlight]() < 240)
		{
			A_StartSound ("DragonWingflap", CHAN_BODY);
		}
		else
		{
			PlayActiveSound ();
		}
	}

	//============================================================================
	//
	// A_DragonAttack
	//
	//============================================================================

	void A_DragonAttack()
	{
		SpawnMissile (target, "DragonFireball");
	}


	//============================================================================
	//
	// A_DragonPain
	//
	//============================================================================

	void A_DragonPain()
	{
		A_Pain();
		if (!tracer)
		{ // no destination spot yet
			SetState (SeeState);
		}
	}

	//============================================================================
	//
	// A_DragonCheckCrash
	//
	//============================================================================

	void A_DragonCheckCrash()
	{
		if (pos.z <= floorz)
		{
			SetStateLabel ("Crash");
		}
	}
	
	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_EEWander(int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value5) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEWander]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		A_Wander(flags);
	}

	// int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0
	void A_EEChase(statelabel melee = '_a_chase_default', statelabel missile = '_a_chase_default', int flags = 0, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1)
		{
			if (value1 <= 0) value1 = 3; // ticdecrement
			if (value2 <= 0) value2 = 1; // speedtimerdecrement
			if (value3 <= 0) value3 = 1; // lowcap

			if (specialspeed1)
			{
				specialspeed1 -= value2;
				tics -= value1;
				if (tics < value3) tics = value3;
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- specialspeed1: %d, ticdecrement: %d, speedtimerdecrement: %d, lowcap: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, tics);
			}
		}
		
		int NoAtkChance = 0;
		int PerkFactor;
		int SkillFactor;
		string Actorname = GetClassName();

		PlayerPawn playpawn;
		if (target) playpawn = PlayerPawn(target);
		if (playpawn)
		{
			if (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("PowerInvisibility2") ||
					playpawn.CountInv("PowerRavenInvisibility") ||
					playpawn.CountInv("PowerGhost") ||
					playpawn.CountInv("PowerGhost2"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = 8334;
				}
				else
				{
					PerkFactor = 1667;
				}
				if (PerkFactor > 10000) PerkFactor = 10000;
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
			if (playpawn.CountInv("PlayerDashing"))
			{
				if (Actorname == "ClayDevilNew")
				{
					PerkFactor = random(9937,9938);
				}
				else
				{
					PerkFactor = 8750;
				}
				SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
				NoAtkChance += SkillFactor;
			}
		}
		
		if (CountInv("ScramblerConfusion"))
		{
			PerkFactor = randompick(2500,3334,3334,3334,3334,3334,5000);
			SkillFactor = (10000 - NoAtkChance) * PerkFactor / 10000;
			NoAtkChance += SkillFactor;
		}
		
		if (dydudebug_showactormoveinfo && NoAtkChance > 0) 
		{
			if (target) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance: %d / 10000, Target: %s \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, target.GetClassName(), tics);
						 else Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance: %d / 10000 \cytics: %d\c-", GetClassName(), gametic, NoAtkChance, tics);
		}
		int BaseWanderChance = 0;
		if (random(1,10000) <= NoAtkChance)
		{
			if (flags & CHF_FASTCHASE) flags &= ~CHF_FASTCHASE;
			if (playpawn && 
				 (playpawn.CountInv("PowerInvisibility") ||
					playpawn.CountInv("PowerInvisibility2") ||
					playpawn.CountInv("PowerRavenInvisibility") ||
					playpawn.CountInv("PowerGhost") ||
					playpawn.CountInv("PowerGhost2")))
			{
				PerkFactor = 2500;
				SkillFactor = (10000 - BaseWanderChance) * PerkFactor / 10000;
				BaseWanderChance += SkillFactor;
			}
			if (CountInv("ScramblerConfusion"))
			{
				PerkFactor = randompick(2500,3334,3334,3334,3334,3334,5000);
				SkillFactor = (10000 - BaseWanderChance) * PerkFactor / 10000;
				BaseWanderChance += SkillFactor;
			}
			
			if (random(1,10000) <= BaseWanderChance) 
			{
				A_Wander();
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- A_Wander Succeed", GetClassName(), gametic);
			}
			else 
			{
				A_Chase(null,null,flags);
			}
			
			if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- NoAtkChance Succeed \cytics: %d\c-", GetClassName(), gametic, tics);
		}
		else
		{
			A_Chase(melee,missile,flags);
		}
		if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEChase]\c- Default Chase \cytics: %d\c-", GetClassName(), gametic, tics);
	}
	
	void A_EEPain(int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		A_Pain();
		
		if (type == 0)
		{
			if (value1) value1 = 0;
			if (value2) value2 = 0;
			if (value3) value3 = 0;
			if (value4) value4 = 0;
			if (value5) value5 = 0;
			if (value6) value6 = 0;
		}
		if (type == 1) // SpeedPainChange
		{
			if (random(1,100) <= value5)
			{
				if (value1 <= 0) value1 = random(18,22);
				if (value2 <= 0) value2 = 8;
				
				int extrasteps;
				if (exex_monsterlevelenabledflags) extrasteps = user_monsterlevel / value2;
				specialspeed1 = value1 + extrasteps; // Number of steps to walk fast
				if (dydudebug_showactormoveinfo) Console.Printf("\cx(%s) (gametic: %d) [A_EEPain]\c- specialspeed1: %d, basespeedtimer: %d, leveldivisor: %d, ?3: %d, ?4: %d, chanceroll[/100]: %d \cytics: %d\c-", GetClassName(), gametic, specialspeed1, value1, value2, value3, value4, value5, tics);
			}
		}

		if (GetClassName() == "Diabloist")
		{
			if (bNOTARGETSWITCH) bNOTARGETSWITCH = false;
			if (!bQUICKTORETALIATE) bQUICKTORETALIATE = true;
		}
	}

	void A_FastChaseCalc(int base = 3, int leveldivisor = 24)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		if (exex_monsterlevelenabledflags) { user_fastchaseextra = user_monsterlevel / leveldivisor; }
		user_fastchasechance = base + user_fastchaseextra + user_painfastchase;
		if (dydudebug_monsterspecialai) Console.Printf("Class: %s - \czFastChaseChance: %d (base: %d, leveldivisor: %d)\cz", GetClassName(), user_fastchasechance, base, leveldivisor); 
	}

	// Attempts to mitigate floating-monsters from drifting too out of control when fast-chasing or damaged [like if they get kicked backwards]
	// by slowing them down gradually and then stopping them at a certain interval that won't reset until they get hurt again or they attempt 
	// to fast-chase.
	void A_FloatLook(int time = 16)
	{
		A_Look();
		user_fastchasetimer = time;
		user_painreacttimer = time;
	}

	void A_FloatPain(int settime = 0, int settime2 = 8, int settime2chance = 64, int type = 0, int value1 = 0, int value2 = 0, int value3 = 0, int value4 = 0, int value5 = 0, int value6 = 0)
	{
		A_EEPain(type,value1,value2,value3,value4,value5,value6);
		if (random(1,256) <= settime2chance) user_painreacttimer = settime2; else user_painreacttimer = settime;
	}

	void A_FloatSetFChaseT(int time = 0)
	{
		user_fastchasetimer = time;
	}

	void A_FloatChaseCheck(int time1 = 4, int time2 = 8, int time3 = 12, int time4 = 16, double decelrate1 = 0.5, double decelrate2 = 0.5)
	{
		user_painreacttimer++;
		if (user_painreacttimer == time1) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time2) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time3) { A_ScaleVelocity(decelrate1); }
		if (user_painreacttimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (dydudebug_monsterspecialai) 
		{ 
			if (user_painreacttimer == time1 || user_painreacttimer == time2 || user_painreacttimer == time3 || user_painreacttimer == time4) Console.Printf("Class: %s - \cxFloatPain-painreacttimer: %d\c-", GetClassName(), user_painreacttimer); 
		}
		
		user_fastchasetimer++;
		if (user_fastchasetimer == time1) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time2) { A_ScaleVelocity(decelrate2);}
		if (user_fastchasetimer == time3) { A_ScaleVelocity(decelrate2); }
		if (user_fastchasetimer == time4) { A_ScaleVelocity(0); A_Stop(); }
		if (dydudebug_monsterspecialai) 
		{ 
			if (user_fastchasetimer == time1 || user_fastchasetimer == time2 || user_fastchasetimer == time3 || user_fastchasetimer == time4) Console.Printf("Class: %s - \cwFloatChase-fastchasetimer: %d\c-", GetClassName(), user_fastchasetimer);
		}
	}

	// Cacodemons' Shadow Split
	void A_ActorStartShadowSplit()
	{
		A_Stop();
		A_StartSound("caco/shadowsplit", CHAN_7, CHANF_DEFAULT, 1, ATTN_NONE, frandom(1.2,1.4));
		A_FaceTarget();
		bSHOOTABLE = 0;
		int user_monsterlevel = CountInv("MonsterLevel");
		
		int nonsolidchance = 1;
		if (GetClassName() == "CacodemonNew") nonsolidchance += (user_monsterlevel / 90);
		//if (GetClassName() == "Cacolantern") nonsolidchance += (user_monsterlevel / random(67,68));
		//if (GetClassName() == "Abaddon") nonsolidchance += (user_monsterlevel / 45);
		//if (GetClassName() == "DSPainElemental") nonsolidchance += (user_monsterlevel / 45);
		if (random(1,4) <= nonsolidchance) bSOLID = 0;
	}
	void A_ActorEndShadowSplit()
	{
		A_GiveInventory("ShadowSplitCooldown", 1);
		A_Stop();
		bSHOOTABLE = 1;
		if (!bSOLID) bSOLID = 1;
	}

	void A_ActorShadowSplit(int minlevel = 30, int minchance = 256)
	{
		int user_monsterlevel = CountInv("MonsterLevel");
		int splittype = 0; // 0;
		int splittype2 = 0; // 0;
		int RandRoll = random(1,1024);
		if (exex_monsterlevelenabledflags)
		{
			A_StopSound(CHAN_WEAPON);
			if (!CountInv("ShadowSplitCooldown")) 
			{
				if (user_monsterlevel >= (minlevel*9))
				{
					if (RandRoll <= (minchance*4)) splittype2 = 2;
				}
				else
				if (user_monsterlevel >= (minlevel*4))
				{
					if (RandRoll <= (minchance*2)) splittype2 = random(1,2);
				}
				else
				if (user_monsterlevel >= minlevel)
				{
					if (RandRoll <= minchance) splittype2 = randompick(1,1,1,1,1,1,1,2);
				}
				else
				if (user_monsterlevel >= (minlevel/2))
				{
					if (RandRoll <= (minchance/4)) splittype2 = randompick(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2);
				}
			}
		}

		if (splittype2 == 0)
		{
		}
		else
		if (splittype2 == 1)
		{
			splittype = random(1,4);
			if (splittype == 1) { SetStateLabel("Shadowsplit1"); }
			if (splittype == 2) { SetStateLabel("Shadowsplit2"); }
			if (splittype == 3) { SetStateLabel("Shadowsplit3"); }
			if (splittype == 4) { SetStateLabel("Shadowsplit4"); }
		}
		else
		if (splittype2 == 2)
		{
			splittype = random(1,4);
			if (splittype == 1) { SetStateLabel("Shadowsplit1a"); }
			if (splittype == 2) { SetStateLabel("Shadowsplit2a"); }
			if (splittype == 3) { SetStateLabel("Shadowsplit3a"); }
			if (splittype == 4) { SetStateLabel("Shadowsplit4a"); }
		}
		if (dydudebug_monsterspecialai) Console.Printf("Class: %s - \cuCacos' ShadowSplit --- (Level / RequiredLvl: %d / %d) splittype2: %d, splittype: %d\c-", GetClassName(), user_monsterlevel, minlevel, splittype2, splittype);
	}

	const DEFSKULLSPEED = 20;
	
	void A_SkullAttack(double skullspeed = DEFSKULLSPEED)
	{
		if (target == null) return;

		if (skullspeed <= 0) skullspeed = DEFSKULLSPEED;

		bSkullfly = true;
		A_StartSound(AttackSound, CHAN_VOICE);
		A_FaceTarget();
		VelFromAngle(skullspeed);
		Vel.Z = (target.pos.Z + target.Height/2 - pos.Z) / DistanceBySpeed(target, skullspeed);
	}

	void A_BetaSkullAttack(int basedmg = 1, int randmin = 1, int randmax = 8)
	{
		if (target == null || target.GetSpecies() == self.GetSpecies()) return;
		A_StartSound(AttackSound, CHAN_WEAPON);
		A_FaceTarget();
		
		int damage = 0;
		if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 1024))
		{
			//Console.Printf("BetaSoul [1024 Unit Attack]");
			if (random(1,16) <= 15) damage = random(randmin,randmax) * basedmg;
												 else damage = ((random(randmin,randmax) * basedmg) * frandom(0.25,0.5));
		}
		else
		{
			if (CheckIfTargetInLOS(90.0, JLOSF_DEADNOJUMP, 4096))
			{
				//Console.Printf("BetaSoul [4096 Unit Attack]");
				if (random(1,4) <= 1) damage = ((random(randmin,randmax) * basedmg) * frandom(0.25,0.5));
			}
		}

		if (exex_monsterlevelenabledflags)
		{
			damage += (CountInv("MonsterLevel") * (0.005 * random(randmin,randmax)));
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") >= 30)
			{
				damage += 0.334 + (CountInv("MonsterLevel") * (0.001667 * random(randmin,randmax)));
			}
			if (exex_monsterlevelenabledflags && CountInv("MonsterLevel") >= 60)
			{
				damage += 0.1667 + (CountInv("MonsterLevel") * (0.0008334 * random(randmin,randmax)));
			}
			damage *= (1.0 + (CountInv("MonsterLevel") * frandom(0.005,0.0075)));
		}
		
		if (damage > 0) 
		{
			target.DamageMobj(self, self, damage, 'PSI');
		}
		else
		{
			string comblog;
			comblog.AppendFormat("\c[red]*\c- ");
			if (exex_combatlog && target)
			{
				if (PlayerPawn(target))
				{
					target.A_StartSound("Player/TookNoDamage",199,CHANF_DEFAULT,frandom(0.5,0.75),ATTN_NORM);
				}
				else
				{
					target.A_StopSound(14);
					target.A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
				}
				comblog.AppendFormat("\c[red]%s\c- took \c[purple]no damage\c- from", target.GetTag());
				comblog.AppendFormat(" \c[purple]%s's", GetTag());
				comblog.AppendFormat(" \c[red]psychic attack!\c-!");
				comblog.AppendFormat(" [\c[lightblue]PSI\c-]");
				if (dydudebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				Console.Printf(comblog);
			}
		}
	}
	
	void A_PainShootSkull(Class<Actor> spawntype, double angle, int flags = 0, int limit = -1)
	{
		// Don't spawn if we get massacred.
		if (DamageType == 'Massacre') return;

		if (spawntype == null) spawntype = "LostSoul";

		// [RH] check to make sure it's not too close to the ceiling
		if (pos.z + height + 8 > ceilingz)
		{
			if (bFloat)
			{
				Vel.Z -= 2;
				bInFloat = true;
				bVFriction = true;
			}
			return;
		}

		// [RH] make this optional
		if (limit < 0 && (Level.compatflags & COMPATF_LIMITPAIN))
			limit = 21;

		if (limit > 0)
		{
			// count total number of skulls currently on the level
			// if there are already 21 skulls on the level, don't spit another one
			int count = limit;
			ThinkerIterator it = ThinkerIterator.Create(spawntype);
			Thinker othink;

			while ( (othink = it.Next ()) )
			{
				if (--count == 0)
					return;
			}
		}

		// okay, there's room for another one
		double otherradius = GetDefaultByType(spawntype).radius;
		double prestep = 4 + (radius + otherradius) * 1.5;

		Vector2 move = AngleToVector(angle, prestep);
		Vector3 spawnpos = pos + (0,0,8);
		Vector3 destpos = spawnpos + move;

		Actor other = Spawn(spawntype, spawnpos, ALLOW_REPLACE);

		// Now check if the spawn is legal. Unlike Boom's hopeless attempt at fixing it, let's do it the same way
		// P_XYMovement solves the line skipping: Spawn the Lost Soul near the PE's center and then use multiple
		// smaller steps to get it to its intended position. This will also result in proper clipping, but
		// it will avoid all the problems of the Boom method, which checked too many lines that weren't even touched
		// and despite some adjustments never worked with portals.

		if (other != null)
		{
			double maxmove = other.radius - 1;

			if (maxmove <= 0) maxmove = 16;

			double xspeed = abs(move.X);
			double yspeed = abs(move.Y);

			int steps = 1;

			if (xspeed > yspeed)
			{
				if (xspeed > maxmove)
				{
					steps = int(1 + xspeed / maxmove);
				}
			}
			else
			{
				if (yspeed > maxmove)
				{
					steps = int(1 + yspeed / maxmove);
				}
			}

			Vector2 stepmove = move / steps;
			bool savedsolid = bSolid;
			bool savednoteleport = other.bNoTeleport;
			
			// make the PE nonsolid for the check and the LS non-teleporting so that P_TryMove doesn't do unwanted things.
			bSolid = false;
			other.bNoTeleport = true;
			for (int i = 0; i < steps; i++)
			{
				Vector2 ptry = other.pos.xy + stepmove;
				double oldangle = other.angle;
				if (!other.TryMove(ptry, 0))
				{
					// kill it immediately
					other.ClearCounters();
					other.DamageMobj(self, self, TELEFRAG_DAMAGE, 'None');
					bSolid = savedsolid;
					other.bNoTeleport = savednoteleport;
					return;
				}

				if (other.pos.xy != ptry)
				{
					// If the new position does not match the desired position, the player
					// must have gone through a portal.
					// For that we need to adjust the movement vector for the following steps.
					double anglediff = deltaangle(oldangle, other.angle);

					if (anglediff != 0)
					{
						stepmove = RotateVector(stepmove, anglediff);
					}
				}

			}
			bSolid = savedsolid;
			other.bNoTeleport = savednoteleport;

			// [RH] Lost souls hate the same things as their pain elementals
			other.CopyFriendliness (self, !(flags & PAF_NOTARGET));
			
			// Inherit the PE's Master if they have a IoS master
			if (master && BossBrainNew(master)) other.master = master;
			if (dydudebug_bossbraininfo2 && other.master)
			{
				Console.Printf("%s Master: \c[gold]%p\c-", other.GetClassName(), other.master);
			}

			if (!(flags & PAF_NOSKULLATTACK))
			{
				other.A_SkullAttack();
			}
		}
	}

	void A_PainAttack(class<Actor> spawntype = "LostSoul", double addangle = 0, int flags = 0, int limit = -1)
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + addangle, flags, limit);
		}
	}
	
	void A_DualPainAttack(class<Actor> spawntype = "LostSoul")
	{
		if (target)
		{
			A_FaceTarget();
			A_PainShootSkull(spawntype, angle + 45);
			A_PainShootSkull(spawntype, angle - 45);
		}
	}
	
	void A_PainDie(class<Actor> spawntype = "LostSoul")
	{
		if (target && IsFriend(target))
		{ // And I thought you were my friend!
			bFriendly = false;
		}
		A_NoBlocking();
		A_PainShootSkull(spawntype, angle + 90);
		A_PainShootSkull(spawntype, angle + 180);
		A_PainShootSkull(spawntype, angle + 270);
	}
	
	
	void A_CheckIfTargetDead(statelabel statel = null)
	{
		if (!target)
		{
			if (dydudebug_monsterspecialai) Console.Printf("NoTarget");
			SetStateLabel(statel);
		}
		else
		{
			if (target.health <= 0)
			{
				if (dydudebug_monsterspecialai) Console.Printf("TargetDead");
				target = null;
				SetStateLabel(statel);
			}
		}
	}
	
	// Nightmare Stuff
	void A_NightmarePhaseOut()
	{
		bSHOOTABLE = 0; bNORADIUSDMG = 1; bNOPAIN = 1; bNOBLOOD = 1; 
		A_UnSetShootable();
		A_SetInventory("NightmarePhaseOutDefense",1); // A_SetInvulnerable
	}
	
	void A_NightmarePhaseIn()
	{
		bSHOOTABLE = 1; bNORADIUSDMG = 0; bNOPAIN = 0; bNOBLOOD = 0; 
		A_SetShootable();
		A_SetInventory("NightmarePhaseOutDefense",0); // A_SetInvulnerable
	}
	
	void A_GetHSHealthPreExp()
	{
		hsexphealth = health;
	}

	void A_HadesSphereTeleport(statelabel tele = "Teleport", int chance = 128, int chancemax = 1024)
	{
		if (!CountInv("HSphereTeleportCooldown") && target && CheckIfTargetInLOS(0, JLOSF_DEADNOJUMP))
		{
			if (random(1,chancemax) <= chance) { SetStateLabel(tele); }
			//if (dydudebug_monsterspecialai) Console.Printf("HSTele: Target - %s (%d / %d)", target.GetClassName(), chance, chancemax);
		}
	}
	
	// Shielding Hell Warrior
	void A_HellWarShieldOff()
	{
		bNOBLOOD = false;
		bNOPAIN = false;
		bREFLECTIVE = false;
		bINVULNERABLE = false;
		//A_SetInventory("HWShieldDefense",0); // A_UnSetInvulnerable
		//A_SetInventory("HWShieldDefenseExtra",0);
	}

	void A_HellWarShieldOn()
	{
		bNOBLOOD = true;
		bNOPAIN = true;
		bREFLECTIVE = true;
		bINVULNERABLE = true;
		//A_SetInventory("HWShieldDefense",1); // A_SetInvulnerable
		//A_SetInventory("HWShieldDefenseExtra",0);
		A_ShieldBlastVelFactor(0.5,0.5,16,1);

		if (random(1,4) == 1) 
		{
			A_SetInventory("HWShieldDefenseExtra",1); 
			A_ShieldBlastVelFactor(0.5,0.5,4,1);
		}
	}
	
	// Shielding Blasted/Vel Factor (makes shielding enemies who've been blasted slow down and occasionally can clear the BLASTED flag)
	void A_ShieldBlastVelFactor(double xmul = 0.5, double ymul = 0.5, int maxunblastchance = 16, int unblastchance = 1)
	{
		xmul = clamp(xmul, 0.0, 1.0);
		ymul = clamp(ymul, 0.0, 1.0);
		if (bBLASTED && (vel.x != 0.0 || vel.y != 0.0))
		{
			vel.x *= xmul;
			vel.y *= ymul;
			if (random(1,maxunblastchance) <= unblastchance) 
			{
				bBLASTED = false;
			}
			else
			{
				if ((vel.x >= -0.125 && vel.x <= 0.125) && (vel.y >= -0.125 && vel.y <= 0.125)) bBLASTED = false;
			}
		}
	}
	
	void A_MonsterStatsHP_ATK_DEF_SPD(int type = 0, int extraflags = 0)
	{
	}
}

class EEUniqueBoss : EECreature abstract
{
}

// A subclass for the DD/AFD unique monsters
class DDOrigCreature : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

// A subclass for the DD/AFD unique monsters
class DDAFDNPC : EECreature abstract
{
	default
	{
		MONSTER;
		+FLOORCLIP
		+NOINFIGHTING
		+NOBLOOD
		+DONTTHRUST
		+LOOKALLAROUND
		-COUNTKILL;
	}
}

class DDMiniTank : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

class DDHoganTarget : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

// A subclass for the DD/AFD unique boss-class enemies
class DDOrigBoss : EECreature abstract
{
	default
	{
		+LOOKALLAROUND;
	}
}

class DDMorphedCreature : MorphedMonster abstract
{
}

class ShieldPartBase : EEBaseZSC
{
	Actor oldtarget;

	default
	{
		Species "Players";
		Health 2147483646;
		Painchance 256;
		Radius 16; // out of 32
		Height 32; // out of 32
		Scale 0.5;
		RenderStyle "Add"; // Add
		Alpha 0.0; // 0.003125
		+NOTARGET; 
		+NEVERTARGET;
		+BUDDHA;
		+DONTBLAST;
		+SOLID; 
		+SHOOTABLE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NODAMAGE;
		+DONTRIP;
		+NOBLOOD;
		+NOBLOODDECALS;
		+FLOORCLIP;
		+NOTELESTOMP;
		+NOTIMEFREEZE;
		+THRUSPECIES;
		+MTHRUSPECIES;
		-CASTSPRITESHADOW;
		+NOSPRITESHADOW;
	}

/*
	override void PostBeginPlay()
	{
		
		Super.PostBeginPlay();
	}
*/
	
	override void Tick()
	{
		if (dydudebug_showvisibleshieldparts) A_FadeTo(0.25,0.25);
		Super.Tick();
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [ShieldPart]");
		if (source)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Source: %s]", Source.GetClassName());
		}
		if (target)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Target: %s]", Target.GetClassName());
		}
		if (inflictor)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Inflictor: %s]", inflictor.GetClassName());
		}
		if (master)
		{
			if (dydudebug_shieldpiecedmg) Console.Printf("DamageMobj [Has Master: %s]", master.GetClassName());
			if (flags & DMG_EXPLOSION && !(flags & DMG_NO_PAIN)) { flags |= DMG_NO_PAIN; } // turns on DMG_NO_PAIN;
		}

		return super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		EEProjectile UniqueProjectile;
		EEFastProjectile UniqueProjectileFast;
		playpawn = PlayerPawn(other);
		UniqueProjectile = EEProjectile(other);
		UniqueProjectileFast = EEFastProjectile(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- \c[brick]other: %s\c-", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			// Projectile Checking
			if (UniqueProjectile)
			{
				if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- UniqueProjectile: %s", gametic, UniqueProjectile.GetClassName());
				playpawn = PlayerPawn(other.target);
				playpawn2 = PlayerPawn(master);
				if (playpawn && playpawn2) return false;

				//Console.Printf("BFGShot (%d)", passive);
				if (JackShotShieldPart(self) || JackShotShieldPartFoe(self))
				{
					if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart BFGShot Dispersal (gametic %d):\c- UniqueProjectile: %s", gametic, UniqueProjectile.GetClassName());
					BFGBallBase bfgshot;
					bfgshot = BFGBallBase(other);
					if (bfgshot && !bREFLECTIVE)
					{
						bfgshot.SetStateLabel("ShotDown");
						bfgshot.bMISSILE = false;
						bfgshot.A_ScaleVelocity(0);
						bfgshot.A_SetScale(bfgshot.scale.x*0.5,bfgshot.scale.y*0.5);
						return false;
					}
				}
			}
			// Fast Projectile Checking
			if (UniqueProjectileFast)
			{
			}

			if (other)
			{
				if (PopperPuff1(other) && playpawn) return false;
				if (PopperPuff2(other) && playpawn) return false;
				if (BarrierBeam(other)) return false;
				if (other.bISMONSTER)
				{
					if (!other.bFRIENDLY)
					{
						if (other.CountInv("JustKicked") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustKicked (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustPunched") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustPunched (%s) [passive side]", other.GetClassName());
							return false;
						}
						if (other.CountInv("JustUppercutted") > 0)
						{
							if (dydudebug_shieldcollision) Console.Printf("JustUppercutted (%s) [passive side]", other.GetClassName());
							return false;
						}
					}
					if (other.bFRIENDLY) return false;
					if (other.health <= 0) return false;
					let ShieldPiece = SwingShieldPart(other); if (ShieldPiece) return false;
					let ShieldPiece2 = SwingShieldPartNoReflect(other); if (ShieldPiece2) return false;
					return true;
				}
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class NoItemSpawn : EEBaseZSC // A special 'drop' that is meant to be an empty "drop" for use in droptables
{
	states
	{
		Spawn:
			TNT1 A 0 NoDelay A_Destroy();
			stop;
	}
}

// Melee Hitsparks
class MeleeHitSpark1 : EEPuff
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS1 AABBCC 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark2 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize(); 
			}
			HTS2 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark3 : MeleeHitSpark1
{ 
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS3 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class MeleeHitSpark4 : MeleeHitSpark1
{
	default
	{
		Scale 0.375;
		VSpeed 0;
		RenderStyle "Translucent";
		+NOINTERACTION 
		+SPECTRAL
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NoDelay 
			{
				A_HitSparkGetSize();
				A_HitSparkGetSize2();
			}
		Finish:
			TNT1 A 0 
			{
				A_HitSparkResize();
			}
			HTS4 AABBCCDD 1 BRIGHT 
			{
				A_Fadeout(alpha/12); 
			}
			stop;
	}
}

class ShieldPart : ShieldPartBase // The Main segment of the sceptre-shield which deflects/blocks attacks
{
	default
	{
		+REFLECTIVE
		+AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA C 2 bright NoDelay 
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (player.CountInv("PlayingDoom64")) { A_SetSize((radius*1.2),(height*1.2),false); }
			}
			stop;
		Pain.Magic:
			TNT1 A 0;
			stop;
		Pain.Sceptre:
			TNT1 A 0;
			stop;
		Pain:
			TNT1 A 0 bright 
			{
				//Console.Printf("#$G#");
			}
			stop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class SwingShieldPart : ShieldPart // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class ShieldPartNoReflect : ShieldPart
{
	default
	{
		-REFLECTIVE
		-AIMREFLECT
	}
	States
	{
		Spawn:
			HEXA A 2 bright NoDelay
			{
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (player.CountInv("PlayingDoom64")) { A_SetSize((radius*1.2),(height*1.2),false); }
			}
			stop;
	}
}

class SwingShieldPartNoReflect : ShieldPartNoReflect // For swinging based shields [used as a general branch that allows monsters to pass through them]
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		PlayerPawn playpawn;
		PlayerPawn playpawn2;
		playpawn = PlayerPawn(other);

		if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart [%s] (gametic %d):\c- other: %s", GetClassName(), gametic, other.GetClassName());
		if (passive)
		{
			if (A_CheckCollisionProjShieldExemption(other)) return false;

			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- passive: %s", gametic, GetClassName());
			// Pass through different species of select types.
			if (playpawn) return false; // Player Checking

			if (other && other.bISMONSTER)
			{
				return false;
			}

			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;
		}
		else // Non-passive means the one moving into the other is performing the checks.
		{
			if (dydudebug_shieldcollision) Console.Printf("\cyShieldPart (gametic %d):\c- non-passive: %s", gametic, GetClassName());
			playpawn = PlayerPawn(other.target);
			playpawn2 = PlayerPawn(master);
			if (playpawn && playpawn2) return false;

			return true;
		}

		// We don't really care about others making the check.
		return true;
	}
}

class PlayerWhistle : EEBaseZSC
{
	default
	{
		-SOLID
		+NOBLOCKMAP
		+NOINTERACTION
		+NOGRAVITY
		+NOTELESTOMP
		+MISSILE
		Speed 1;
		Height 1;
		Radius 1;
		Tag "Whistling";
	}
	States
	{
		Spawn:
			TNT1 A 1 NoDelay 
			{
				double vol = frandom(0.86,1.14);
				int range = 256;
				int dmg = random(1,4);
				if (target)
				{
					let MiscItem = PlayerStatItem(target.player.mo.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						int TruePlayerLevel = MiscItem.TruePlayerLevel;
						if (TruePlayerLevel >= 25) dmg = random(2,4);
						if (TruePlayerLevel >= 50) dmg = random(3,4);
						if (TruePlayerLevel >= 75) dmg = random(4,5);
						if (TruePlayerLevel >= 100) dmg = random(5,5);
						if (TruePlayerLevel >= 125) dmg = random(6,7);
						if (TruePlayerLevel >= 150) dmg = random(7,7);
						if (TruePlayerLevel >= 175) dmg = random(8,9);
						if (TruePlayerLevel >= 200) dmg = random(9,9);
						dmg += (TruePlayerLevel * frandompick(0.1875,0.25,0.3125));
						
						range = 64;
						range += (TruePlayerLevel * frandompick(0.75,1,1.25));
					}
					if (target.CountInv("PowerStrength") || target.CountInv("PowerStrengthDD")) 
					{
						range *= frandom(4.5,5.5);
						dmg *= frandom(9,11);
						vol *= 1.2;
					}
				}
				
				if (target.GetClassName() == "DinahPlayer")
				{
					A_StartSound("player/whistle5",CHAN_VOICE,CHANF_DEFAULT,vol,ATTN_NONE,frandom(0.76,1.24));
					A_Explode((dmg),range,XF_NOSPLASH,true,(range * 0.5),0,0,"","Beats");
				}
			}
			TNT1 A 1 
			{
				if (target && target.GetClassName() == "DinahPlayer")
				{
					A_AlertMonsters();
				}
			}
			stop;
	}
}

class BatNew : EEBaseZSC replaces Bat
{
	Default
	{
		Speed 5;
		Radius 3;
		Height 3;
		+NOBLOCKMAP +NOGRAVITY +MISSILE
		+NOTELEPORT +CANPASS
	}

	States
	{
		Spawn:
			ABAT ABC 2 A_BatMove;
			Loop;
		Death:
			ABAT A 2;
			Stop;
	}
	
	void A_BatMove()
	{
		if (special2 < 0)
		{
			SetStateLabel ("Death");
		}
		special2 -= 2;		// Called every 2 tics

		double newangle;
		if (random[BatMove]() < 128)
		{
			newangle = Angle + args[4];
		}
		else
		{
			newangle = Angle - args[4];
		}

		// Adjust velocity vector to new direction
		VelFromAngle(Speed, newangle);

		if (random[BatMove]() < 15)
		{
			A_StartSound ("BatScream", CHAN_VOICE, CHANF_DEFAULT, 1, ATTN_IDLE);
		}

		// Handle Z movement
		if (target)
		{
			SetZ(target.pos.Z + 2 * BobSin(args[0]));
			args[0] = (args[0] + 3) & 63;	
		}
	}
}

class PoisonCloudEE : EEBaseZSC replaces PoisonCloud
{
	Default
	{
		Tag "Poisonous Mushroom Bog";
		Radius 20;
		Height 30;
		Mass 0x7fffffff;
		+NOBLOCKMAP +NOGRAVITY +DROPOFF
		+NODAMAGETHRUST
		+DONTSPLASH +FOILINVUL +CANBLAST +BLOODLESSIMPACT +BLOCKEDBYSOLIDACTORS +FORCEZERORADIUSDMG +OLDRADIUSDMG
		RenderStyle "Translucent";
		Alpha 0.6;
		DeathSound "PoisonShroomDeath";
		DamageType "PoisonCloud";
	}

	States
	{
		Spawn:
			PSBG D 1;
			PSBG D 1 A_Scream;
			PSBG DEEEFFFGGGHHHII 2 A_PoisonBagDamage;
			PSBG I 2 A_PoisonBagCheck;
			PSBG I 1 A_PoisonBagCheck;
			Goto Spawn + 3;
		Death:
			PSBG HG 7;
			PSBG FD 6;
			Stop;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override void BeginPlay ()
	{
		Vel.X = MinVel; // missile objects must move to impact other objects
		special1 = random[PoisonCloud](24, 31);
		special2 = 0;
	}
	
	//===========================================================================
	//
	// 
	//
	//===========================================================================

	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim.player)
		{
			DDPlayerPawn playpawn;
			playpawn = DDPlayerPawn(victim);
			bool mate = (target != null && victim.player != target.player && victim.IsTeammate (target));
			bool dopoison;
			
			if (!mate)
			{
				dopoison = victim.player.poisoncount < 4;
			}
			else
			{
				dopoison = victim.player.poisoncount < (int)(4. * level.teamdamage);
			}

			if (dopoison)
			{
				damage = random[PoisonCloud](15, 30);
				if (mate)
				{
					damage = (int)(damage * level.teamdamage);
				}
				// Handle passive damage modifiers (e.g. PowerProtection)
				damage = victim.GetModifiedDamage(damagetype, damage, true);
				// Modify with damage factors
				damage = victim.ApplyDamageFactor(damagetype, damage);
				if (damage > 0)
				{
					victim.player.PoisonDamage (self, random[PoisonCloud](15, 30), false); // Don't play painsound

					// If successful, play the poison sound.
					if (victim.player.PoisonPlayer (self, self.target, 50))
					{
						if (playpawn) playpawn.A_DDPain();
						else victim.A_StartSound ("*poison", CHAN_VOICE);
					}
				}
			}	
			return -1;
		}
		else if (!victim.bIsMonster)
		{ // only damage monsters/players with the poison cloud
			return -1;
		}
		return damage;
	}
	
	//===========================================================================
	//
	// A_PoisonBagCheck
	//
	//===========================================================================

	void A_PoisonBagCheck()
	{
		if (--special1 <= 0)
		{
			SetStateLabel("Death");
		}
	}

	//===========================================================================
	//
	// A_PoisonBagDamage
	//
	//===========================================================================

	void A_PoisonBagDamage()
	{
		A_Explode(4, 40);
		AddZ(BobSin(special2) / 16);
		special2 = (special2 + 1) & 63;
	}
}

// Practice Target
class PracticeTarget : EECreature //21333
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category "EE Monsters"
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		-SOLID;
		-COUNTKILL;
	}
		
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1 
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}

class PracticeTarget2 : EECreature
{
	default
	{
		Tag "Practicing Target";
		//$Angled
		//$Color 6
		//$Category "EE Monsters"
		//$Sprite "PRDUA0"
		Radius 16;
		Height 48;
		Health 10000000;
		Mass 275000000;
		PainChance 255;
		
		Scale 0.4325; // 0.25
		
		+ISMONSTER;
		+SHOOTABLE;
		+NOBLOOD;
		+FORCEYBILLBOARD;
		+NEVERTARGET;
		+NOPAIN;
		+SOLID;
		-COUNTKILL;
	}
	
	States
	{
		Spawn:
			PRDU A 0 NoDelay Bright
			{
				targetdummyhitcooldown = -1;
			}
		See:
			PRDU A 1
			{
				if (targetdummyhitcooldown > 0) 
				{
					targetdummyhitcooldown--;
					//Console.Printf("targetdummyhitcooldown: %d", targetdummyhitcooldown);
				}
				if (targetdummyhitcooldown == 0) 
				{
					int oldhealth = health;
					A_EEHealThing(10000000, SpawnHealth(), 1);
					string dps = "";
					dps.AppendFormat("\c[brick]DPS:\c- \c[gold]%d\c- / sec", abs(oldhealth-health));
					A_PrintBold(dps);
					targetdummyhitcooldown--;
				}
			}
			Loop;
		Pain: goto See;
		Death:
			TNT1 A -1 A_SpawnItemEx("PracticeTarget2", 0, 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
			Stop;
	}
}