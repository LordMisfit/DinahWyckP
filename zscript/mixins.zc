mixin class HUDRecovery
{
	void A_StatIncHud(int recovery, int type)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud [MiscItem]");
			if (type == 0) // Max HP
			{
				if (MiscItem.MaxHPIncTimer <= 0) MiscItem.MaxHPIncTimer = 105;
				else
				{
					MiscItem.MaxHPIncTimer += 35;
					if (MiscItem.MaxHPIncTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.MaxHPIncTimer > 175) MiscItem.MaxHPIncTimer = 175;
				}
				MiscItem.MaxHPIncAmt += recovery;
				if (dydudebug_hudrecdmgdisplays) Console.Printf("Max HP Gain: %d [%d] (timer: %d)", MiscItem.MaxHPIncAmt, recovery, MiscItem.MaxHPIncTimer);
			}
			if (type == 1) // Dash Length
			{
				if (MiscItem.MaxDashIncTimer <= 0) MiscItem.MaxDashIncTimer = 105;
				else
				{
					MiscItem.MaxDashIncTimer += 35;
					if (MiscItem.MaxDashIncTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.MaxDashIncTimer = 105;
					if (MiscItem.MaxDashIncTimer > 175) MiscItem.MaxDashIncTimer = 175;
				}
				MiscItem.MaxDashIncAmt += recovery;
				if (dydudebug_hudrecdmgdisplays) Console.Printf("Max Dash Gain: %d [%d] (timer: %d)", MiscItem.MaxDashIncAmt, recovery, MiscItem.MaxDashIncTimer);
			}
		}
	}
	
	void A_AddIP(double base, double basef, bool acculmuatepulse)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		
		int IPTimerBaseInc = -35;
		if (MiscItem) 
		{
			base *= (1.0 + (MiscItem.PlayerLevel * 0.0025));
			if (base <= 0.01) base = 0.01;
			if (basef <= 0.01) basef = 0.01;
			
			if (base)
			{
				if (MiscItem.IPTimer1 > 0) MiscItem.IPTimer1 = (IPTimerBaseInc * basef);
															else MiscItem.IPTimer1 += (IPTimerBaseInc * basef);
				MiscItem.ItemPoints += base;
				globalvars.ItemPoints += base;
				
				if (MiscItem.IPHUDPulseTimer <= 0) MiscItem.IPHUDPulseTimer = 105;
				else
				{
					MiscItem.IPHUDPulseTimer += 35;
					if (MiscItem.IPHUDPulseTimer < 105 && base > (MiscItem.MaxItemPoints * 0.10)) MiscItem.IPHUDPulseTimer = 105;
					if (MiscItem.IPHUDPulseTimer > 175) MiscItem.IPHUDPulseTimer = 175;
				}
				
				if (acculmuatepulse && base > 0 && (MiscItem.ItemPointsSession < MiscItem.MaxItemPoints))
				{
					MiscItem.ItemPointsSession += base;
					if (MiscItem.ItemPointsSession >= MiscItem.MaxItemPoints) MiscItem.ItemPointsSession == MiscItem.MaxItemPoints;
					if (MiscItem.ItemPointsSession > 0 && base > 0)
					{
						int healfactor = MiscItem.ItemPointsSession * 100 / MiscItem.MaxItemPoints;
						if (healfactor < 10) MiscItem.IPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.IPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.IPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.IPHUDPulseType = 4;
						MiscItem.IPHUDPulseTimeP = (level.time % randompick(10,15,20));
					}
				}
				
				if (exex_playerdmglog) Console.Printf("\c[red]+%.2f%% IP Gained!", base);
			}
		}
	}
	
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					if (player.CountInv("KnightGownItem")) armmax = 250;
					if (player.CountInv("KnightGownItem2")) armmax = 500;
					if (player.CountInv("KnightGownItem3")) armmax = 1000;
					if (player.CountInv("KnightGownItem4")) armmax = 2000;
					if (armmax)
					{
						if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.APHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
							MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
		}
	}

	void A_LossHUD(int loss, int type, bool acculmuateshake)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_LossHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_LossHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Loss [HUD]
				if (MiscItem.HPDmgHUDTimer <= 0) MiscItem.HPDmgHUDTimer = 105;
				else
				{
					MiscItem.HPDmgHUDTimer += 35;
					if (MiscItem.HPDmgHUDTimer < 105 && loss > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPDmgHUDTimer = 105;
					if (MiscItem.HPDmgHUDTimer > 175) MiscItem.HPDmgHUDTimer = 175;
				}
				MiscItem.HPDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (dydudebug_hudrecdmgdisplays) Console.Printf("HP loss: %d", loss);
					if (MiscItem.HPDmgHUDAmt > 0 && loss > 0)
					{
						MiscItem.HPHUDShakeTime += random(52,53);
						int damagetakefactor = MiscItem.HPDmgHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (damagetakefactor < 10)
						{
							MiscItem.HPHUDShakeType = 1;
							if (MiscItem.HPHUDShakeTime > 53) MiscItem.HPHUDShakeTime = 53;
						}
						if (damagetakefactor >= 10) 
						{
							MiscItem.HPHUDShakeType = 2;
							if (MiscItem.HPHUDShakeTime > 88) MiscItem.HPHUDShakeTime = 88;
						}
						if (damagetakefactor >= 50) 
						{
							MiscItem.HPHUDShakeType = 3;
							if (MiscItem.HPHUDShakeTime > 140) MiscItem.HPHUDShakeTime = 140;
						}
						if (damagetakefactor >= 100) 
						{
							MiscItem.HPHUDShakeType = 4;
							if (MiscItem.HPHUDShakeTime > 175) MiscItem.HPHUDShakeTime = 175;
						}
					}
				}
				
				if (dydudebug_hudrecdmgdisplays) Console.Printf("HP Loss: %d [%d] (timer: %d)", MiscItem.HPDmgHUDAmt, loss, MiscItem.HPDmgHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Loss [HUD]
				if (MiscItem.APDmgHUDTimer <= 0) MiscItem.APDmgHUDTimer = 105;
				else
				{
					MiscItem.APDmgHUDTimer += 35;
					if (MiscItem.APDmgHUDTimer < 105 && loss > 1) MiscItem.APDmgHUDTimer = 105;
					if (MiscItem.APDmgHUDTimer > 175) MiscItem.APDmgHUDTimer = 175;
				}
				MiscItem.APDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (dydudebug_hudrecdmgdisplays) Console.Printf("AP loss: %d", loss);
					int armmax;
					if (player.CountInv("KnightGownItem")) armmax = 250;
					if (player.CountInv("KnightGownItem2")) armmax = 500;
					if (player.CountInv("KnightGownItem3")) armmax = 1000;
					if (player.CountInv("KnightGownItem4")) armmax = 2000;
					if (armmax)
					{
						int damagetakefactor = MiscItem.APDmgHUDAmt * 100 / armmax;
						if (MiscItem.APDmgHUDAmt > 0 && loss > 0)
						{
							MiscItem.APHUDShakeTime += random(52,53);
							if (damagetakefactor < 10) 
							{
								MiscItem.APHUDShakeType = 1;
								if (MiscItem.APHUDShakeTime > 53) MiscItem.APHUDShakeTime = 53;
							}
							if (damagetakefactor >= 10)
							{
								MiscItem.APHUDShakeType = 2;
							if (MiscItem.APHUDShakeTime > 88) MiscItem.APHUDShakeTime = 88;
							}
							if (damagetakefactor >= 50)
							{
								MiscItem.APHUDShakeType = 3;
							if (MiscItem.APHUDShakeTime > 140) MiscItem.APHUDShakeTime = 140;
							}
							if (damagetakefactor >= 100)
							{
								MiscItem.APHUDShakeType = 4;
							if (MiscItem.APHUDShakeTime > 175) MiscItem.APHUDShakeTime = 175;
							}
						}
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("AP Loss: %d [%d] (timer: %d)", MiscItem.APDmgHUDAmt, loss, MiscItem.APDmgHUDTimer);
			}
		}
	}
}

mixin class DmgCalc
{
	action int A_GetPunchDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		int damage;
		int previousdamage;
		int strengthcounter;
		String nm, nn, no, np;

		int Power;
		if (istarget && target) Power = target.player.mo.Stamina;
		else Power = player.mo.Stamina;
		if (Power) Power /= 10;
		if (Power > 10) Power = 10;

		// Character Check [base damage]
		If (weapon is "HandToHand")
		{
			if (altfire == 0)
			{
				damage = (random(9,15) + (Power * 0.9));
			}
			else
			if (altfire == 1)
			{
				damage = (random(59,101) + (Power * 6.663));
			}
			if (Power) damage *= frandom(1.00,(1.00 + (Power * frandompick(0.667,0.75,0.834))));
		}
		else
		{
			damage = random(9,15);
		}
		if (dydudebug_meleedmg) Console.Printf("BaseDmg: %d [%s, %s]", damage, weaponname, actorname);

		// Berserk Check
		previousdamage = damage;
		if (CountInv("PowerStrength", AAPTR_PLAYER1) || CountInv("PowerStrengthDD", AAPTR_PLAYER1)) damage = floor(damage * 10);
		if (dydudebug_meleedmg) Console.Printf("BerserkDmg: %d - (Previous Dmg: %d) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,2,2,2,2,2,3)));
			if (dydudebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (\c[green]%s\c-) %d - (Previous Dmg: %d)", weaponname, damage, previousdamage);
		}
		else
		{
			previousdamage = damage;
		}

		previousdamage = damage;
		If (weapon is "HandToHand")
		{
			if (CountInv("DinahTrueIPState")) damage *= 5;
			if (altfire == 0) damage = damage;
		}
		if (dydudebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %d - (Previous Dmg: %d) [Punch]", weaponname, damage, previousdamage);
		if (dydudebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %d - (Previous Dmg: %d) [Uppercut]", weaponname, damage, previousdamage);

		if (istarget)
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %d\c- - \cx(Previous Dmg: %d) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %d\c- - \cx(Previous Dmg: %d) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %d\c- - \cx(Previous Dmg: %d) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %d\c- - \cx(Previous Dmg: %d) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return damage;
	}
}

mixin class CollisionChecker
{
	string infl;
	actor projowner;
	// Checks for certain projectiles from charmed/friendly allies to pass through other friendlies instead of colliding
	int A_CheckFriendCollisionProjTypeFriendlyDoom()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyDoom:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyHeretic()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHeretic:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyHexen()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHexen:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyStrife()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyStrife:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyOthers()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyOthers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendly1()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendly1:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer(Actor actr)
	{
		infl = actr.GetClassName();
		projowner = actr.target;
		actor PlayPawn = PlayerPawn(projowner);
		actor ProjD;
		ProjD = DDProjectile(actr);
		
		int type;
		if (ProjD && PlayPawn) type = 1;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer2(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (
				// Circus 2 Stuff
				infl == "Sparkles" ||
				CrazyBits1(actr) ||
				infl == "Popcorn_Shrap1" ||
				infl == "Popcorn_Shrap7" ||
				infl == "CrazyBalls" ||
				infl == "CrazyBall" ||
				infl == "CrazyBallDD"
			 ) type = 1;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer2:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckCollisionProjShieldExemptionE(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		If (BadJackShot(actr)) type = 1;
	
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckCollisionProjShieldExemption(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (MalletShot(actr) || 
				MalletShotBerserk(actr) || 
				BlunderShot(actr) || 
				EggShot(actr) || 
				EggGrenade(actr) || 
				EggMini(actr) || 
				ZapShot(actr) || 
				JackShot(actr) || 
				RecordShot(actr) || 
				VacShot(actr) || 
				CherryBombShot(actr) || 
				BRocketShot(actr) || 
				BRocketBoom1(actr) || 
				BRocketBoom2(actr) || 
				SpinnerShot(actr) || 
				infl == "StreamerShot" || 
				infl == "StreamerTrail" || 
				infl == "PopperPuff1" || 
				infl == "PopperPuff2" || 
				infl == "SnakeGrenade" || 
				infl == "SnakeMiniGrenade" 
			 ) type = 1;
	
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
}

mixin class MonsterCollider
{
	int targetdummyhitcooldown;
	Actor lastattacker;
	Actor lastattackeratk;
	Actor playeriskiller;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	// Resurrections
	override bool CanResurrect(Actor other, bool passive)
	{
		bool ResSucceed = true;
		if (!passive) // Monster is the one REVIVING...
		{
			if (other != self)
			{
				let Vile = Archvile(self);
				if (Vile) 
				{
					if (Vile.health > ((Vile.SpawnHealth() + Vile.Stamina) * 0.667))
					{
						ResSucceed = true;
						if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect anything");
					}
					else
					{
						if (Vile.health > ((Vile.SpawnHealth() + Vile.Stamina) * 0.334))
						{
							if ((other.SpawnHealth() + other.Stamina) <= 500)
							{
								ResSucceed = true;
								if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Resurrectee's max health is low enough");
							}
							else
							{
								ResSucceed = false;
								if (dydudebug_ressurrectdisplays) Console.Printf("Failed: Vile's Health Too Low");
								if (exex_combatlog) Console.Printf("\c[red]*\c- \c[brick]%s\c- failed to resurrect \c[purple]%s\c- because their health is too low! [%d]", GetTag(), other.GetTag(), gametic);
							}
						}
						else
						{
							if ((other.SpawnHealth() + other.Stamina) <= 150)
							{
								ResSucceed = true;
								if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Resurrectee's max health is low enough");
							}
							else
							{
								ResSucceed = false;
								if (dydudebug_ressurrectdisplays) Console.Printf("Failed: Vile's Health Too Low");
								if (exex_combatlog) Console.Printf("\c[red]*\c- \c[brick]%s\c- failed to resurrect \c[purple]%s\c- because their health is too low! [%d]", GetTag(), other.GetTag(), gametic);
							}
						}
					}
				}
				if (exex_combatlog) 
				{
					if (ResSucceed)
					{
						string sndname = "Resurrection/Evil";
						if (other.bBOSS) sndname = "Resurrection/EvilBig";
						other.A_StopSound(15);
						other.A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
						Console.Printf("\c[red]*\c- \c[brick]%s\c- is resurrecting \c[purple]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
					}
				}
			}
			else
			{
				if (exex_combatlog) 
				{
					if (ResSucceed)
					{
						string sndname = "Resurrection/Evil";
						if (bBOSS) sndname = "Resurrection/EvilBig";
						A_StopSound(15);
						A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
						Console.Printf("\c[red]*\c- \c[brick]%s\c- is self resurrecting! [%d]", GetTag(), gametic);
					}
				}
			}
		}
		else // Monster is the one BEING REVIVED...
		{
			if (RoseMotherClone(other))
			{
				let Vile = Archvile(self);
				if (Vile) 
				{
					if (Vile.health >= (Vile.SpawnHealth() + Vile.Stamina))
					{
						ResSucceed = true;
						if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect %s! [%d]", other.GetTag(), gametic);
					}
					else
					{
						ResSucceed = false;
						if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is NOT High Enough (i.e. Max or Higher) to resurrect %s! [%d]", other.GetTag(), gametic);
					}
				}
			}
			//if (exex_combatlog) Console.Printf("\c[red]*\c- \c[purple]%s\c- is being resurrected by \c[brick]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
		}
		return ResSucceed;
	}

	// Collisions
	override bool CanCollideWith(Actor other, bool passive)
	{
		ShieldPart shieldpiece;
		shieldpiece = ShieldPart(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
			
			// Pass through certain shield parts, ones that would normally cause a monster to be bumped around by running into them
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - \c[green]%s\c- [ShieldPiece] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
				if (shieldpiece.GetClassName() == "CricketShieldPart" || shieldpiece.GetClassName() == "CricketShieldPartNoReflect" ||
						shieldpiece.GetClassName() == "ShieldPartMeleeNoReflect" || shieldpiece.GetClassName() == "ShieldPartMeleeNoReflect")
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - \c[green]%s\c- [MeleeShieldPart] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
					return true;
				}
				return false;
			}

			// Pass through players, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.GetSpecies() == "Players")
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerType] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}

			// Pass through other actors, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.bFRIENDLY == 1)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}
		}
		else
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (\c[green]%s\c-) vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
			
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false;
			}
			return true; 
		}

		// We don't really care about others making the check.
		return true;
	}
	
	// Damage Tracking
	int initdmg;
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		initdmg = damage;
		int shieldtype;
		if (dydudebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): initdmg vs Damage: %d vs %d", GetClassName(), initdmg, damage);
		if (dydudebug_actordmgdisplays && source) Console.Printf("(\c[green]%s\c-): dmgsource: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), source, source.GetClassName());
		if (dydudebug_actordmgdisplays && inflictor) Console.Printf("(\c[green]%s\c-): dmginflictor: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), inflictor, inflictor.GetClassName());
		nm = "CCards_Actor_Ghost"; if (CountInv(nm)) A_SetInventory("CCardGhostMarker",1);
		nm = "CCards_Actor_HasRespawned"; if (CountInv(nm)) A_SetInventory("CCardRespawnedMarker",1);
		nm = "CCards_Actor_AssassinBuff"; if (CountInv(nm)) A_SetInventory("CCardAssassinMarker",1);
		
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) DamageMobj [Mixin]", GetClassName());
		int oldhealth = health;
		int initdmg = damage;
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) initdmg: %d, oldhealth: %d", GetClassName(), initdmg, oldhealth);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor != null) lastattackeratk = inflictor;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source != null) lastattacker = source;
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		if (score & 16)
		{
			if (GetRenderStyle() != default.GetRenderStyle())
			{
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) alpha: %.8f, defalpha: %d", GetClassName(), alpha, default.alpha);
				if (infl == "VacPuff" && random(1,8) <= 5) A_SetRenderStyle(default.alpha, default.GetRenderStyle());
			}
		}
		
		if (ExplosiveBarrelNew(self))
		{
			if (mod == 'Beats' && flags & DMG_EXPLOSION)
			{
				damage = 0;
				return 0;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Barrel Hit by AOE 'Beats'", GetClassName());
			}
			else 
			if (CandlePuff(inflictor) || WhipPuff(inflictor))
			{
				if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
				damage += (SpawnHealth() * 2);
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Barrel Hit by Candle Shot 'Beats'", GetClassName());
			}
		}
		
		if (bDORMANT)
		{
			if (!(mod == "SilentMassacre" || mod == "Massacre" || mod == "InstantDeath")) return 0;
		}

		if (dydudebug_actordmgdisplays)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
		}
		
		if (bFRIENDLY && ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor))))
		{
			actor src;
			if (source) src = PlayerPawn(source);
			if (!source && inflictor) src = PlayerPawn(inflictor);
			damage = 0;
			if (dydudebug_actordmgdisplays) 
			{
				if (src) Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY) [src: \c[brick]%p\c- (\c[red]%s\c-)]", GetClassName(), src, src.GetClassName());
						else Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY)", GetClassName());
			}
			return 0;
		}

		bool wasblastedimpact = false;
		if (inflictor == null && source == null && mod == 'Melee') 
		{
			wasblastedimpact = true;
			if (bBLASTED && random(1,20) <= 19) 
			{
				damage *= 0.0625;
				bBLASTED = false;
			}
			else
			{
				damage *= 0.25;
			}
			if (vel.x != 0.0) vel.x *= 0.1;
			if (vel.y != 0.0) vel.y *= 0.1;
			if (dydudebug_actordmgdisplays && wasblastedimpact) Console.Printf("(\c[green]%s\c-) (\czwasblastedimpact?: %d", GetClassName(), wasblastedimpact);
		}
		if (vict == "PracticeTarget" || vict == "PracticeTarget2") targetdummyhitcooldown = 175;

		//*******
		//*******
		//*******
		double hndmthslddmg;
		if (HandMotherPhaseAClone(self) ||
				HandMotherPhaseBClone(self) ||
				HandMotherPhaseCClone(self))
		{
			int prevdmg = damage;
			if (CountInv("ShieldEmitter")) 
			{
				hndmthslddmg = frandompick(0.2,0.25,0.25,0.25,0.334);
				damage *= hndmthslddmg;
				shieldtype = 3;
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}
		
		double JorgKilSoloFactor = frandompick(1.5,1.75,1.75,1.75,2.0,2.0,2.0,2.0,2.0,2.0,2.25,2.25,2.25,2.5);
		if (Teacher_JorgClone(self))
		{
			int prevdmg = damage;
			if ((inflictor && KilletanteSoloist(inflictor)) || (source && KilletanteSoloist(source)))
			{
				damage *= JorgKilSoloFactor;
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}
		if (KilletanteSoloist(self))
		{
			int prevdmg = damage;
			if ((inflictor && Teacher_JorgClone(inflictor)) || (source && Teacher_JorgClone(source)))
			{
				damage *= (1.0 / JorgKilSoloFactor);
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}

		if (Teacher_VokterClone(self))
		{
			int prevdmg = damage;
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone", GetClassName());
			if (CountInv("VokterCloneShield"))
			{
							 if (mod == 'Cricket') damage *= 0.25;
					else if (mod == 'Dashing') damage *= 1.5;
				else if (mod == 'DashingBG') damage *= 8;
																else damage *= 0.0625;
				shieldtype = 1;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Shield 1]: %d (%d)", GetClassName(), damage, prevdmg);
			}
			if (CountInv("VokterCloneShield2")) 
			{
							 if (mod == 'Cricket') damage *= 0.25;
					else if (mod == 'Dashing') damage *= 1.5;
				else if (mod == 'DashingBG') damage *= 8;
																else damage *= 0.015625;
				shieldtype = 2;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Shield 2]: %d (%d)", GetClassName(), damage, prevdmg);
			}
			if (CountInv("VokterCloneStun"))
			{
				damage *= 2.5;
				shieldtype = 0;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Stunned]: %d (%d)", GetClassName(), damage, prevdmg);
			}
		}

		if (KilletanteSoloist(self) && IsFrozen())
		{
			damage *= frandompick(0.20,0.25);
			Console.Printf("%s resists your damage due to being frozen in time!", GetTag());
			A_StartSound("misc/ResistanceHit",21,CHANF_DEFAULT,frandom(1.25,1.334),ATTN_NORM,frandom(0.875,1.125));
		}

		// Checks for if you're fighting a Serpent Rider boss
		if (mod != 'Sigil' || mod != 'Massacre' || mod != 'Telefrag') // Make sure the Sigil can deal full damage and ignores this resistance entirely :V
		{
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Check for Serpent Rider", GetClassName());
			let SerpentRider = Sorcerer2New(self);
			let SerpentRider2 = KoraxNew(self);
			//let SerpentRider3 = EidolonNew(self); // LUL I wish >.>;
			int prevdmg = damage;
			if (SerpentRider || SerpentRider2) // || SerpentRider3
			{
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Serpent Rider", GetClassName());
				// If D'Sparil is hit by Cherry Bombs or Korax is hit by Cricket Balls, IGNORE their increasing resistances entirely :V
				if ((SerpentRider && mod != 'CherryBomb') || (SerpentRider2 && mod != 'Cricket'))
				{
					if (dydudebug_actordmgdisplays && SerpentRider) Console.Printf("(\c[green]%s\c-) D'Spari (Wasn't hit by Cherry Bomb)", GetClassName());
					if (dydudebug_actordmgdisplays && SerpentRider2) Console.Printf("(\c[green]%s\c-) Korax (Wasn't hit by Cricket Ball)", GetClassName());
					let SerpRide = Actor(self);
					if (SerpRide)
					{
						if (health < ((SpawnHealth() + Stamina) >> 1)) // <50%
						{
							if (health < ((SpawnHealth() + Stamina) >> 4)) // <6.25%
							{
								if (health < ((SpawnHealth() + Stamina) >> 9)) // <0.1953125%
								{
									damage *= 0.125;
								}
								else
								{
									damage *= 0.25;
								}
							}
							else
							{
								damage *= 0.50;
							}
						}
					}
					if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Serpent Rider [Damage Resist Buff]: %d (%d)", GetClassName(), damage, prevdmg);
				}
			}
		}

		// Special SuperVac Suck Attack Checks :V
		if (GetClassName() == "BossBrainNew" || GetClassName() == "Sorcerer2New" || GetClassName() == "KoraxNew")
		{
			if (mod == 'Suck' && damage > health)
			{
				if (damage > health) 
				{
					Console.Printf("\c[red]You cannot kill %s with the SuperVac's suck attack! You must use a different weapon to finish it!", GetTag());
					return 0; // The above bosses CANNOT die from the SuperVac
				}
			}
		}

		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Pre-Function Call: damage: %d (initdmg: %d)", GetClassName(), damage, initdmg);
		//************************************************************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//************************************************************************
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Post-Function Call: ret: %d (pre-function damage: %d) (initdmg: %d)", GetClassName(), ret, damage, initdmg);
		
		if ((initdmg > 0 && ret == 0) || bINVULNERABLE || bNODAMAGE)
		{
			bool showdmglog;
			int tempdmgval = 10000;
			double tempdmgfactor = damagefactor;
			damagefactor = 1.0;
			int moddedDMG = ApplyDamageFactor(mod, tempdmgval);
			if (shieldtype > 0)
			{
				if (shieldtype == 1) moddedDMG *= 0.0625;
				if (shieldtype == 2) moddedDMG *= 0.03125;
				if (shieldtype == 3) moddedDMG *= hndmthslddmg;
				if (shieldtype >= 1 && shieldtype <= 2)
				{
					int basetauntchance = 1;
					int basetauntchancemax = 8;
					if (mod == 'Zap') basetauntchance *= random(2,3);
					if (mod == 'Cricket') basetauntchancemax *= random(2,3);
					if (random(1,basetauntchancemax) <= basetauntchance) 
					{
						A_StopSound(CHAN_VOICE);
						A_StartSound("vokter/shieldtaunt",CHAN_VOICE);
					}
				}
			}
			damagefactor = tempdmgfactor;
			double outputdmgfactor = 1.0;
			outputdmgfactor *= moddedDMG;
			outputdmgfactor /= tempdmgval;
			if (dydudebug_actordmgdisplays || dydudebug_hitsounds) Console.Printf("(\c[green]%s\c-) moddedDMG: %d (%.8f) (%s), damagefactor: %.8f", GetClassName(), moddedDMG, outputdmgfactor, mod, damagefactor);

			if (exex_q3aqchitsounds2)
			{
				if (moddedDMG <= (tempdmgval * 0.6666667) || bINVULNERABLE || bNODAMAGE)
				{
					if ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor)))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_q3aqchitsoundvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.8,1,1.25));
					}
					else
					if ((source && source.bFRIENDLY) || (inflictor && inflictor.bFRIENDLY))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_q3aqchitsoundvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.5,0.625,0.78125));
					}
					else
					if (source || inflictor)
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_q3aqchitsoundvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
					}
				}
			}
			if (exex_combatlog && showdmglog)
			{
				string victname = GetTag();
				string atkrname = "(?)";
				string attkernam;
				if (!GetTag()) victname = vict;
				if (source)
				{
					if (source.GetTag()) attkernam = source.GetTag();
													else attkernam = source.GetClassName();
				}
				if (inflictor)
				{
					if (inflictor.GetTag()) atkrname = inflictor.GetTag();
														 else atkrname = inflictor.GetClassName();
				}
				string comblog = "";
				comblog.AppendFormat("\c[red]*\c- ");
				if (mod == 'NONE') mod = 'Typeless';
				comblog.AppendFormat("\c[red]%s\c-", victname);
				if (bINVULNERABLE) comblog.AppendFormat(" is currently \c[purple]invulnerable\c- from", victname);
											else comblog.AppendFormat(" took \c[purple]no damage\c- from", victname);
				if (inflictor && source && (inflictor != source)) comblog.AppendFormat(" \c[purple]%s's", attkernam);
				if (inflictor) comblog.AppendFormat(" \c[red]%s\c-!", atkrname);
				comblog.AppendFormat(" [\c[lightblue]%s\c-]", mod);
				if (dydudebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				
				Console.Printf(comblog);
			}
		}
		initdmg = 0;
		
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up: finaldmg: %d", GetClassName(), ret);
		return ret;
	}
	
	override void PostBeginPlay()
	{
		BossEyeNew actcheck;
		actcheck = BossEyeNew(self);
		if (actcheck)
		{
			if (exex_improvediconofsin) { actcheck.user_bosseyetype = 1; }
			else { actcheck.user_bosseyetype = 0; }
		}
		Actor bsbrn;
		if (BossBrainNew(self))
		{
			bsbrn = self;
			if (dydudebug_bossbraininfo)
			{
				if (bsbrn) Console.Printf("bsbrn: \c[green]%p\c-", bsbrn);
							else Console.Printf("bsbrn: \c[red]NOT FOUND\c-");
			}
			if (exex_improvediconofsin) 
			{
				int foundspawners;
				int foundspawnspots;
				ThinkerIterator SpawnFinder = ThinkerIterator.Create("BossEye");
				Actor mo;
				while (mo = BossEye(SpawnFinder.Next()))
				{
					foundspawners++;
					mo.master = bsbrn;
					if (dydudebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawners);
						if (mo.master) Console.Printf("BossEye (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossEye (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				SpawnFinder = ThinkerIterator.Create("BossTarget");
				while (mo = BossTarget(SpawnFinder.Next()))
				{
					foundspawnspots++;
					if (bsbrn) mo.master = bsbrn;
					if (dydudebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawnspots);
						if (mo.master) Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				if (foundspawners && foundspawnspots)
				{
					double levelhpmultfactor = 0.025;
					double leveldmgmultfactor = 0.001667;
					double dmgfactbase = 0.5;
					if (skill <= 0) 
					{
						health *= 4.00;
						levelhpmultfactor = 0.015;
						leveldmgmultfactor = 0.000500;
						dmgfactbase = 0.7;
					}
					if (skill == 1) 
					{
						health *= 4.50;
						levelhpmultfactor = 0.020;
						leveldmgmultfactor = 0.000667;
						dmgfactbase = 0.65;
					}
					if (skill == 2) 
					{
						health *= 5.00;
						levelhpmultfactor = 0.025;
						leveldmgmultfactor = 0.0008334;
						dmgfactbase = 0.6;
					}
					if (skill == 3)
					{
						health *= 5.50;
						levelhpmultfactor = 0.030;
						leveldmgmultfactor = 0.001000;
						dmgfactbase = 0.55;
					}
					if (skill >= 4)
					{
						health *= 6.00;
						levelhpmultfactor = 0.035;
						leveldmgmultfactor = 0.0011667;
						dmgfactbase = 0.5;
					}
					A_SetInventory("BossBrainHolder",1);
					actor player = players[0].mo;
					let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
					if (MiscItem)
					{
						health *= (1.0 + (MiscItem.PlayerLevel * levelhpmultfactor));
						damagefactor *= (dmgfactbase - (MiscItem.PlayerLevel * leveldmgmultfactor));
						if (dydudebug_bossbraininfo) Console.Printf("Icon of Sin is now stronger!");
					}
				}
			}
		}
		
		//
		if (!(GetRenderStyle() == STYLE_Fuzzy && bSHADOW)) score += 16;
		super.PostBeginPlay();
	}
	
	void A_EEHealThing(int healvalue = 0, int healtarget = 0, int silentheal = 0)
	{
		if (healvalue > 0)
		{
			health += healvalue;
			if (health > healtarget) health = healtarget;
		}
		if (silentheal)
		{
			//if (CountInv("DamageTracker")) A_SetInventory("SilentHeal",1);
		}
	}
}

mixin class EvolveMonsters
{
	action int A_GetEvolveChance()
	{
		int SpawnChance; //, TempSpawnChance, ChanceFactor, LevelCheck, MapCheck;
		return SpawnChance;
	}
}

mixin class IPCostCheck
{
	double A_GetIPCost(int ipid = 0, bool sigiluse = false, double sigilcostbase = 3.00)
	{
		actor player = players[0].mo;
		double cost;
		
		if (ipid == -1)
		{
			cost = 999.9;
		}
		
		if (ipid == 1) // Cherry Bomb [Inventory]
		{
			if (skill <= 0) cost = 25.0;
			if (skill == 1) cost = 27.5;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 32.5;
			if (skill >= 4) cost = 35.0;
		}
		if (ipid == 2) // Bottle Rocket [Inventory]
		{
			if (skill <= 0) cost = 30.0;
			if (skill == 1) cost = 33.75;
			if (skill == 2) cost = 37.5;
			if (skill == 3) cost = 41.25;
			if (skill >= 4) cost = 45.0;
		}
		if (ipid == 3) // Sugar Snake [Inventory]
		{
			if (skill <= 0) cost = 40.0;
			if (skill == 1) cost = 45.0;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 55.0;
			if (skill >= 4) cost = 60.0;
		}
		if (ipid == 4) // Spinner Chaser [Inventory]
		{
			if (skill <= 0) cost = 40.0;
			if (skill == 1) cost = 45.0;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 55.0;
			if (skill >= 4) cost = 60.0;
		}
		if (ipid == 5) // Killetante Effigy [Inventory]
		{
			if (skill <= 0) cost = 64.0;
			if (skill == 1) cost = 72.0;
			if (skill == 2) cost = 80.0;
			if (skill == 3) cost = 88.0;
			if (skill >= 4) cost = 96.0;
		}
		if (ipid == 6) // Scatter Popper [Inventory]
		{
			if (skill <= 0) cost = 27.0;
			if (skill == 1) cost = 28.5;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 31.5;
			if (skill >= 4) cost = 33.0;
		}
		if (ipid == 7) // Essence of Fury [Inventory]
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
		}
		if (ipid == 8) // Essence of Time [Inventory]
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
			cost *= 1.5;
		}
		if (ipid == 9) // Apple Wine [Inventory]
		{
			if (skill <= 0) cost = 17.5;
			if (skill == 1) cost = 18.75;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 21.25;
			if (skill >= 4) cost = 22.5;
		}
		if (ipid == 10) // Turkey Dinner [Inventory]
		{
			if (skill <= 0) cost = 17.5;
			if (skill == 1) cost = 18.75;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 21.25;
			if (skill >= 4) cost = 22.5;
			cost *= 1.75;
		}
		if (ipid == 11) // Door Bell [Inventory]
		{
		}
		
		if (ipid == 101) // Cricket Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
		}
		if (ipid == 102) // Cricket Bat Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
		}
		if (ipid == 103) // Cricket Bat Spinning Attack [Weapon]
		{
			if (skill <= 0) cost = 33.75;
			if (skill == 1) cost = 39.375;
			if (skill == 2) cost = 45.0;
			if (skill == 3) cost = 50.625;
			if (skill >= 4) cost = 56.25;
		}
		
		if (ipid == 111) // Blunderaxe Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
		}
		if (ipid == 112) // Blunderaxe Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
		}
		
		if (ipid == 121) // Scrambler Main Attack [Weapon]
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5; // 2.4
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
		}
		if (ipid == 122) // Scrambler Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 22.5;
			if (skill == 1) cost = 26.25;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 33.75;
			if (skill >= 4) cost = 37.5;
		}
		
		if (ipid == 131) // AppleJack Melee Attack [Weapon]
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
		}
		if (ipid == 132) // AppleJack Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 15.0;
			if (skill == 1) cost = 17.5;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 22.5;
			if (skill >= 4) cost = 25.0;
		}
		
		if (ipid == 141) // WizardPike Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
			cost *= 1.25;
		}
		if (ipid == 142) // WizardPike Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 78.75;
			if (skill == 2) cost = 90.0;
			if (skill == 3) cost = 101.25;
			if (skill >= 4) cost = 112.5;
		}
		
		if (ipid == 151) // SuperVac Main Attack [Weapon]
		{
			if (skill <= 0) cost = 0.75;
			if (skill == 1) cost = 0.875;
			if (skill == 2) cost = 1.0;
			if (skill == 3) cost = 1.125;
			if (skill >= 4) cost = 1.25;
			cost *= 2;
		}
		if (ipid == 152) // SuperVac Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 71.25;
			if (skill == 2) cost = 75.0;
			if (skill == 3) cost = 78.75;
			if (skill >= 4) cost = 82.5;
		}
		
		if (ipid == 161) // Grimophone Main Attack [Weapon]
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
		}
		if (ipid == 162) // Grimophone Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 0.5625;
			if (skill == 1) cost = 0.65625;
			if (skill == 2) cost = 0.75;
			if (skill == 3) cost = 0.84375;
			if (skill >= 4) cost = 0.9375;
		}
		
		if (ipid == 171) // CandleWhip Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 8.4375;
			if (skill == 1) cost = 9.84375;
			if (skill == 2) cost = 11.25;
			if (skill == 3) cost = 12.65625;
			if (skill >= 4) cost = 14.0625;
		}
		if (ipid == 172) // CandleWhip Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 2.8125;
			if (skill == 1) cost = 3.28125;
			if (skill == 2) cost = 3.75;
			if (skill == 3) cost = 4.21875;
			if (skill >= 4) cost = 4.6875;
		}
		
		if (ipid == 181 && sigiluse) // ???
		{
			if (skill <= 0) cost = (sigilcostbase * 1.35);
			if (skill == 1) cost = (sigilcostbase * 1.425);
			if (skill == 2) cost = (sigilcostbase * 1.50);
			if (skill == 3) cost = (sigilcostbase * 1.575);
			if (skill >= 4) cost = (sigilcostbase * 1.65);
		}
		
		if (ipid == 191) // ???
		{
		}
		
		if (ipid == 1001) // Knight Gown
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
		}
		if (ipid == 1002) // Expert's Knight Gown
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 71.25;
			if (skill == 2) cost = 75.0;
			if (skill == 3) cost = 78.75;
			if (skill >= 4) cost = 82.5;
		}
		if (ipid == 1003) // Master's Knight Gown
		{
			if (skill <= 0) cost = 78.75;
			if (skill == 1) cost = 83.125;
			if (skill == 2) cost = 87.5;
			if (skill == 3) cost = 91.875;
			if (skill >= 4) cost = 96.25;
		}
		if (ipid == 1004) // Ultimate Knight Gown
		{
			if (skill <= 0) cost = 84.375;
			if (skill == 1) cost = 89.0625;
			if (skill == 2) cost = 93.75;
			if (skill == 3) cost = 98.4375;
			if (skill >= 4) cost = 103.125;
		}
		
		if (player) 
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem) 
			{
				if (MiscItem.TimeFreezeTimer && MiscItem.TimeFreezeIPBuff)
				{
					if (ipid == 8) cost = ceil(cost * 2.0);
										else cost = floor(cost * 0.5);
				}

				if (cost > MiscItem.MaxItemPoints) cost = MiscItem.MaxItemPoints;
			}
		}
		
		// Double Sphere reduces IP Cost by 25%
		if (player && player.CountInv("PowerDouble") && ipid != -1) cost = floor(cost * 0.875);
		
		// "Mystery Item" reduces IP Cost by 33.3%
		if (player && player.CountInv("MysteryItem") && ipid != -1) cost = floor(cost * 0.667);
		
		// Armor IPs Reduce Costs for Non-Armor IP Abilities
		if (ipid != -1)
		{
			if (!(ipid >= 1000 && ipid <= 1004))
			{
				if (player && player.CountInv("KnightGownIP1Buff")) cost = floor(cost * 0.8);
				if (player && player.CountInv("KnightGownIP2Buff")) cost = floor(cost * 0.6);
				if (player && player.CountInv("KnightGownIP3Buff")) cost = floor(cost * 0.4);
				if (player && player.CountInv("KnightGownIP4Buff")) cost = floor(cost * 0.2);
			}
			else
			{
				if (player && !player.CountInv("MysteryItem"))
				{
					if (player && player.CountInv("KnightGownIP1Buff")) cost = ceil(cost * 1.075);
					if (player && player.CountInv("KnightGownIP2Buff")) cost = ceil(cost * 1.15);
					if (player && player.CountInv("KnightGownIP3Buff")) cost = ceil(cost * 1.225);
					if (player && player.CountInv("KnightGownIP4Buff")) cost = ceil(cost * 1.30);
				}
			}
		}
		
		if (player) 
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				if (ipid != -1 || !(ipid >= 1000 && ipid <= 1004))
				{
					if (ipid == 8)
					{
						if (MiscItem.IPMortalBlowReduceTimer)
						{
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 2) - 1)) cost = ceil(cost * 0.8334);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 2) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 3) - 1)) cost = ceil(cost * 0.75);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 3) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 4) - 1)) cost = ceil(cost * 0.666);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 4) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 5) - 1)) cost = ceil(cost * 0.583);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 5)) cost = 0.5;
						}
					}
					else
					{
						if (MiscItem.IPMortalBlowReduceTimer)
						{
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 2) - 1)) cost = ceil(cost * 0.666);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 2) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 3) - 1)) cost = ceil(cost * 0.5);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 3) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 4) - 1)) cost = ceil(cost * 0.333);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 4) && MiscItem.PlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 5) - 1)) cost = ceil(cost * 0.166);
							if (MiscItem.PlayerLevel >= (exex_mortalblowipcostlvlrequirement * 5)) cost = 0;
						}
					}
				}
			}
		}

		if (ipid == -1)
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem) 
			{
				cost *= (1.0 - ((MiscItem.PlayerLevel - 1) * 0.001));
			}
		}
		
		// If Infinite IP Cheat is on, nullify any above cost calculations and set to 0. :V
		if (dydudebug_infiniteip) cost = 0.0;
		
		if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [%d]: %.4f, Skill: %d", ipid, cost, skill);
		return cost;
	}
	
	play void A_IPDinahVoiceSelect(int IPType = 0, int basechance = 3, int maxroll = 10)
	{
		actor player = players[0].mo;
		int voiceroll = random(1,6);
		string voiceplay;
		if (player && player.GetClassName() == "DinahPlayer" && exex_dinahextravoices)
		{
			if (random(1,maxroll) <= basechance)
			{
				if (IPType == 0) // Default
				{
					voiceroll = random(1,6);
					if (voiceroll == 1) 
					{
						voiceplay = "dinah/ulikethis";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'YOU LIKE THIS!?'\c-");
					}
					if (voiceroll == 2) 
					{
						voiceplay = "dinah/howsthis";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'HOW'S... THIS!?'\c-");
					}
					if (voiceroll == 3) 
					{
						voiceplay = "dinah/playtimeisover";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'PLAYTIME IS OVER!!'\c-");
					}
					if (voiceroll == 4) 
					{
						voiceplay = "dinah/thiswillendit";
						Console.Printf("\c[gold]'This will end it!!'\c-");
					}
					if (voiceroll == 5) 
					{
						voiceplay = "dinah/thiswillhurt";
						Console.Printf("\c[gold]'This will hurt!!'\c-");
					}
					if (voiceroll == 6) 
					{
						voiceplay = "dinah/yourmine";
						Console.Printf("\c[gold]'You're Mine!!'\c-");
					}
				}
				else
				if (IPType == 1) // Support Item Use
				{
					voiceroll = random(1,3);
					if (voiceroll == 1) 
					{
						voiceplay = "dinah/playtimeisover";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'PLAYTIME IS OVER!!'\c-");
					}
					if (voiceroll == 2) 
					{
						voiceplay = "Dinah/marvelous";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'Marvellous!'\c-");
					}
					if (voiceroll == 3) 
					{
						voiceplay = "Dinah/AllowMe";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'Allow Me!'\c-");
					}
				}
				player.A_StopSound(CHAN_VOICE);
				player.A_StartSound(voiceplay,CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM);
			}
		}
	}
	
	play void A_CheckIPModeOnUse()
	{
		actor player = players[0].mo;
		if (exex_ikaripointtechpresstype >= 2 && player && player.CountInv("IPUseMode")) player.A_SetInventory("IPUseMode",0);
	}
}

mixin class InvWeaponShare
{
	//===========================================================================
	//
	// A_ThrowGrenadeAngle
	//
	// Throws a grenade (like Hexen's fighter flechette) with the added options to tweak
	// the randomized angle-range used, and if to use fixed/doubles or ints for the angles.
	//
	//===========================================================================
	action bool, Actor A_ThrowGrenadeAngle(class<Actor> missile, double zheight = 0, double zheightoffset = 35, double xyvel = 0, double zvel = 0, double angularspreadmin = -4.0, double angularspreadmax = 3.0, bool usefixedangles = false, bool useammo = true, bool checkspawn = true)
	{
		if (dydudebug_attackstuff) Console.Printf("zheight: %.4f, xyvel: %.4f, zvel: %.4f, angularspreadmin: %.4f, angularspreadmax: %.4f", zheight, xyvel, zvel, angularspreadmin, angularspreadmax);
		double anglemin = angularspreadmin;
		double anglemax = angularspreadmax;
		if (!usefixedangles)
		{
			anglemin = int(angularspreadmin); 
			anglemax = int(angularspreadmax);
		}
		else
		{
			anglemin = angularspreadmin; 
			anglemax = angularspreadmax;
		}
		if (dydudebug_attackstuff) Console.Printf("anglemin: %.4f, anglemax: %.4f", anglemin, anglemax);

		if (missile == NULL)
		{
			return false, null;
		}
		if (stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			let player = self.player;
			if (player == null) return false, null;
			let weapon = player.ReadyWeapon;
			// Used from a weapon, so use some ammo

			if (weapon == NULL || (useammo && !weapon.DepleteAmmo(weapon.bAltFire)))
			{
				return true, null;
			}
		}

		let bo = Spawn(missile, pos + (0, 0, (-Floorclip + GetBobOffset() + zheight + zheightoffset + (player? player.crouchoffset : 0.))), ALLOW_REPLACE);
		if (bo)
		{
			if (dydudebug_attackfuncinfo) Console.Printf("bo [spawned]");
			self.PlaySpawnSound(bo);
			if (xyvel != 0)
				bo.Speed = xyvel;
			if (usefixedangles) bo.Angle = Angle + (frandom[grenade](anglemin, anglemax) * (360./256.));
										 else bo.Angle = Angle + (random[grenade](anglemin, anglemax) * (360./256.));

			let pitch = -self.Pitch;
			let angle = bo.Angle;

			// There are two vectors we are concerned about here: xy and z. We rotate
			// them separately according to the shooter's pitch and then sum them to
			// get the final velocity vector to shoot with.

			double xy_xyscale = bo.Speed * cos(pitch);
			double xy_velz = bo.Speed * sin(pitch);
			double xy_velx = xy_xyscale * cos(angle);
			double xy_vely = xy_xyscale * sin(angle);

			pitch = self.Pitch;
			double z_xyscale = zvel * sin(pitch);
			double z_velz = zvel * cos(pitch);
			double z_velx = z_xyscale * cos(angle);
			double z_vely = z_xyscale * sin(angle);

			bo.Vel.X = xy_velx + z_velx + Vel.X / 2;
			bo.Vel.Y = xy_vely + z_vely + Vel.Y / 2;
			bo.Vel.Z = xy_velz + z_velz;

			bo.target = self;
			if (checkspawn) 
			{
				if (dydudebug_attackfuncinfo) Console.Printf("bo: checkspawn: %d", checkspawn);
				if (!bo.CheckMissileSpawn(radius))
				{
					if (dydudebug_attackfuncinfo) Console.Printf("bo: null");
					bo = null;
				}
			}
			return true, bo;
		} 
		else
		{
			return false, null;
		}
	}
}

/*
	Enum ESpawnItemExtendedFlags
	{
		SXF_ABSOLUTEPITCH = 1 << 29,
		SXF_ABSOLUTEROLL = 1 << 30,
		SXF_VELOCITYFROMPITCH = 1 << 31,
		SXF_OFFSETFROMPITCH = 1 << 32,
	};

	Bool, Actor A_SpawnItemExtended(Class<Actor> Actr, Double OffsetX = 0.0, Double OffsetY = 0.0, Double OffsetZ = 0.0, Double VelX = 0.0, Double VelY = 0.0, Double VelZ = 0.0, Double Angle = 0.0, Double Pitch = 0.0, Double Roll = 0.0, Int Flags = 0, Int Flags2 = 0, Int FailChance = 0, Int TID = 0)
	{
		Bool Result;
		Actor MapObject;
		Double CallerAngle;
		Double CallerPitch;
		Double CallerRoll;
		Double CallerPosZ;
		Double CallerVelZ;
		Vector3 Position;
		Double TSin;
		Double TCos;
		Double NewVelX;
	
		If (!Actr)
		{
			Return False, Null;
		}
	
		If (FailChance > 0 && Random[SpawnItemEx]() < FailChance)
		{
			Return True, Null;
		}
	
		If (DamageType == 'Massacre' && GetDefaultByType(Actr).bISMONSTER)
		{
			Return True, Null;
		}
	
		CallerAngle = Self.Angle;
		CallerPitch = Self.Pitch;
		CallerRoll = Self.Roll;
		CallerPosZ = Self.Pos.Z;
		CallerVelZ = Self.Vel.Z;
	
		If (Flags2 & SXF_OFFSETSFROMPITCH)
		{
			Vector3 BaseDirection;
			Double BaseAngle;
			Double BasePitch;
			Vector3 Right;
			Vector3 Up;
			Vector2 OffsetXZ;
			Vector3 Offset;
			
			BaseDirection = (Cos(CallerPitch) * Cos(CallerAngle),Cos(CallerPitch) * Sin(CallerAngle),-Sin(CallerPitch));
			Right = (Cos(CallerAngle - 90.0),Sin(CallerAngle - 90.0),0.0);
			Up = (Cos(CallerPitch - 90.0) * Cos(CallerAngle),Cos(CallerPitch - 90.0) * Sin(CallerAngle),-Sin(CallerPitch - 90.0));
			
			BaseDirection += Sin(Angle) * Right;
			BaseDirection += Sin(-Pitch) * Up;
			
			BaseAngle = VectorAngle(BaseDirection.X,BaseDirection.Y);
			BaseDirection.XY = RotateVector(BaseDirection.XY,-BaseAngle);
			BasePitch = -VectorAngle(BaseDirection.X,BaseDirection.Z);
			
			OffsetY *= -1;
			OffsetXZ = RotateVector((OffsetX,OffsetZ),-BasePitch);
			OffsetX = OffsetXZ.X;
			OffsetZ = OffsetXZ.Y;
			Offset = (OffsetX,OffsetY,OffsetZ);
			Offset.XY = RotateVector(Offset.XY,BaseAngle);
			
			If (Flags & SXF_ABSOLUTEPOSITION)
			{
				Position.XY = Vec2Offset(Offset.X,Offset.Y,False);
			}
			Else
			{
				Position.XY = (Self.Pos.X + Offset.X,Self.Pos.Y + Offset.Y);
			}
			
			Position.Z = CallerPosZ - FloorClip + GetBobOffset(0.0) + Offset.Z;
		}
		Else
		{
			If (!(Flags & SXF_ABSOLUTEANGLE))
			{
				Angle += CallerAngle;
			}
			
			TSin = Sin(Angle);
			TCos = Cos(Angle);
			
			If (Flags & SXF_ABSOLUTEPOSITION)
			{
				Position.XY = Vec2Offset(OffsetX,OffsetY,False);
			}
			Else
			{
				Position.XY = Vec2Offset(OffsetX * TCos + OffsetY * TSin,OffsetX * TSin - OffsetY * TCos,False);
			}
			
			Position.Z = CallerPosZ - FloorClip + GetBobOffset(0.0) + OffsetZ;
		}
	
		MapObject = Spawn(Actr,Position,ALLOW_REPLACE);
		Result = InitSpawnedItem(MapObject,Flags);
	
		If (Result)
		{
			If (Flags2 & SXF_OFFSETSFROMPITCH)
			{
				If (!(Flags & SXF_ABSOLUTEANGLE))
				{
						Angle += CallerAngle;
				}
			
				TSin = Sin(Angle);
				TCos = Cos(Angle);
			}
			
			If (!(Flags2 & SXF_ABSOLUTEPITCH))
			{
				Pitch = Clamp(Pitch + CallerPitch,-90.0,90.0);
			}
			
			If (!(Flags2 & SXF_ABSOLUTEROLL))
			{
				Roll += CallerRoll;
			}
			
			If (!(Flags & SXF_ABSOLUTEVELOCITY))
			{
				NewVelX = VelX * TCos + VelY * TSin;
				VelY = VelX * TSin - VelY * TCos;
				VelX = NewVelX;
			
				If (Flags2 & SXF_ADDZVELOCITY)
				{
							VelZ += CallerVelZ;
				}
			}
			
			MapObject.Angle = Angle;
			MapObject.Pitch = Pitch;
			MapObject.Roll = Roll;
			MapObject.Vel = (VelX,VelY,VelZ);
			
			If (Flags2 & SXF_VELOCITYFROMPITCH)
			{
				If (Flags2 & SXF_ADDZVELOCITY)
				{
						MapObject.Vel3DFromAngle(MapObject.Vel.XY.Length(),VectorAngle(VelX,VelY),MapObject.Pitch);
						MapObject.Vel.Z += VelZ;
				}
				Else
				{
							MapObject.Vel3DFromAngle(MapObject.Vel.Length(),VectorAngle(VelX,VelY),VectorAngle(MapObject.Vel.XY.Length(),VelZ) + Pitch);
				}
			}
			
			If (Flags & SXF_MULTIPLYSPEED)
			{
				MapObject.Vel *= MapObject.Speed;
			}
			
			If (Flags2 & SXF_PITCHFROMMOMENTUM)
			{
				MapObject.A_FaceMovementDirection(0.0,0.0,270.0,FMDF_NOANGLE,AAPTR_DEFAULT);
			}
			
			If (TID != 0)
			{
				MapObject.ChangeTID(TID);
			}
		}
	
		Return Result, MapObject;
	}
*/