mixin class StunItems
{
	bool dideffect;
	
	action bool A_CheckDDGameA()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	action int A_GetPlayerLvl(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGameA()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - StunItems mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void A_StunInduce(int basestun = 5, double lvlfactor = 0.0667, bool checkberserk = true, double bersmult = 1.5, bool destroyitem = false, bool martialarts = false)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl(1);
		bool surprised;
		if (!dideffect)
		{
			if (owner)
			{
				if (PuddingDog(owner) || PuddingPup(owner)) 
				{
					// Pudding Creatures CANNOT be stunned and in fact SPEED up the first pain frame to 0 tics
					owner.A_SetTics(0);
					basestun = 0;
					if (dydudebug_punchkickstundisplays) Console.Printf("[Pudding(Dog/Pup)] basestun: %d", basestun);
				}
				else
				{
					if (owner.bBOSS)
					{
						bool reducestun = false;
						if (TruePlayerLevel <= 60 && random(1,16) <= 1) reducestun = true;
						else if (TruePlayerLevel <= random(37,38) && random(1,16) <= 5) reducestun = true;
						else if (TruePlayerLevel <= 15 && random(1,16) <= 9) reducestun = true;
						
						if (player.CountInv("MAManual") && martialarts && reducestun && random(1,3) <= 1) reducestun = false;
						if (reducestun) 
						{
							if (DDOrigBoss(owner))
							{
								if (TruePlayerLevel <= 60) basestun *= frandompick(0.2,0.25,0.25,0.25,0.2857);
								else if (TruePlayerLevel <= 30) basestun *= frandompick(0.1,0.125,0.125,0.125,0.1428);
							}
							else
							{
								if (TruePlayerLevel <= 60) basestun *= frandompick(0.334,0.5,0.5,0.5,0.667);
								else if (TruePlayerLevel <= 30) basestun *= frandompick(0.167,0.25,0.25,0.25,0.334);
							}
							if (dydudebug_punchkickstundisplays) Console.Printf("[Boss Reduce Stun] basestun: %d ", basestun);
						}
					}
					else
					{
						bool reducestun = false;
						if (TruePlayerLevel <= 60 && random(1,32) <= 1) reducestun = true;
						else if (TruePlayerLevel <= random(37,38) && random(1,32) <= 5) reducestun = true;
						else if (TruePlayerLevel <= 15 && random(1,32) <= 9) reducestun = true;
						
						if (player.CountInv("MAManual") && martialarts && reducestun && random(1,3) <= 2) reducestun = false;
						if (reducestun) 
						{
							if (EvilDinah(owner) || EvilDinahEE(owner))
							{
								if (TruePlayerLevel <= 60) basestun *= frandompick(0.2,0.25,0.25,0.25,0.2857);
								else if (TruePlayerLevel <= 30) basestun *= frandompick(0.1,0.125,0.125,0.125,0.1428);
							}
							else
							{
								if (TruePlayerLevel <= 60) basestun *= frandompick(0.5,0.75,0.75,0.75,1.0);
								else if (TruePlayerLevel <= 30) basestun *= frandompick(0.25,0.375,0.375,0.375,0.5);
							}
							if (dydudebug_punchkickstundisplays) Console.Printf("[Monster Reduce Stun] basestun: %d ", basestun);
						}
					}
					
					basestun += (TruePlayerLevel * lvlfactor);
					if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) basestun *= bersmult;
					if (skill <= 0) basestun *= frandom(1.25,1.375);
					if (skill == 1) basestun *= frandom(1.125,1.25);
					if (skill == 2) basestun *= frandom(0.975,1.025);
					if (skill == 3) basestun *= frandom(0.75,0.875);
					if (skill >= 4) basestun *= frandom(0.625,0.75);
					if (A_CheckDDGameA()) 
					{
						basestun *= 0.5;
						basestun *= exex_nrpggeneraleffect;
					}
					if (Knucklehead(owner)) basestun *= frandompick(2,2.5,3.25,4.125,5); // Knuckleheads will be stunned much longer
					if (player.CountInv("MAManual") && martialarts) basestun *= frandompick(1.75,2.125,2.125,2.5,2.5,2.5,2.5,2.875,2.875,3.25);
					if (player.CountInv("ClassyRibbon")) basestun *= 1.3;
					if (player.CountInv("ExpeditionHat")) basestun *= (1.0 / 1.15);
					if (basestun < 1) basestun = 1;
					int tic = owner.tics + basestun;
					if (dydudebug_punchkickstundisplays) Console.Printf("stun tics [%s]: \c[gold]%d\c- (old: %d, basestun: %d)", GetClassName(), tic, owner.tics, basestun);
					owner.A_SetTics(tic);
				}
				dideffect = true;
			}
		}
	}
	
	bool A_PainStateChecker()
	{
		bool isit = false;
		if (
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bonk")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Breakfast")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Zap")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Cricket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lead")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Bop")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Beats")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dust")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.CherryBomb")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.BRocket")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Spinner")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Popper")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dashing")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Boiling")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Tank")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Suck")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Musak")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.DoomSpell")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Magic")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Holy")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Dark")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Eldritch")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fire")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Ice")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Plasma")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Thunder")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Electric")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Lightning")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Shock")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Sceptre")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Fist")) || 
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Kick")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.PoisonNeedle")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Deadlight")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Chainsaw")) ||
			owner.InStateSequence(owner.curstate,owner.ResolveState("Pain.Gauntlets"))
			 )
			isit = true;
			
		return isit;
	}
}

mixin class HUDRecovery
{
	void A_IPUseHUD(double cost)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		if (MiscItem)
		{
			MiscItem.IPLossHUDAmt += cost;
			if (MiscItem.IPLossHUDTimer <= 0) MiscItem.IPLossHUDTimer = 105;
			else
			{
				MiscItem.IPLossHUDTimer += 35;
				if (MiscItem.IPLossHUDTimer < 105 && cost > (MiscItem.MaxItemPoints * 0.01)) MiscItem.IPLossHUDTimer = 105;
				if (MiscItem.IPLossHUDTimer > 175) MiscItem.IPLossHUDTimer = 175;
			}
		}
	}

	void A_StatIncHud(int recovery, int type)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_MaxHPHud [MiscItem]");
			if (type == 0) // Max HP
			{
				if (MiscItem.MaxHPIncTimer <= 0) MiscItem.MaxHPIncTimer = 105;
				else
				{
					MiscItem.MaxHPIncTimer += 35;
					if (MiscItem.MaxHPIncTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.MaxHPIncTimer > 175) MiscItem.MaxHPIncTimer = 175;
				}
				MiscItem.MaxHPIncAmt += recovery;
				if (dydudebug_hudrecdmgdisplays) Console.Printf("Max HP Gain: %d [%d] (timer: %d)", MiscItem.MaxHPIncAmt, recovery, MiscItem.MaxHPIncTimer);
			}
			
			if (type == 1) // Dash Length
			{
				if (MiscItem.MaxDashIncTimer <= 0) MiscItem.MaxDashIncTimer = 105;
				else
				{
					MiscItem.MaxDashIncTimer += 35;
					if (MiscItem.MaxDashIncTimer > 175) MiscItem.MaxDashIncTimer = 175;
				}
				MiscItem.MaxDashIncAmt += recovery;
				if (dydudebug_hudrecdmgdisplays) Console.Printf("Max Dash Gain: %d [%d] (timer: %d)", MiscItem.MaxDashIncAmt, recovery, MiscItem.MaxDashIncTimer);
			}
		}
	}
	
	bool CheckIPEnabled()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();

		if (exex_ikaripointsenabled) return true;
		else
		{
			if (player.CountInv("IsDynDuchess") || 
					player.CountInv("IsAppetite") || 
					player.CountInv("IsCarnOfSouls") || 
					player.CountInv("IsWeddingCake"))
			{
				if (MiscItem && MiscItem.TotalNRPGLvlPts >= exex_nrpglevelipgained) return true;
				else return false;
			}
		}
		return false;
	}
	
	void A_AddIP(double base, double basef, bool acculmuatepulse, bool addtohud, int gaintype)
	{
		//Console.Printf("A_AddIP [mixin]");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		let globalvars = DDGlobalVariables.Get();
		int TruePlayerLevel = 0;
		if (exex_expenabled && MiscItem) TruePlayerLevel = MiscItem.PlayerLevel;
		int IPTimerBaseInc = -35;
		
		double sts = 1.0;
		if (MiscItem && MiscItem.sttabs > 0) sts = 1.0 + (MiscItem.sttabs * 0.083334);
		if (sts >= 1.50) sts = 1.50;
		base *= sts;
		basef *= sts;
		
		double ssa = 1.0;
		if (player.CountInv("ClassyRibbon")) ssa += 0.25;
		if (player.CountInv("ExpeditionHat")) ssa -= 0.125;
		base *= ssa;
		basef *= ssa;
		
		double bsa = 1.0;
		if (player.CountInv("PowerWineBuffWeak")) bsa -= 0.05;
		if (player.CountInv("PowerWineBuffIPWeak")) bsa -= 0.01667;
		if (player.CountInv("PowerWineBuffStrong")) bsa -= 0.0875;
		if (player.CountInv("PowerWineBuffIPStrong")) bsa -= 0.0291666666666667;
		if (player.CountInv("PowerWineBuffStrongest")) bsa -= 0.1375;
		if (player.CountInv("PowerWineBuffIPStrongest")) bsa -= 0.0458333333333333;
		if (player.CountInv("PowerWineBuffStrongestEven")) bsa -= 0.2;
		if (player.CountInv("PowerWineBuffIPStrongestEven")) bsa -= 0.0667;
		if (player.CountInv("PowerWineBuffIPMaximum")) bsa -= 0.275;
		
		if (MiscItem && (player.CountInv("PowerEggBuff") || player.CountInv("PowerEggBuff2"))) bsa += (0.10 + (MiscItem.UsedEggHeal * 0.001));
		if (player.CountInv("PowerFruitBuff") || player.CountInv("PowerFruitBuff2")) bsa += 0.05;
		if (player.CountInv("PowerRoastBuff")) bsa += 0.10;
		if (player.CountInv("PowerMealBuff") || player.CountInv("PowerMealBuff2")) bsa += 0.20;
		if (player.CountInv("PowerMeal2Buff") || player.CountInv("PowerMeal2Buff2")) bsa += 0.20;
		if (player.CountInv("PowerHaste")) bsa *= 1.5;
		if (player.CountInv("PowerSlow")) bsa *= 0.6667;
		
		base *= bsa;
		basef *= bsa;
		
		base *= (1.0 + (TruePlayerLevel * 0.0025));
		if (base <= 0.01) base = 0.01;
		if (basef <= 0.01) basef = 0.01;

		if (MiscItem && MiscItem.KillComboCount)
		{
			int tallyextra = MiscItem.KillComboCount;
			if (tallyextra > 10 && tallyextra < 21) 
			{
				if (gaintype <= 0) // from damage
				{
					base *= 1.005;
					basef *= 1.00125;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.00125;
					basef *= 1.0003125;
				}
			}
			if (tallyextra > 20 && tallyextra < 36) 
			{
				if (gaintype <= 0) // from damage
				{
					base *= 1.02;
					basef *= 1.005;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.005;
					basef *= 1.00125;
				}
			}
			if (tallyextra > 35 && tallyextra < 61)
			{
				if (gaintype <= 0) // from damage
				{
					base *= 1.08;
					basef *= 1.02;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.02;
					basef *= 1.005;
				}
			}
			if (tallyextra > 60 && tallyextra < 101)
			{
				if (gaintype <= 0) // from damage
				{
					base *= 1.32;
					basef *= 1.08;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.08;
					basef *= 1.02;
				}
			}
			if (tallyextra > 100 && tallyextra < 201)
			{
				if (gaintype <= 0) // from damage
				{
					base *= 2.28;
					basef *= 1.32;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.32;
					basef *= 1.08;
				}
			}
			if (tallyextra > 200 && tallyextra < 501)
			{
				if (gaintype <= 0) // from damage
				{
					base *= 3.56;
					basef *= 1.64;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 1.64;
					basef *= 1.32;
				}
			}
			if (tallyextra > 500)
			{
				if (gaintype <= 0) // from damage
				{
					base *= 6.12;
					basef *= 2.28;
				}
				else
				if (gaintype <= 1) // from Cup of Rage type
				{
					base *= 2.28;
					basef *= 1.64;
				}
			}
		}

		
		if (player.CountInv("AngerLevelEvent") || player.CountInv("AngerLevelEventN")) base *= (1.0 + (player.CountInv("AngerLevelEvent") * 0.0005) + (player.CountInv("AngerLevelEventN") * 0.00005));
		
		if (base)
		{
			if (MiscItem.IPDissipateTimer > 0) MiscItem.IPDissipateTimer = (IPTimerBaseInc * basef);
																		else MiscItem.IPDissipateTimer += (IPTimerBaseInc * basef);
			double oldItemPoints = MiscItem.ItemPoints;
			MiscItem.ItemPoints += base;
			if (MiscItem.ItemPoints > MiscItem.MaxItemPoints) MiscItem.ItemPoints = MiscItem.MaxItemPoints;
			if (MiscItem.ItemPoints >= oldItemPoints) 
			{
				base = (MiscItem.ItemPoints - oldItemPoints);
				if (dydudebug_ipdisplays2) Console.Printf("\c[red]A_AddIP (base): %.8f (ItemPoints: %.8f, oldItemPoints: %.8f)", base, oldItemPoints, MiscItem.ItemPoints);
			}
			globalvars.ItemPoints = MiscItem.ItemPoints;
			
			if (base > 0)
			{
				if (addtohud)
				{
					MiscItem.IPGainHUDAmt += base;
					if (MiscItem.IPGainHUDTimer <= 0) MiscItem.IPGainHUDTimer = 105;
					else
					{
						MiscItem.IPGainHUDTimer += 35;
						if (MiscItem.IPGainHUDTimer < 105 && base > (MiscItem.MaxItemPoints * 0.005)) MiscItem.IPGainHUDTimer = 105;
						if (MiscItem.IPGainHUDTimer > 175) MiscItem.IPGainHUDTimer = 175;
					}
				}
				
				if (MiscItem.IPHUDPulseTimer <= 0) MiscItem.IPHUDPulseTimer = 105;
				else
				{
					MiscItem.IPHUDPulseTimer += 35;
					if (MiscItem.IPHUDPulseTimer < 105 && base > (MiscItem.MaxItemPoints * 0.10)) MiscItem.IPHUDPulseTimer = 105;
					if (MiscItem.IPHUDPulseTimer > 175) MiscItem.IPHUDPulseTimer = 175;
				}
			}
			
			if (acculmuatepulse && base > 0 && (MiscItem.ItemPointsSession < MiscItem.MaxItemPoints))
			{
				MiscItem.ItemPointsSession += base;
				if (MiscItem.ItemPointsSession >= MiscItem.MaxItemPoints) MiscItem.ItemPointsSession == MiscItem.MaxItemPoints;
				if (MiscItem.ItemPointsSession > 0 && base > 0)
				{
					int healfactor = MiscItem.ItemPointsSession * 100 / MiscItem.MaxItemPoints;
					if (healfactor < 10) MiscItem.IPHUDPulseType = 1;
					if (healfactor >= 10) MiscItem.IPHUDPulseType = 2;
					if (healfactor >= 50) MiscItem.IPHUDPulseType = 3;
					if (healfactor >= 100) MiscItem.IPHUDPulseType = 4;
					MiscItem.IPHUDPulseTimeP = (level.time % randompick(10,15,20));
				}
			}
			
			if (exex_playerdmglog && CheckIPEnabled() && base) Console.Printf("\c[red]+%.2f%% IP Gained!", base);
		}
	}
	
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					if (player.CountInv("KnightGownItem")) armmax = MiscItem.ArmorItemMax1;
					if (player.CountInv("KnightGownItem2")) armmax = MiscItem.ArmorItemMax2;
					if (player.CountInv("KnightGownItem3")) armmax = MiscItem.ArmorItemMax3;
					if (player.CountInv("KnightGownItem4")) armmax = MiscItem.ArmorItemMax4;
					if (armmax)
					{
						if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.APHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
							MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
		}
	}

	void A_LossHUD(int loss, int type, bool acculmuateshake)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_LossHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_LossHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Loss [HUD]
				if (MiscItem.HPDmgHUDTimer <= 0) MiscItem.HPDmgHUDTimer = 105;
				else
				{
					MiscItem.HPDmgHUDTimer += 35;
					if (MiscItem.HPDmgHUDTimer < 105 && loss > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPDmgHUDTimer = 105;
					if (MiscItem.HPDmgHUDTimer > 175) MiscItem.HPDmgHUDTimer = 175;
				}
				MiscItem.HPDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (dydudebug_hudrecdmgdisplays) Console.Printf("HP loss: %d", loss);
					if (MiscItem.HPDmgHUDAmt > 0 && loss > 0)
					{
						MiscItem.HPHUDShakeTime += random(52,53);
						int damagetakefactor = MiscItem.HPDmgHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (damagetakefactor < 10)
						{
							MiscItem.HPHUDShakeType = 1;
							if (MiscItem.HPHUDShakeTime > 53) MiscItem.HPHUDShakeTime = 53;
						}
						if (damagetakefactor >= 10) 
						{
							MiscItem.HPHUDShakeType = 2;
							if (MiscItem.HPHUDShakeTime > 88) MiscItem.HPHUDShakeTime = 88;
						}
						if (damagetakefactor >= 50) 
						{
							MiscItem.HPHUDShakeType = 3;
							if (MiscItem.HPHUDShakeTime > 140) MiscItem.HPHUDShakeTime = 140;
						}
						if (damagetakefactor >= 100) 
						{
							MiscItem.HPHUDShakeType = 4;
							if (MiscItem.HPHUDShakeTime > 175) MiscItem.HPHUDShakeTime = 175;
						}
					}
				}
				
				if (dydudebug_hudrecdmgdisplays) Console.Printf("HP Loss: %d [%d] (timer: %d)", MiscItem.HPDmgHUDAmt, loss, MiscItem.HPDmgHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Loss [HUD]
				if (MiscItem.APDmgHUDTimer <= 0) MiscItem.APDmgHUDTimer = 105;
				else
				{
					MiscItem.APDmgHUDTimer += 35;
					if (MiscItem.APDmgHUDTimer < 105 && loss > 1) MiscItem.APDmgHUDTimer = 105;
					if (MiscItem.APDmgHUDTimer > 175) MiscItem.APDmgHUDTimer = 175;
				}
				MiscItem.APDmgHUDAmt += loss;
				if (acculmuateshake && loss > 0)
				{
					if (dydudebug_hudrecdmgdisplays) Console.Printf("AP loss: %d", loss);
					int armmax;
					if (player.CountInv("KnightGownItem")) armmax = 250;
					if (player.CountInv("KnightGownItem2")) armmax = 500;
					if (player.CountInv("KnightGownItem3")) armmax = 1000;
					if (player.CountInv("KnightGownItem4")) armmax = 2000;
					if (armmax)
					{
						int damagetakefactor = MiscItem.APDmgHUDAmt * 100 / armmax;
						if (MiscItem.APDmgHUDAmt > 0 && loss > 0)
						{
							MiscItem.APHUDShakeTime += random(52,53);
							if (damagetakefactor < 10) 
							{
								MiscItem.APHUDShakeType = 1;
								if (MiscItem.APHUDShakeTime > 53) MiscItem.APHUDShakeTime = 53;
							}
							if (damagetakefactor >= 10)
							{
								MiscItem.APHUDShakeType = 2;
							if (MiscItem.APHUDShakeTime > 88) MiscItem.APHUDShakeTime = 88;
							}
							if (damagetakefactor >= 50)
							{
								MiscItem.APHUDShakeType = 3;
							if (MiscItem.APHUDShakeTime > 140) MiscItem.APHUDShakeTime = 140;
							}
							if (damagetakefactor >= 100)
							{
								MiscItem.APHUDShakeType = 4;
							if (MiscItem.APHUDShakeTime > 175) MiscItem.APHUDShakeTime = 175;
							}
						}
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("AP Loss: %d [%d] (timer: %d)", MiscItem.APDmgHUDAmt, loss, MiscItem.APDmgHUDTimer);
			}
		}
	}
}

mixin class DmgCalc
{
	action bool A_CheckDDGameA()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	action int A_GetPlayerLvl(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGameA()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl - DmgCalc mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}

	action int A_GetPunchDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
			PlayerLevel = TruePlayerLevel;
		}
		
		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;
		String nm, nn, no, np;

		// Character Check [base damage]
		damage = random(6,12);
		if (altfire == 1) damage *= 6.64;
		if (dydudebug_meleedmg) Console.Printf("BaseDmg: %.8f [%s, %s]", damage, weaponname, actorname);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = player.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.375)));
		if (dydudebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,192) <= (191 - (TruePlayerLevel * 0.01875)))
			{
				if (altfire == 0) adddmg = randompick(1,1,1,2,2);
				if (altfire == 1) adddmg = randompick(4,5,6,7,8);
			}
			else
			{
				if (altfire == 0) adddmg = randompick(2,3,3,4,4);
				if (altfire == 1) adddmg = randompick(7,8,9,10,11);
				rngroll = 1;
			}
			adddmg *= exex_strmeleescale;
			if (dydudebug_meleedmg) Console.Printf("exex_strmeleescale: %.8f", exex_strmeleescale);
			if (!exex_expenabled && A_CheckDDGameA()) 
			{
				adddmg *= exex_nrpgmeleescale;
				adddmg *= exex_nrpggeneraleffect;
				if (dydudebug_meleedmg) Console.Printf("exex_nrpgmeleescale: %.8f", exex_nrpgmeleescale);
			}
			double mindmg = (1.0 * exex_strmeleescale * exex_nrpgmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (dydudebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Punch/Uppercut (type: %d)]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerSTR, altfire, adddmg, rngroll);
		}
		if (dydudebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerSTR, previousdamage);
		
		if (MiscItem && exex_expenabled) damage *= (1.0 + (MiscItem.NumOfAfasDrops * 0.0625));

		// Berserk Check
		previousdamage = damage;
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) damage = floor(damage * 10);
		if (dydudebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,1,2,2,2,2,2,3)));
			if (dydudebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f)", weaponname, damage, previousdamage);
		}
		
		previousdamage = damage;
		If (weapon is "HandToHand")
		{
			if (CountInv("DinahTrueIPState")) damage *= 5;
		}
		if (dydudebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Punch]", weaponname, damage, previousdamage);
		if (dydudebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (\c[green]%s\c-) %.8f - (Previous Dmg: %.8f) [Uppercut]", weaponname, damage, previousdamage);
		
		if (istarget)
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Puff: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: \c[green]%s\c- - Source: \c[darkgreen]%s\c-) %.8f\c- - \cx(Previous Dmg: %.8f) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
	
	action int A_GetKickDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int PlayerSTR;
		int PlayerLevel;
		int TruePlayerLevel = A_GetPlayerLvl(1);
		if (MiscItem) 
		{
			PlayerSTR = MiscItem.TruePlayerATK + TruePlayerLevel;
			PlayerLevel = TruePlayerLevel;
		}

		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		double damage;
		double previousdamage;
		int strengthcounter;

		damage = random(19,42);
		if (dydudebug_meleedmg) Console.Printf("BaseDmg: %.8f", damage);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = player.Stamina;
		previousdamage = damage;
		damage = floor(damage * (1.00 + (stamdamagefactor * 0.375)));
		if (dydudebug_meleedmg) Console.Printf("StaminaDmg: %.8f, StamUpgrades: %d - (Previous Dmg: %.8f)", damage, stamdamagefactor, previousdamage);

		// Strength Stat Check [7 pts = roughly double the character's base punch damage]
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
		{
			double adddmg;
			int rngroll;
			if (random(1,128) <= (127 - (TruePlayerLevel * 0.025)))
			{
				adddmg = randompick(2,2,2,3,3,4);
			}
			else
			{
				adddmg = randompick(5,6,7,9,10,11);
				rngroll = 1;
			}
			adddmg *= exex_strmeleescale;
			if (dydudebug_meleedmg) Console.Printf("exex_strmeleescale: %.8f", exex_strmeleescale);
			if (!exex_expenabled && A_CheckDDGameA()) 
			{
				adddmg *= exex_nrpgmeleescale;
				adddmg *= exex_nrpggeneraleffect;
				if (dydudebug_meleedmg) Console.Printf("exex_nrpgmeleescale: %.8f", exex_nrpgmeleescale);
			}
			double mindmg = (1.0 * exex_strmeleescale * exex_nrpgmeleescale);
			if (adddmg < mindmg) adddmg = mindmg;
			damage += adddmg;
			if (dydudebug_meleedmg) Console.Printf("\c[fire]strengthcounter %d / %d [Kick]: %.8f (rngroll: %d)\c-", strengthcounter+1, PlayerSTR, adddmg, rngroll);
		}
		if (dydudebug_meleedmg) Console.Printf("\c[fire]StrDmg: %.8f\c- - (Strength: %d) - (Previous Dmg: %.8f)", damage, PlayerSTR, previousdamage);
		
		if (MiscItem && exex_expenabled) damage *= (1.0 + (MiscItem.NumOfAfasDrops * 0.0625));

		// Reduce Check
		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * (1.00 + (0.05 * random(-4,4))));
		if (altfire == 1) damage = floor(damage * (1.00 + (0.075 * random(-4,4))));
		if (dydudebug_meleedmg) Console.Printf("ReduceDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		if (player.CountInv("DinahTrueIPState")) damage *= 5;

		// Berserk Check
		previousdamage = damage;
		if (player.CountInv("PowerStrength") || player.CountInv("PowerStrengthDD")) damage = floor(damage * 10);
		if (dydudebug_meleedmg) Console.Printf("BerserkDmg: %.8f - (Previous Dmg: %.8f)", damage, previousdamage);

		double PerkFactor;
		double temp1, temp2;

		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,2,2,2,2,2,3)));
			if (dydudebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (%s) %.8f - (Previous Dmg: %.8f (Shockwave)", weaponname, damage, previousdamage);
		}

		previousdamage = damage;
		if (altfire == 0) damage = floor(damage * 1.0);
		if (altfire == 1) damage = floor(damage * 0.25);
		if (dydudebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Kick]", weaponname, damage, previousdamage);
		if (dydudebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %.8f - (Previous Dmg: %.8f) [Roundhouse Kick]", weaponname, damage, previousdamage);

		if (istarget)
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Kick]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %.8f\c- - \cx(Previous Dmg: %.8f) [Roundhouse Kick]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return int(damage);
	}
}

mixin class CollisionChecker
{
	string infl;
	actor projowner;
	// Checks for certain projectiles from charmed/friendly allies to pass through other friendlies instead of colliding
	int A_CheckFriendCollisionProjTypeFriendlyDoom()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyDoom:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyHeretic()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHeretic:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyHexen()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHexen:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyStrife()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyStrife:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyOthers()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyOthers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendly1()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendly1:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer(Actor actr)
	{
		infl = actr.GetClassName();
		projowner = actr.target;
		actor PlayPawn = PlayerPawn(projowner);
		actor ProjD;
		ProjD = EEProjectile(actr);
		
		int type;
		if (ProjD && PlayPawn) type = 1;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer2(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (
				// Circus 2 Stuff
				infl == "Sparkles" ||
				CrazyBits1(actr) ||
				infl == "Popcorn_Shrap1" ||
				infl == "Popcorn_Shrap7" ||
				infl == "CrazyBalls" ||
				infl == "CrazyBall" ||
				infl == "CrazyBallDD"
			 ) type = 1;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer2:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	// Sets up what projectiles can be eaten by the active SuperVac, and how many units they give V:
	int, int A_CheckCollisionProjShieldExemptionSV(Actor actr)
	{
		bool IPAttack = false;
		if (GetClassName() == "SuperVacAbsorbsionPartIP") IPAttack = true;
		string nm, nn, no, np;
		if (actr && actr.bMISSILE)
		{
			infl = actr.GetClassName();
			if (dydudebug_supervacproj) Console.Printf("(\c[gold]%s\c- [attempt])", infl);
			
			int type = 1;
			int vacgive = ((actr.height * (actr.radius * 2)) * frandom(0.1667,0.3334));
			if (vacgive < 1) vacgive = 1;
			
			//**********************************************************************************
			//* Special Calls for Guaranteed Devours [i.e. boosting/lessening their bag units] *
			//**********************************************************************************
			if (BadBlundershot(actr)) return type, (vacgive * frandom(2.5,3.25));
	
			if (exex_supervaccaneatprojectiles < 2) // If set to 2, SuperVac will eat all projectiles and ignore the lists below V:
			{
				//**********************************************************************************
				//* Things that have a random chance of being devoured instead of being guaranteed *
				//**********************************************************************************
				int defaultroll = 100;
				// Imps
				if (DoomImpBall(actr) ||
						DoomImpBallNew(actr))
				{
					defaultroll = randompick(86,86,86,87);
				}
				if (DarkNormal(actr))
				{
					defaultroll = randompick(86,86,86,87);
				}
				if (DarkStrong(actr))
				{
					defaultroll = randompick(55,56);
				}
				if (DarkFast(actr))
				{
					defaultroll = randompick(28,28,28,29);
				}
				if (NetherLightning(actr))
				{
					defaultroll = randompick(9,10);
				}
				if (InfernoBall(actr))
				{
					defaultroll = randompick(28,28,28,28,28,28,28,29);
				}
				// Pinkies
				if (DemonFire(actr) ||
						BloodDemonFire(actr))
				{
					defaultroll = randompick(86,86,86,87);
				}
				if (NightmareSpectreFire(actr) ||
						NightmareBloodSpectreFire(actr))
				{
					defaultroll = randompick(56,56,56,57);
				}
				// Hell Cleric
				if (HellClericBall(actr) ||
						HellClericDarkBall(actr))
				{
					defaultroll = 45;
				}
				// Revenant
				if (RevenantTracer(actr) ||
						RevenantTracerNew(actr))
				{
					defaultroll = randompick(99,100,100,100,100,100,100,100,100,100);
				}
				// Cacodemons
				if (CacodemonBall(actr) ||
						CacodemonBallNew(actr))
				{
					defaultroll = 80;
				}
				if (CacolanternBall(actr))
				{
					defaultroll = randompick(62,63);
				}
				if (AbaddonBall(actr))
				{
					defaultroll = randompick(66,67,67);
				}
				// Hell Nobles
				if (HellWarriorBall(actr))
				{
					defaultroll = randompick(44,44,44,44,44,45,45,45,45);
				}
				if (HellWarriorBall2(actr)) 
				{
					defaultroll = randompick(88,89,89,89,89,89,89,89,89);
				}
				if (FlyingBalrogShot1(actr) ||
						FlyingBalrogShot2(actr))
				{
					defaultroll = randompick(47,48);
				}
				if (CyBruiserMissile(actr) ||
						CyBruiserMissileSeek(actr))
				{
					defaultroll = randompick(36,37,37,37);
				}
				if (BruiserBall(actr))
				{
					defaultroll = 75;
				}
				if (BruiserBall2(actr))
				{
					defaultroll = 50;
				}
				if (BruiserFire(actr))
				{
					defaultroll = randompick(12,13);
				}
				if (KnightBallNew(actr))
				{
					defaultroll = randompick(36,37);
				}
				if (BaronBall(actr) || 
						BaronBallNew(actr))
				{
					defaultroll = randompick(23,24,24,24);
				}
				if (BelphegorBall(actr))
				{
					defaultroll = randompick(18,19,19,19);
				}
				// Karasawa
				if (KsawBolt(actr)) 
				{
					defaultroll = randompick(93,94,94,94);
				}
				// Mancubi
				if (FatShot(actr) || 
						FatShotNew(actr))
				{
					defaultroll = randompick(37,38);
				}
				if (HectShot(actr))
				{
					defaultroll = 30;
				}
				if (DaedFire(actr))
				{
					defaultroll = randompick(22,23);
				}
				// Arachnotrons / Plasma Zombiemen / BFG Commando's 2704 shots
				if (ArachnotronPlasma(actr) || 
						ArachnotronPlasmaNew(actr) || 
						PlasmaBallMonster(actr) ||
						PlasmaBall1Monster(actr) ||
						PlasmaBall2Monster(actr))
				{
					defaultroll = randompick(28,28,28,28,28,28,28,29);
				}
				// Archviles
				if (DFlare(actr))
				{
					defaultroll = randompick(62,63);
				}
				if (DMissile(actr))
				{
					defaultroll = 5;
				}
				if (DMissileCircle(actr) ||
						DMissileTrail(actr))
				{
					defaultroll = 95;
				}
				if (DTracer(actr))
				{
					defaultroll = randompick(24,25,25,25,25,25,25,25);
				}
				if (DTracerPuff(actr))
				{
					defaultroll = randompick(98,99,99,99);
				}
				// Hitscan Tracers
				if (ZombieBulletTracer(actr))
				{
					defaultroll = randompick(3,4,4,4);
				}
				if (ZombieRepeaterTracer(actr))
				{
					defaultroll = 15;
				}
				if (IncarnateGlareTracer(actr))
				{
					defaultroll = randompick(55,56);
				}
				// Cyberdemons/Rocket Zombiemen
				If (RocketMonster(actr) || 
						Rocket2(actr) || 
						HomRocket1(actr)) 
				{
					defaultroll = randompick(18,19,19,19);
				}
				// BFG Commandos/Spider Demolishers
				if (BFGBallMonster(actr))
				{
					defaultroll = randompick(11,11,11,12);
				}
				// DD Trilogy Projectiles
				if (BadCherryBomb(actr) ||
						BadCherryBomb2(actr))
				{
					defaultroll = randompick(28,28,28,29);
				}
				if (SpinnerShotEvil(actr))
				{
					defaultroll = randompick(36,37);
				}
				if (CroquetBall(actr))
				{
					defaultroll = randompick(86,86,86,87);
				}
				if (JorgSong(actr) ||
						AAngelSong(actr))
				{
					defaultroll = randompick(28,28,28,29);
				}
				if (RealBadCroquetBall(actr))
				{
					defaultroll = 45;
				}
				if (CoinShot(actr))
				{
					defaultroll = random(87,100);
				}
				if (SeedBall(actr) ||
						BigChookGrenade(actr))
				{
					defaultroll = randompick(86,86,86,87);
				}
				if (JuggerAxe(actr) || 
						BadJackShot(actr) ||
						StarBall(actr))
				{
					defaultroll = randompick(72,73);
				}
				if (RealBadJackShot(actr) ||
						KragBall(actr))
				{
					defaultroll = 40;
				}
				if (ChookEggShot(actr) ||
						MeteorBall(actr))
				{
					defaultroll = randompick(55,56);
				}
				if (ChookEggGrenade(actr))
				{
					defaultroll = random(95,100);
				}
				if (ChookEggMini(actr) || 
						JorgTeeth(actr))
				{
					defaultroll = random(98,100);
				}
				if (PupGrenade(actr) || 
						ChookGrenade(actr))
				{
					defaultroll = random(95,100);
				}
				if (BadBRocketShot(actr))
				{
					defaultroll = random(4,5);
				}
				if (BadZapShot(actr)) 
				{
					defaultroll = random(4,5);
				}
				if (BadRecordShot(actr)) 
				{
					defaultroll = random(5,7);
				}
				if (BadCandleShot(actr) ||
						BadCandleShotIcy(actr))
				{
					defaultroll = random(4,5);
				}
				// Out of Mod definitions
				nm = "ShadowBall"; if (infl == nm) defaultroll = randompick(55,56);
				nm = "RimeGrapple"; if (infl == nm) defaultroll = 50;
				nm = "ClinkBlade"; if (infl == nm) defaultroll = randompick(62,63);
				nm = "GreenAxe"; if (infl == nm) defaultroll = randompick(62,63);
				nm = "RedAxe"; if (infl == nm) defaultroll = randompick(62,63);
				nm = "GrellShot"; if (infl == nm) defaultroll = randompick(66,67,67);
				nm = "RSnakeShotSmall"; if (infl == nm) defaultroll = randompick(66,67,67);
				nm = "RSnakeShotBig"; if (infl == nm) defaultroll = randompick(83,84,84,84);
				nm = "AdderHex1"; if (infl == nm) defaultroll = randompick(66,67,67);
				nm = "AdderHex2"; if (infl == nm) defaultroll = randompick(66,67,67);
				
				actor player = players[0].mo;
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				int TruePlayerLevel = A_GetPlayerLvl();
				if (MiscItem)
				{
					double remainder = (100 - defaultroll);
					remainder *= 0.25;
					remainder *= (0.0 + (TruePlayerLevel * 0.005));
					defaultroll += remainder;
					if (defaultroll > 100) defaultroll = 100;
				}
				if (IPAttack)
				{
					double remainder = (100 - defaultroll);
					remainder *= frandom(0.667,0.75);
					defaultroll += remainder;
					if (defaultroll > 100) defaultroll = 100;
				}
				
				//*****************************************************
				//* Things that will NOT get devoured below this line *
				//*****************************************************
				If (VacShot(actr) || 
						VacShotMini(actr) ||
						BadVacShot(actr) ||
						MiniNote(actr) ||
						MiniNote2(actr) ||
						Lightningbolt(actr) ||
						BarrierBeam(actr) ||
						ArchvileFire(actr) ||
						DFire(actr) ||
						DiabloistGravityHPTargeter(actr) ||
						DiabloistGravityHPTargeter2(actr) ||
						DiabloistGravityHPTargeter3(actr) ||
						DiabloistGravityManaTargeter(actr) ||
						DiabloistGravityManaTargeter2(actr) ||
						DiabloistGravityManaTargeter3(actr) ||
						ReviveProj(actr) ||
						ReviveProj2(actr) ||
						SuicideBomb(actr) ||
						SuicideBombStrong(actr) ||
						SuicideBombUltra(actr) ||
						HSBoom(actr) ||
						BruiserFireSpawner(actr) ||
						FootStep(actr) ||
						CyberStomp(actr) ||
						AnnhiliatorStomp(actr)) defaultroll = 0;
				
				
				//*********
				//* Rolls *
				//*********
				int roll = random(1,100);
				if (roll <= defaultroll) 
				{
					if (RevenantTracer(actr) ||
							RevenantTracerNew(actr))
					{
						vacgive *= frandom(2.5,3.25);
					}
					if (dydudebug_supervacproj) Console.Printf("(\c[gold]%s\c-): type: %d, vacgive: %d, roll [%d] vs defaultroll [%d] [\c[green]succeed\c-]", actr.GetClassName(), type, vacgive, roll, defaultroll);
					return type, vacgive;
				}
				else
				{
					if (dydudebug_supervacproj) Console.Printf("(\c[gold]%s\c-): roll [%d] vs defaultroll [%d] [\c[red]fail\c-]", actr.GetClassName(), roll, defaultroll);
					return 0, 0;
				}
			}
			
			// Else, Default to "yes"
			if (vacgive < 1 && type > 0) vacgive = 1;
			return type, vacgive;
		}
		else return 0, 0;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckCollisionProjShieldExemptionE(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		If (BadJackShot(actr)) type = 1;
		If (RealBadJackShot(actr)) type = 1;
	
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemptionE:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckCollisionProjShieldExemption(Actor actr)
	{
		infl = actr.GetClassName();

		int type;
		if (MalletShot(actr) || 
				MalletShotBerserk(actr) || 
				BlunderShot(actr) || 
				EggShot(actr) || 
				EggGrenade(actr) || 
				EggMini(actr) || 
				ZapShot(actr) || 
				JackShot(actr) || 
				RecordShot(actr) || 
				VacShot(actr) || 
				CherryBombShot(actr) || 
				BRocketShot(actr) || 
				BRocketBoom1(actr) || 
				BRocketBoom2(actr) || 
				SpinnerShot(actr) || 
				PopperPuff1(actr) || 
				PopperPuff1Tracer(actr) || 
				PopperPuff2(actr) || 
				PopperPuff2Tracer(actr) || 
				StreamerShot(actr) || 
				StreamerTrail(actr) || 
				SnakeGrenade(actr) || 
				SnakeMiniGrenade(actr) || 
				Confetti_Y(actr) ||
				Confetti_B(actr) ||
				Confetti_P(actr)
			 ) type = 1;
	
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
}

mixin class DynMusicControl
{
	bool A_CheckDDGame()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}

	void A_DynamicMusic(int timerset = 200, int patktype = 0, bool bossfight = false, int bossmusic = -1, bool forcedplay = false, bool checkres = false)
	{
		timerset *= exex_dynmustimescale;
		bool changemusic;
		actor dmtarget;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (checkres && bFRIENDLY) return;
		
		if (A_CheckDDGame())
		{
			//ACS_Execute(102,0,0,0,0); // Uses the ACS-Based system within the original DD/AFD maps for the dynamic music, as originally coded
		}
		else
		{
			if (dydudebug_dynmusdisplays && exex_dynamicmusic && !forcedplay) Console.Printf("DynMusActionAttempt (playerside) [%s]", self.GetClassName());
			// Uses the mod's own system
			DDPlayerPawn playpawn;
			playpawn = DDPlayerPawn(self);
			if (playpawn) 
			{
				if (AimTarget()) 
				{
					dmtarget = AimTarget();
					if (dmtarget)
					{
						if (EECustomGib(dmtarget)) dmtarget == null;
						if (DDAFDNPC(dmtarget)) dmtarget == null;
						if (EEProp(dmtarget)) dmtarget == null;
						if (ShieldPartBase(dmtarget)) dmtarget == null;
						if (ShieldPart(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeNoReflect(dmtarget)) dmtarget == null;

						if (SwingShieldPart(dmtarget)) dmtarget == null;
						if (SwingShieldPartNoReflect(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeNoReflect(dmtarget)) dmtarget == null;
						if (ShieldPartMeleeReflect(dmtarget)) dmtarget == null;

						if (KickShieldNoReflect(dmtarget)) dmtarget == null;
						if (KickShieldReflect(dmtarget)) dmtarget == null;

						if (CricketShieldPart(dmtarget)) dmtarget == null;
						if (CricketShieldPartNoReflect(dmtarget)) dmtarget == null;
						if (CricketShieldPartNoReflect(dmtarget)) dmtarget == null;
						if (CricketSwingShieldPart(dmtarget)) dmtarget == null;
						if (CricketSwingShieldPartBerserk(dmtarget)) dmtarget == null;
						if (CricketSwingShieldShort(dmtarget)) dmtarget == null;
						if (CricketSwingShieldShortBerserk(dmtarget)) dmtarget == null;
						if (CricketSwingPartNoReflect(dmtarget)) dmtarget == null;
						if (CricketSwingPartNoReflectBerserk(dmtarget)) dmtarget == null;
						if (CricketSwingShortNoReflect(dmtarget)) dmtarget == null;
						if (CricketSwingShortNoReflectBerserk(dmtarget)) dmtarget == null;

						if (SuperVacAbsorbsionPart(dmtarget)) dmtarget == null;
						if (SuperVacAbsorbsionPartIP(dmtarget)) dmtarget == null;

						if (ScramblerSwingShieldPart(dmtarget)) dmtarget == null;
						if (ScramblerSwingPartNoReflect(dmtarget)) dmtarget == null;

						if (AppleJackSwingShieldPart(dmtarget)) dmtarget == null;
						if (AppleJackSwingPartNoReflect(dmtarget)) dmtarget == null;
						if (JackShotShieldPart(dmtarget)) dmtarget == null;
						if (JackShotShieldPartFoe(dmtarget)) dmtarget == null;
						if (JackShotShieldPartBerserk(dmtarget)) dmtarget == null;

						if (WhipShieldPart(dmtarget)) dmtarget == null;
						if (WhipShieldPartNoReflect(dmtarget)) dmtarget == null;

						if (EvilKickShieldNoReflect(dmtarget)) dmtarget == null;
						if (EvilKickShieldReflect(dmtarget)) dmtarget == null;

						if (ShieldPartBig(dmtarget)) dmtarget == null;
						if (ShieldPartBigVisual(dmtarget)) dmtarget == null;

						if (ExplosiveBarrel(dmtarget)) dmtarget == null;
						if (ExplosiveBarrelNew(dmtarget)) dmtarget == null;
						if (!dmtarget.bISMONSTER) dmtarget == null;
					}
				}
				if (!dmtarget) // No Target, increment actiontimer by 1-3+
				{
					double actionmult = 1.0;
					if (patktype == 1)
					{
						if (playpawn.CountInv("PowerStrength") || playpawn.CountInv("PowerStrengthDD")) actionmult = 1.5;
						else actionmult = 0.05;
					}
					if (dydudebug_dynmusdisplays && exex_dynamicmusic && !forcedplay) Console.Printf("actionmult: %.4f [patktype: %d]", actionmult, patktype);
					if (MiscItem)
					{
						MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
						if (random(1,4) <= 1) 
						{
							MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
							if (random(1,16) <= 1) 
							{
								MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
								if (random(1,64) <= 1) 
								{
									MiscItem.playeractiontimer += (randompick(1,2,2,2,2,2,3) * actionmult);
								}
							}
						}
						// If actiontimer exceeds a random range, force action music to play, ala SiN
						if (MiscItem.DynMusFightTimer > 0)
						{
							if (MiscItem.playeractiontimer > random(8,12)) changemusic = true;
						}
						else
						{
							if (MiscItem.playeractiontimer > random(14,21)) changemusic = true;
						}
					}
				}
				
				if (dydudebug_dynmusdisplays && exex_dynamicmusic && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt [AimTarget: %s]", dmtarget.GetClassName());
			}
			else 
			{
				dmtarget = target;
				if (dydudebug_dynmusdisplays && exex_dynamicmusic && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt [target: %s]", dmtarget.GetClassName());
			}

			if (dmtarget)
			{
				if (dydudebug_dynmusdisplays && exex_dynamicmusic) Console.Printf("DynMusActionAttempt [dmtarget: %s]", dmtarget.GetClassName());
				if (((bFRIENDLY == true || self == player) && dmtarget.bFRIENDLY == false) ||
						 (bFRIENDLY == false && (dmtarget.bFRIENDLY == true || dmtarget == player))) changemusic = true;
			}
			if (forcedplay) changemusic = true;
			if (exex_dynamicmusic && changemusic)
			{
				if (dmtarget && (dmtarget.bBOSS && !dmtarget.bFRIENDLY) || (!self.bFRIENDLY && self.bBOSS && dmtarget == player)) timerset *= 1.75;
				if (MiscItem)
				{
					MiscItem.playeractiontimer = 0;
					MiscItem.playeractiontimerfrag = 0;
					if (exex_deathmusic && player.health <= 0)
					{
					}
					else
					{
						MiscItem.DynMusActCall = true;
						if (MiscItem.DynMusFightTimer < timerset) MiscItem.DynMusFightTimer = timerset;
					}
				}
			}
		}
	}
}

mixin class MonsterCollider
{
	int targetdummyhitcooldown;
	Actor lastattacker;
	Actor lastattackeratk;
	Actor playeriskiller;
	
	class<Actor> extracheck, extracheck2, extracheck3, extracheck4;
	string nm, nn, no, np;
	
	bool A_CheckDDGame()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	int A_GetPlayerLvl2(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGame()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl2 - MonsterCollider mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}
	
	void CCCardDeathCheck()
	{
		state CCState = FindState("DeathCC");
		let globalvars = DDGlobalVariables.Get();
		if (globalvars.PlayingCCards)
		{
			//Console.Printf("globalvars.PlayingCCards: %d", globalvars.PlayingCCards);
			if (CCState) SetState(CCState);
		}
	}
	
	void A_DynamicMusic(int timerset = 200, int matktype = 0, bool bossfight = false, int bossmusic = -1, bool forcedplay = false, bool checkres = false)
	{
		timerset *= exex_dynmustimescale;
		bool changemusic;
		actor dmtarget;
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (checkres && bFRIENDLY) return;
		
		if (A_CheckDDGame())
		{
			ACS_Execute(102,0,0,0,0); // Uses the ACS-Based system within the original DD/AFD maps for the dynamic music, as originally coded
		}
		else
		{
			if (dydudebug_dynmusdisplays && exex_dynamicmusic && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [%s]", self.GetClassName());
			// Uses the mod's own system
			dmtarget = target;
			if (dydudebug_dynmusdisplays && exex_dynamicmusic && dmtarget && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [target: %s]", dmtarget.GetClassName());

			if (dmtarget)
			{
				if (dydudebug_dynmusdisplays && exex_dynamicmusic && !forcedplay) Console.Printf("DynMusActionAttempt (monsterside) [dmtarget: %s]", dmtarget.GetClassName());
				if (((bFRIENDLY == true || self == player) && dmtarget.bFRIENDLY == false) ||
						 (bFRIENDLY == false && (dmtarget.bFRIENDLY == true || dmtarget == player))) changemusic = true;
			}
			if (matktype == 11) // Suicide Bomber type call
			{
				if (dmtarget && Distance3D(dmtarget) > 1024) changemusic = false;
			}
			if (forcedplay) changemusic = true;
			if (exex_dynamicmusic && changemusic)
			{
				if (dmtarget && (dmtarget.bBOSS && !dmtarget.bFRIENDLY) || (!self.bFRIENDLY && self.bBOSS && dmtarget == player)) timerset *= 1.75;
				if (MiscItem)
				{
					if (exex_deathmusic && player.health <= 0)
					{
					}
					else
					{
						MiscItem.DynMusActCall = true;
						if (MiscItem.DynMusFightTimer < timerset) MiscItem.DynMusFightTimer = timerset;
					}
				}
			}
		}
	}
	//
	void A_RecoverHUD(int recovery, int type, bool acculmuatepulse)
	{
		if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD called");
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));

		if (MiscItem && dyduhud_showhpapdmgrec)
		{
			if (dydudebug_hudrecdmgdisplays) Console.Printf("A_RecoverHUD [MiscItem]");
			if (type == 0) // HP
			{
				// HP Recovery [HUD]
				if (MiscItem.HPRecHUDTimer <= 0) MiscItem.HPRecHUDTimer = 105;
				else
				{
					MiscItem.HPRecHUDTimer += 35;
					if (MiscItem.HPRecHUDTimer < 105 && recovery > (MiscItem.MaxHealthTrue * 0.01)) MiscItem.HPRecHUDTimer = 105;
					if (MiscItem.HPRecHUDTimer > 175) MiscItem.HPRecHUDTimer = 175;
				}
				MiscItem.HPRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					if (MiscItem.HPRecHUDAmt > 0 && recovery > 0)
					{
						int healfactor = MiscItem.HPRecHUDAmt * 100 / MiscItem.MaxHealthTrue;
						if (healfactor < 10) MiscItem.HPHUDPulseType = 1;
						if (healfactor >= 10) MiscItem.HPHUDPulseType = 2;
						if (healfactor >= 50) MiscItem.HPHUDPulseType = 3;
						if (healfactor >= 100) MiscItem.HPHUDPulseType = 4;
						MiscItem.HPHUDPulseTimeP = (level.time % randompick(15,25,35));
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("HP Gain: %d [%d] (timer: %d)", MiscItem.HPRecHUDAmt, recovery, MiscItem.HPRecHUDTimer);
			}

			if (type == 1) // AP
			{
				// AP Recovery [HUD]
				if (MiscItem.APRecHUDTimer <= 0) MiscItem.APRecHUDTimer = 105;
				else
				{
					MiscItem.APRecHUDTimer += 35;
					if (MiscItem.APRecHUDTimer < 105 && recovery > 1) MiscItem.APRecHUDTimer = 105;
					if (MiscItem.APRecHUDTimer > 175) MiscItem.APRecHUDTimer = 175;
				}
				MiscItem.APRecHUDAmt += recovery;
				if (acculmuatepulse && recovery > 0)
				{
					int armmax;
					if (player.CountInv("KnightGownItem")) armmax = 250;
					if (player.CountInv("KnightGownItem2")) armmax = 500;
					if (player.CountInv("KnightGownItem3")) armmax = 1000;
					if (player.CountInv("KnightGownItem4")) armmax = 2000;
					if (armmax)
					{
						if (MiscItem.APRecHUDAmt > 0 && recovery > 0)
						{
							int healfactor = MiscItem.APRecHUDAmt * 100 / armmax;
							if (healfactor < 10) MiscItem.APHUDPulseType = 1;
							if (healfactor >= 10) MiscItem.APHUDPulseType = 2;
							if (healfactor >= 50) MiscItem.APHUDPulseType = 3;
							if (healfactor >= 100) MiscItem.APHUDPulseType = 4;
							MiscItem.APHUDPulseTimeP = (level.time % randompick(15,25,35));
						}
					}
				}
				if (dydudebug_hudrecdmgdisplays) Console.Printf("AP Gain: %d [%d] (timer: %d)", MiscItem.APRecHUDAmt, recovery, MiscItem.APRecHUDTimer);
			}
		}
	}

	// Resurrections
	override bool CanResurrect(Actor other, bool passive)
	{
		//Console.Printf("(CanResurrect)");
		int maxviletimesrevived = exex_maxresperarchvile;
		if (maxviletimesrevived <= 0) maxviletimesrevived = 32;
		int maxtimesrevivedpervile = exex_maxarchrespermonster;
		if (maxtimesrevivedpervile <= 0) maxtimesrevivedpervile = 32;

		int maxdiabtimesrevived = exex_maxresperdiabloist;
		if (maxdiabtimesrevived <= 0) maxdiabtimesrevived = 32;
		int maxtimesrevivedperdiab = exex_maxdiabrespermonster;
		if (maxtimesrevivedperdiab <= 0) maxtimesrevivedperdiab = 32;

		bool ResSucceed = true;
		DDPlayerPawn playpawn;
		EECreature EEMonster;
		EECreature RevivedMonster;
		EECreature RevivingMonster;
		RevivingMonster = EECreature(self);
		RevivedMonster = EECreature(other);
		if (RevivingMonster && RevivedMonster)
		{
			//Console.Printf("\c[fire]RevivingMonster: %p\c-, \c[green]RevivedMonster: %p\c-", RevivingMonster, RevivedMonster);
			if (!passive) // Monster is the one REVIVING...
			{
				if (GetClassName() == "Archvile" || GetClassName() == "ArchvileNew")
				{
					if (RevivingMonster.timesrevivedamonster < maxviletimesrevived)
					{
						if (RevivedMonster.timesrevivedpervile < maxtimesrevivedpervile)
						{
							if (other.GetClassName() == "ArchvileNew") { if (exex_vilesressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (exex_vilesressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (exex_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (exex_vilesressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (exex_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (exex_vilesressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (exex_vilesusehealthtores != 0)
								{
									if (exex_vilesusehealthtores < 0) health -= exex_vilesusehealthtores;
									if (exex_vilesusehealthtores > 0) health -= (health * (exex_vilesusehealthtores * 0.01));
									
									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedpervile++;
									//Console.Printf("\cxRevivedMonster.timesrevivedpervile: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedpervile, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				else
				if (GetClassName() == "Diabloist")
				{
					if (RevivingMonster.timesrevivedamonster < maxdiabtimesrevived)
					{
						if (RevivedMonster.timesrevivedperdiabloist < maxtimesrevivedperdiab)
						{
							if (other.GetClassName() == "ArchvileNew") { if (exex_diabsressurectviles) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Diabloist") { if (exex_diabsressurectdiabs) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "CyberdemonNew") { if (exex_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Annihilator") { if (exex_diabsressurectcybers) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "SpiderMastermindNew") { if (exex_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else if (other.GetClassName() == "Demolisher") { if (exex_diabsressurectspiders) { ResSucceed = true; } else { ResSucceed = false; } }
							else { ResSucceed = true; }
							if (ResSucceed > 0)
							{
								if (exex_diabsusehealthtores != 0)
								{
									if (exex_diabsusehealthtores < 0) health -= exex_diabsusehealthtores;
									if (exex_diabsusehealthtores > 0) health -= (health * (exex_diabsusehealthtores * 0.01));

									if (health < 1) health = 1;
								}
								RevivingMonster.timesrevivedamonster++;
								if (RevivedMonster) 
								{
									RevivedMonster.timesrevivedperdiabloist++;
									//Console.Printf("\cxRevivedMonster.timesrevivedperdiabloist: %d, timesrevivedamonster: %d\c-", RevivedMonster.timesrevivedperdiabloist, RevivingMonster.timesrevivedamonster);
								}
							}
						}
						else
						{
							ResSucceed = false;
						}
					}
					else
					{
						ResSucceed = false;
					}
				}
				
				if (other != self)
				{
					let Forsakened = Forsaken(self);
					if (Forsakened)
					{
						ResSucceed = true;
						other.A_SetInventory("ForsakenResBuff",1);
						//Console.Printf("ForsakenResurrection: %s", other.GetClassName());
					}
					
					if (ResSucceed && exex_combatlog) 
					{
						string sndname = "Resurrection/Evil";
						if (other.bBOSS) sndname = "Resurrection/EvilBig";
						other.A_StopSound(15);
						other.A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
						Console.Printf("\c[red]*\c- \c[brick]%s\c- is resurrecting \c[purple]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
					}
				}
				else
				{
					if (ResSucceed && exex_combatlog && !other.CountInv("NoRessurrectMessage")) 
					{
						if (DDAFDNPC(other))
						{
							other.bFRIENDLY = true;
							A_StopSound(15);
							A_StartSound("misc/spoohw",15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
							Console.Printf("\c[red]*\c- \c[brick]%s\c- is recovering from their stupor! [%d]", GetTag(), gametic);
						}
						else
						if (Delila_Boss(other))
						{
							string sndname = "Resurrection/Evil";
							if (bBOSS) sndname = "Resurrection/EvilBig";
							A_StopSound(15);
							A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
							Console.Printf("\c[red]*\c- \c[brick]%s\c- is recovering from their stupor! [%d]", GetTag(), gametic);
						}
						else
						{
							bool notification = true;
							nm = "ClayDevilNew"; extracheck = nm;
							if (other.GetClassName() == nm) notification = false;
							
							if (notification)
							{
								string sndname = "Resurrection/Evil";
								if (bBOSS) sndname = "Resurrection/EvilBig";
								A_StopSound(15);
								A_StartSound(sndname,15,CHANF_DEFAULT,frandom(0.8,1.2),ATTN_NONE,frandom(0.8,1.2));
								Console.Printf("\c[red]*\c- \c[brick]%s\c- is self resurrecting! [%d]", GetTag(), gametic);
							}
						}
					}
				}
			}
			else // Monster is the one BEING REVIVED...
			{
				if (RevivedMonster.cannotres) 
				{
					ResSucceed = false; 
				}
				else
				{
					let Vile = Archvile(self);
					if (Vile) 
					{
						if (Vile.health >= (Vile.SpawnHealth() + Vile.Stamina))
						{
							ResSucceed = true;
							if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect %s! [%d]", other.GetTag(), gametic);
						}
						else
						{
							ResSucceed = false;
							if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is NOT High Enough (i.e. Max or Higher) to resurrect %s! [%d]", other.GetTag(), gametic);
						}
					}
				}
				//if (exex_combatlog) Console.Printf("\c[red]*\c- \c[purple]%s\c- is being resurrected by \c[brick]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
			}
		}
		else ResSucceed = true;
		
		return ResSucceed;
	}

	// Collisions
	override bool CanCollideWith(Actor other, bool passive)
	{
		ShieldPart shieldpiece;
		shieldpiece = ShieldPart(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - \c[orange]%s\c- vs (\c[green]%s\c-) {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
			
			// Pass through certain shield parts, ones that would normally cause a monster to be bumped around by running into them
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - \c[green]%s\c- [ShieldPiece] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
				if (CricketShieldPart(shieldpiece) || CricketShieldPartNoReflect(shieldpiece) ||
						CricketSwingShieldPart(shieldpiece) || CricketSwingPartNoReflect(shieldpiece) ||
						CricketSwingShieldPartBerserk(shieldpiece) || CricketSwingPartNoReflectBerserk(shieldpiece) ||
						CricketSwingShieldShort(shieldpiece) || CricketSwingShortNoReflect(shieldpiece) ||
						CricketSwingShieldShortBerserk(shieldpiece) || CricketSwingShortNoReflectBerserk(shieldpiece) ||
						AppleJackSwingShieldPart(shieldpiece) || AppleJackSwingPartNoReflect(shieldpiece) ||
						JackShotShieldPartBerserk(shieldpiece) || JackShotShieldPart(shieldpiece) || JackShotShieldPartFoe(shieldpiece) ||
						ShieldPartMeleeNoReflect(shieldpiece) || ShieldPartMeleeNoReflect(shieldpiece) ||
						KickShieldReflect(shieldpiece) || KickShieldNoReflect(shieldpiece) ||
						EvilKickShieldReflect(shieldpiece) || EvilKickShieldNoReflect(shieldpiece) ||
						SuperVacAbsorbsionPart(shieldpiece) || SuperVacAbsorbsionPartIP(shieldpiece))
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision: Passive - \c[green]%s\c- [MeleeShieldPart] vs (\c[orange]%s\c-) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
					if (ExplosiveBarrel(self)) return false;
					return true;
				}
				return false;
			}

			// Pass through players, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.GetSpecies() == "Players")
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [PlayerType] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}

			// Pass through other actors, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.bFRIENDLY == 1)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}
		}
		else
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (\c[green]%s\c-) vs \c[orange]%s\c- {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
			
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- Passive - \c[orange]%s\c- [Friendly] vs (\c[green]%s\c-) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false;
			}
			return true; 
		}

		// We don't really care about others making the check.
		return true;
	}
	
	// Damage Tracking
	int initdmg;
	
	double, double, double A_DefenseIgnoreFactor(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle, bool wasblastedimpact, bool bellefishzap, bool surprisehit, int angvstype)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		int predmginr = damage;
		// (Partial) Defense Ignoring Attacks
		double prevDamageFactor;
		double basedmgfactor = DamageFactor;
		double ActorDefenseIgnoreFactor = 0.00;
		if (inflictor == null && source == null) 
		{
			// BLASTED Impact Damage
			if (wasblastedimpact) ActorDefenseIgnoreFactor += (frandom(0.45,0.55) * (1.00 - ActorDefenseIgnoreFactor));
		}
		else
		{
			double IPDmgFactor = 0.50;
			if (skill <= 0) IPDmgFactor = 1.00;
			if (skill == 1) IPDmgFactor = 0.875;
			if (skill == 2) IPDmgFactor = 0.75;
			if (skill == 3) IPDmgFactor = 0.625;
			if (skill >= 4) IPDmgFactor = 0.50;
			double sts = 1.0;
			if (MiscItem && MiscItem.sttabs > 0) sts = 1.0 + (MiscItem.sttabs * 0.083334);
			if (sts >= 1.50) sts = 1.50;
			IPDmgFactor *= sts;
			if (IPDmgFactor > 1.00) IPDmgFactor = 1.00;

			EEProjectile IPAtk;
			if (inflictor) IPAtk = EEProjectile(inflictor);
			else if (source) IPAtk = EEProjectile(source);
			if (IPAtk && IPAtk.IPAttack) ActorDefenseIgnoreFactor += (IPDmgFactor * (1.00 - ActorDefenseIgnoreFactor));
			else
			{
				DDPlayerPawn IPAtk2;
				if (inflictor) IPAtk2 = DDPlayerPawn(inflictor);
				else if (source) IPAtk2 = DDPlayerPawn(source);
				if (IPAtk2 && IPAtk2.IPAttack) ActorDefenseIgnoreFactor += (IPDmgFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			double AxeDebuffFactor = 0.00;
			if (CountInv("BlunderHelmSplitter")) AxeDebuffFactor = 0.30;
			if (CountInv("BlunderHelmSplitter2")) AxeDebuffFactor = 0.60;
			if (CountInv("BlunderHelmSplitter3")) AxeDebuffFactor = 0.90;
			double AxeAmpFactor = 1.00 + ((1 / ((1.0 - AxeDebuffFactor)) - 1.0) * frandompick(0.20,0.25,0.25,0.25,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.334,0.5,0.5,0.5,0.75));
			damage *= AxeAmpFactor;
			ActorDefenseIgnoreFactor += (AxeDebuffFactor * (1.00 - ActorDefenseIgnoreFactor));

			double TrueIPFactor = 1.00;
			DDPlayerPawn TrueIPPlayer;
			if (inflictor) TrueIPPlayer = DDPlayerPawn(inflictor);
			else if (source) TrueIPPlayer = DDPlayerPawn(source);
			if (TrueIPPlayer && TrueIPPlayer.CountInv("DinahTrueIPState")) ActorDefenseIgnoreFactor += (TrueIPFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double PikeAOEFactor = 0.334;
			if (mod == 'Zap') ActorDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - ActorDefenseIgnoreFactor));
			if (mod == 'Zap' && flags & DMG_EXPLOSION) ActorDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - ActorDefenseIgnoreFactor));
			if (flags & DMG_INFLICTOR_IS_PUFF && (PikePuff(inflictor) || PikePuff(source))) ActorDefenseIgnoreFactor += (PikeAOEFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double LeadFactor = 0.000;
			if (inflictor && DDPlayerPawn(inflictor))
			{
				if (inflictor.CountInv("BlunderShotUpgrade") == 1) LeadFactor = 0.1667;
				if (inflictor.CountInv("BlunderShotUpgrade") == 2) LeadFactor = 0.4;
				if (inflictor.CountInv("BlunderShotUpgrade") >= 3) LeadFactor = 0.75;
				
				double temp = (1.00 - LeadFactor);
				if (inflictor.CountInv("PowerWineBuffIPMaximum")) LeadFactor += (temp * frandom(0.25,0.375));
				else if (inflictor.CountInv("PowerWineBuffIPStrongestEven")) LeadFactor += (temp * frandom(0.1875,0.25));
				else if (inflictor.CountInv("PowerWineBuffStrongestEven")) LeadFactor += (temp * frandom(0.1125,0.15));
				else if (inflictor.CountInv("PowerWineBuffIPStrongest")) LeadFactor += (temp * frandom(0.125,0.1875));
				else if (inflictor.CountInv("PowerWineBuffStrongest")) LeadFactor += (temp * frandom(0.075,0.1125));
				else if (inflictor.CountInv("PowerWineBuffIPStrong")) LeadFactor += (temp * frandom(0.0625,0.125));
				else if (inflictor.CountInv("PowerWineBuffStrong")) LeadFactor += (temp * frandom(0.0375,0.075));
				else if (inflictor.CountInv("PowerWineBuffIPWeak")) LeadFactor += (temp * frandom(0.0,0.0625));
				else if (inflictor.CountInv("PowerWineBuffWeak")) LeadFactor += (temp * frandom(0.0,0.0375));
			}
			else
			if (source && DDPlayerPawn(source))
			{
				if (source.CountInv("BlunderShotUpgrade") == 1) LeadFactor = 0.1667;
				if (source.CountInv("BlunderShotUpgrade") == 2) LeadFactor = 0.4;
				if (source.CountInv("BlunderShotUpgrade") >= 3) LeadFactor = 0.75;
				
				double temp = (1.00 - LeadFactor);
				if (source.CountInv("PowerWineBuffIPMaximum")) LeadFactor += (temp * frandom(0.25,0.375));
				else if (source.CountInv("PowerWineBuffIPStrongestEven")) LeadFactor += (temp * frandom(0.1875,0.25));
				else if (source.CountInv("PowerWineBuffStrongestEven")) LeadFactor += (temp * frandom(0.1125,0.15));
				else if (source.CountInv("PowerWineBuffIPStrongest")) LeadFactor += (temp * frandom(0.125,0.1875));
				else if (source.CountInv("PowerWineBuffStrongest")) LeadFactor += (temp * frandom(0.075,0.1125));
				else if (source.CountInv("PowerWineBuffIPStrong")) LeadFactor += (temp * frandom(0.0625,0.125));
				else if (source.CountInv("PowerWineBuffStrong")) LeadFactor += (temp * frandom(0.0375,0.075));
				else if (source.CountInv("PowerWineBuffIPWeak")) LeadFactor += (temp * frandom(0.0,0.0625));
				else if (source.CountInv("PowerWineBuffWeak")) LeadFactor += (temp * frandom(0.0,0.0375));
			}
			if (mod == 'Lead') ActorDefenseIgnoreFactor += (LeadFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double CBombFactor = 0.125;
			if (inflictor && DDPlayerPawn(inflictor))
			{
				if (inflictor.CountInv("CBombUpgrade") == 1) CBombFactor = 0.25;
				if (inflictor.CountInv("CBombUpgrade") == 2) CBombFactor = 0.425;
				if (inflictor.CountInv("CBombUpgrade") >= 3) CBombFactor = 0.6125;
			}
			else
			if (source && DDPlayerPawn(source))
			{
				if (source.CountInv("CBombUpgrade") == 1) CBombFactor = 0.25;
				if (source.CountInv("CBombUpgrade") == 2) CBombFactor = 0.525;
				if (source.CountInv("CBombUpgrade") >= 3) CBombFactor = 0.6125;
			}
			if (mod == 'CherryBomb') ActorDefenseIgnoreFactor += (CBombFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double SpinnerFactor = 0.25;
			if (mod == 'Spinner') ActorDefenseIgnoreFactor += (SpinnerFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double BRocketFactor = 0.5;
			if (mod == 'BRocket') ActorDefenseIgnoreFactor += (BRocketFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double PopperFactor = frandompick(0.125,0.25,0.5);
			if (mod == 'Popper') ActorDefenseIgnoreFactor += (PopperFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
			if (inflictor && DDPlayerPawn(inflictor))
			{
				if (inflictor.CountInv("GrimophoneUpgrade") == 1) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.75);
				if (inflictor.CountInv("GrimophoneUpgrade") == 2) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.125);
				if (inflictor.CountInv("GrimophoneUpgrade") >= 3) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.625);
			}
			else
			if (source && DDPlayerPawn(source))
			{
				if (source.CountInv("GrimophoneUpgrade") == 1) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.75);
				if (source.CountInv("GrimophoneUpgrade") == 2) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.125);
				if (source.CountInv("GrimophoneUpgrade") >= 3) BeatsFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.625);
			}
			if (BeatsFactor > 1.00) BeatsFactor = 1.00;
			if (mod == 'Beats') ActorDefenseIgnoreFactor += (BeatsFactor * (1.00 - ActorDefenseIgnoreFactor));
			double BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.5);
			if (inflictor && DDPlayerPawn(inflictor))
			{
				if (inflictor.CountInv("GrimophoneUpgrade") == 1) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.75);
				if (inflictor.CountInv("GrimophoneUpgrade") == 2) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.125);
				if (inflictor.CountInv("GrimophoneUpgrade") >= 3) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.625);
			}
			else
			if (source && DDPlayerPawn(source))
			{
				if (source.CountInv("GrimophoneUpgrade") == 1) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 0.75);
				if (source.CountInv("GrimophoneUpgrade") == 2) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.125);
				if (source.CountInv("GrimophoneUpgrade") >= 3) BeatsAOEFactor = (frandompick(0.25,0.334,0.334,0.334,0.334,0.334,0.5) * 1.625);
			}
			if (BeatsAOEFactor > 1.00) BeatsAOEFactor = 1.00;
			if (mod == 'Beats' && flags & DMG_EXPLOSION) ActorDefenseIgnoreFactor += (BeatsAOEFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double WhistleFactor = 0.75;
			if (inflictor && PlayerWhistle(inflictor) || source && PlayerWhistle(source)) ActorDefenseIgnoreFactor += (WhistleFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double BarrelFactor = 0.50;
			if (skill <= 0) BarrelFactor = 1.0;
			if (skill == 1) BarrelFactor = 0.75;
			if (skill == 2) BarrelFactor = 0.5;
			if (skill == 3) BarrelFactor = 0.25;
			if (skill >= 4) BarrelFactor = 0.0;
			if ((ExplosiveBarrel(inflictor) || ExplosiveBarrel(source) || Pod(inflictor) || Pod(source)) && flags & DMG_EXPLOSION) ActorDefenseIgnoreFactor += (BarrelFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double CandleFactor = 0.00;
			if (MiscItem)
			{
				if (TruePlayerLevel >= 120) CandleFactor = ((random(5,15) * 0.025) + (TruePlayerLevel * (random(14,16) * 0.0035)));
				else if (TruePlayerLevel >= 45) CandleFactor = ((random(1,10) * 0.02) + (TruePlayerLevel * (random(9,11) * 0.003)));
				else CandleFactor = ((random(1,5) * 0.01) + (TruePlayerLevel * (random(3,5) * 0.0025)));
				if (CandleFactor > 1.00) CandleFactor = 1.00;
			}
			if (CandlePuff(inflictor) || CandlePuff(source) || WhipPuff(inflictor) || WhipPuff(source)) ActorDefenseIgnoreFactor += (CandleFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double FCandleFactor = 0.00;
			if (MiscItem)
			{
				if (TruePlayerLevel >= 120) FCandleFactor = ((random(5,15) * 0.125) + (TruePlayerLevel * (random(14,16) * 0.0175)));
				else if (TruePlayerLevel >= 45) FCandleFactor = ((random(1,10) * 0.1) + (TruePlayerLevel * (random(9,11) * 0.015)));
				else FCandleFactor = ((random(1,5) * 0.05) + (TruePlayerLevel * (random(3,5) * 0.0125)));
				if (FCandleFactor > 1.00) FCandleFactor = 1.00;
			}
			if (CandleShot(inflictor) ||
					CandleShotIP(inflictor) ||
					CandleShotIcy(inflictor) ||
					CandleShotIcyIP(inflictor) ||
					CandleTrail(inflictor) ||
					CandleTrailIP(inflictor) ||
					CandleTrailIcy(inflictor) ||
					CandleTrailIcyIP(inflictor)) ActorDefenseIgnoreFactor += (FCandleFactor * (1.00 - ActorDefenseIgnoreFactor));

			double SuckFactor = 0.75;
			if (bBOSS) 
			{
				SuckFactor = 0.334;
				if (inflictor && DDPlayerPawn(inflictor)) SuckFactor = 0.334 + (TruePlayerLevel * 0.001);
				else if (source && DDPlayerPawn(source)) SuckFactor = 0.334 + (TruePlayerLevel * 0.001);
				
			}
			else
			{
				SuckFactor = 0.75;
				if (inflictor && DDPlayerPawn(inflictor)) SuckFactor = 0.75 + (TruePlayerLevel * 0.0025);
				else if (source && DDPlayerPawn(source)) SuckFactor = 0.75 + (TruePlayerLevel * 0.0025);
			}
			if (mod == 'Suck') ActorDefenseIgnoreFactor += (SuckFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double PuddingFactor = 0.667;
			if (PuddingDog(inflictor) || PuddingPup(inflictor) || PupGrenade(inflictor) || PuddingDog(source) || PuddingPup(source) || PupGrenade(source)) ActorDefenseIgnoreFactor += (PuddingFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double RailFactor = frandom(0.3,0.334);
			if (mod == 'Railgun') ActorDefenseIgnoreFactor += (RailFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double AngelFactor = 0.00;
			if ((source && PushyArchAngel(source)) || (inflictor && PushyArchAngel(inflictor)))
			{
				if (angvstype == 0) ActorDefenseIgnoreFactor += (frandom(0.000,0.250) * (1.00 - ActorDefenseIgnoreFactor));
				if (angvstype == 1) ActorDefenseIgnoreFactor += (1.000 * (1.00 - ActorDefenseIgnoreFactor));
				if (angvstype == 2) ActorDefenseIgnoreFactor += (0.500 * (1.00 - ActorDefenseIgnoreFactor));
				if (angvstype == 3) ActorDefenseIgnoreFactor += (0.250 * (1.00 - ActorDefenseIgnoreFactor));
				if (angvstype == 4) ActorDefenseIgnoreFactor += (0.750 * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			if (bellefishzap) ActorDefenseIgnoreFactor += (0.334 * (1.00 - ActorDefenseIgnoreFactor));
				
			if (BarrierBeam(inflictor) || BarrierBeam(source)) ActorDefenseIgnoreFactor += (frandom(0.9,1.0) * (1.00 - ActorDefenseIgnoreFactor));
			
			double CricketFactor = 0.00;
			if ((inflictor && DDPlayerPawn(inflictor)) ||
					(source && DDPlayerPawn(source)))
			{
				double temp = (TruePlayerLevel * 0.005);
				if (temp > 1.00) temp = 1.00;
				CricketFactor += (temp * (1.00 - CricketFactor));
			}
			else
			if ((inflictor && Hammerduck(inflictor)) ||
					(source && Hammerduck(source)))
			{
				double temp = (CountInv("MonsterLevel") * 0.0025);
				if (temp > 0.50) temp = 0.50;
				CricketFactor += (temp * (1.00 - CricketFactor));
			}
			if (IPAtk && IPAtk.IPAttack) CricketFactor += (0.875 * (1.00 - CricketFactor));
			ActorDefenseIgnoreFactor += (CricketFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			if (inflictor && 
					(inflictor.GetClassName() == "SoulScepterPuff" ||
					 inflictor.GetClassName() == "DualSoulScepterPuff" ||
					 inflictor.GetClassName() == "SoulScepterPuff2" ||
					 inflictor.GetClassName() == "SoulScepterPowerPuff" ||
					 inflictor.GetClassName() == "DualSoulScepterPowerPuff"))
			{
				ActorDefenseIgnoreFactor += (0.50 * (1.00 - ActorDefenseIgnoreFactor));
			}

			double SpinAtkFactor = 0.8;
			if (BatSpinPuff(inflictor) || BatSpinPuff(source) ||
					BatSpinPuffIP(inflictor) || BatSpinPuffIP(source) ||
					BatSpinPuffNoSound(inflictor) || BatSpinPuffNoSound(source) ||
					BatSpinPuffNoSoundIP(inflictor) || BatSpinPuffNoSoundIP(source)) ActorDefenseIgnoreFactor += (SpinAtkFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			double HWShieldFactor = 0.125;
			if (EvilWarriorShieldBall(inflictor) || EvilWarriorShieldBall(source) ||
					HellWarriorBall2(inflictor) || HellWarriorBall2(source)) ActorDefenseIgnoreFactor += (HWShieldFactor * (1.00 - ActorDefenseIgnoreFactor));
			
			DDPlayerPawn FoundPlayer;
			FoundPlayer = DDPlayerPawn(source);
			if (!FoundPlayer) FoundPlayer = DDPlayerPawn(inflictor);
			if (FoundPlayer)
			{
				double EggFactor = 0.00;
				if ((EggShot(inflictor) || EggShot(source))) EggFactor = 0.125;
				if ((EggGrenade(inflictor) || EggGrenade(source))) EggFactor = 0.334;
				if ((EggMini(inflictor) || EggMini(source))) EggFactor = 0.75;
				if (EggFactor > 0.00) ActorDefenseIgnoreFactor += (EggFactor * (1.00 - ActorDefenseIgnoreFactor));
				
				double FoodFactor = 0.00;
				IF (FoundPlayer.CountInv("PowerRoastBuff")) FoodFactor += 0.0625; // Pig Roast
				IF (FoundPlayer.CountInv("PowerMealBuff")) FoodFactor += 0.25; // Gourmet Meal
				IF (FoundPlayer.CountInv("PowerMeal2Buff")) FoodFactor += 0.0625; // Turkey Dinner
				if (FoodFactor > 0.00) ActorDefenseIgnoreFactor += (FoodFactor * (1.00 - ActorDefenseIgnoreFactor));
			}
			
			if (mod == 'Dashing') ActorDefenseIgnoreFactor += (0.2 * (1.00 - ActorDefenseIgnoreFactor));
			if (mod == 'DashingBG') ActorDefenseIgnoreFactor += (0.375 * (1.00 - ActorDefenseIgnoreFactor));
			if (mod == 'DashingSD') ActorDefenseIgnoreFactor += (0.375 * (1.00 - ActorDefenseIgnoreFactor));
			
			if (mod == 'Massacre') ActorDefenseIgnoreFactor += (1.00 * (1.00 - ActorDefenseIgnoreFactor));
			
			if (surprisehit) ActorDefenseIgnoreFactor += ((random(6,8) * 0.125) * (1.00 - ActorDefenseIgnoreFactor));
			
			if (CountInv("PWDefenseBuff") > 0) ActorDefenseIgnoreFactor *= 0.25;
		}

		return prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor;
	}
	
	int A_CheckTargType(actor input)
	{
		int type = 0;
		// Doom-type
		if (Zombieman(input) || ZombiemanNew(input)) type = 2; // Zombie/Undead
		if (PlasmaGuy(input)) type = 2; // Zombie/Undead
		if (RepeaterZombie(input)) type = 2; // Zombie/Undead
		if (KarasawaGuy(input)) type = 2; // Zombie/Undead
		if (RocketLauncherGuy(input)) type = 2; // Zombie/Undead
		if (ShotgunGuy(input) || ShotgunGuyNew(input)) type = 2; // Zombie/Undead
		if (SuperShotgunGuy(input)) type = 2; // Zombie/Undead
		if (FemaleRailZombie(input)) type = 2; // Zombie/Undead
		if (ChaingunGuy(input) || ChaingunGuyNew(input)) type = 2; // Zombie/Undead
		if (Minigunner(input)) type = 2; // Zombie/Undead
		if (BFGGuy(input)) type = 2; // Zombie/Undead
		if (SuicideBomber(input)) type = 2; // Zombie/Undead
		if (DoomImp(input) || DoomImpNew(input)) type = 1; // Demonic
		if (NetherDarkImp(input)) type = 1; // Demonic
		if (Demon(input) || DemonNew(input)) type = 1; // Demonic
		if (BloodDemon(input)) type = 1; // Demonic
		if (LostSoul(input) || LostSoulNew(input) || LostSoulAnnoying(input) || BetaLostSoul(input)) type = 1; // Demonic
		if (Cacodemon(input) || CacodemonNew(input)) type = 1; // Demonic
		if (Cacolantern(input)) type = 1; // Demonic
		if (Abaddon(input)) type = 1; // Demonic
		if (PainElemental(input) || PainElementalNew(input)) type = 1; // Demonic
		if (Arachnotron(input) || ArachnotronNew(input) || RailArachnotron(input) || FusionArachnotron(input) || ArachnotronMK2(input)) type = 1; // Demonic
		if (Revenant(input) || RevenantNew(input)) type = 2; // Zombie/Undead
		if (DeathIncarnate(input)) type = 2; // Zombie/Undead
		if (Fatso(input) || MancubusNew(input)) type = 1; // Demonic
		if (Hectebus(input)) type = 1; // Demonic
		if (Daedabus(input)) type = 1; // Demonic
		if (HellKnight(input) || HellKnightNew(input)) type = 1; // Demonic
		if (BaronOfHell(input) || BaronOfHellNew(input)) type = 1; // Demonic
		if (Belphegor(input)) type = 1; // Demonic
		if (HellWarrior(input)) type = 1; // Demonic
		if (BruiserDemon(input)) type = 1; // Demonic
		if (Cybruiser(input)) type = 1; // Demonic
		if (ArchonOfHell(input)) type = 1; // Demonic
		if (PyroDemon(input)) type = 1; // Demonic
		if (Archvile(input) || ArchvileNew(input)) type = 1; // Demonic
		if (Diabloist(input)) type = 1; // Demonic
		if (Cyberdemon(input) || CyberdemonNew(input) || Annihilator(input)) type = 1; // Demonic
		if (SpiderMastermind(input) || SpiderMastermindNew(input) || Demolisher(input)) type = 1; // Demonic
		if (FlyingBalrog(input) || FlyingBalrogDVDS(input)) type = 1; // Demonic
		if (HellCleric(input) || HellClericDVDS(input)) type = 3; // Human/Demon
		if (HadesSphere(input)) type = 4; // Hades Scion
		if (HSOverlord(input)) type = 4; // Hades Scion
		if (HadesElemental(input)) type = 4; // Hades Scion
		if (HadesOverlord(input)) type = 4; // Hades Scion
		// Heretic/Hexen [tbc]
		// Strife [tbc]
		// DD/AFD/COS
		if (Hammerduck(input)) type = 5; // Creature
		if (Planter(input) || PlanterBird(input)) type = 6; // Inanimate/Creature
		if (Manchineel(input) || Manchineel_Ceiling(input)) type = 6; // Inanimate/Creature
		if (Centaurion(input) || CentaurionSgt(input)) type = 5; // Creature
		if (PuddingPup(input) || PuddingDog(input)) type = 6; // Inanimate/Creature
		if (Vitriola(input)) type = 6; // Inanimate/Creature
		if (Killetante(input)) type = 6; // Inanimate/Creature
		if (Muddernaut(input)) type = 5; // Creature
		if (Jugger(input)) type = 6; // Inanimate/Creature
		if (Juggette(input)) type = 6; // Inanimate/Creature
		if (ReelHeel(input) || ReelHeelNew(input)) type = 6; // Inanimate/Creature
		if (Knucklehead(input)) type = 6; // Inanimate/Creature
		if (SpiderCenser(input)) type = 6; // Inanimate/Creature
		if (Galgoyle(input)) type = 7; // Inanimate/Demonic
		if (Shillfish(input) || Shillfish_Fly(input)) type = 5; // Creature
		if (Bellefish(input) || Bellefish_Fly(input)) type = 5; // Creature
		if (RoseMother(input) || RoseMotherClone(input)) type = 11; // Avataric
		if (GameMother(input) || GameMotherClone(input)) type = 11; // Avataric
		if (GlobeMother(input) || GlobeMotherClone(input)) type = 11; // Avataric
		if (MossMother(input) || MossMotherClone(input)) type = 11; // Avataric
		if (SphinxMother(input) || SphinxMotherClone(input)) type = 11; // Avataric
		if (HandMotherVac(input) || HandMotherVacClone(input) ||
				HandmotherPhaseA(input) || HandmotherPhaseAClone(input) ||
				HandmotherPhaseB(input) || HandmotherPhaseBClone(input) ||
				HandmotherPhaseC(input) || HandmotherPhaseCClone(input)) type = 11; // Avataric
		if (SugarSnake(input) || MiniSugarSnake(input)) type = 5; // Creature
		if (Teacher_Krag(input) || Teacher_KragClone(input)) type = 8; // Human
		if (Teacher_Quis(input) || Teacher_QuisClone(input) ||
				QuisFake(input) || QuisFakeClone(input)) type = 8; // Human
		if (Teacher_Lauritz(input) || Teacher_LauritzClone(input)) type = 8; // Human
		if (Nurse(input)) type = 8; // Human
		if (Teacher_Jorg(input) || Teacher_JorgClone(input)) type = 8; // Human
		if (Teacher_Vokter(input) || Teacher_VokterClone(input)) type = 8; // Human
		if (VokterCannon(input) || VokterCannon_Flipped(input)) type = 9; // Full Mechanical
		if (JorgSphereCannon(input)) type = 9; // Full Mechanical

		if (EvilDinah(input)) type = 8; // Human
		if (FractalChicken(input) || FractalChick(input) || FractalHen(input)) type = 5; // Creature
		if (CremeDeBratte(input) || CremeDeBratte_Torched(input)) type = 6; // Inanimate/Creature
		if (PushyAngel(input)) type = 10; // Angelic/Heavenly
		if (Devil(input)) type = 1; // Demonic
		if (Reaper(input)) type = 1; // Demonic
		if (Forsaken(input) || Forsaken_Quisling(input) || Forsaken_Jorgensen(input)) type = 2; // Demonic
		// type = 8; // Human
		// type = 8; // Human
		// EE Unique
		if (PushyArchAngel(input)) type = 42; // Eeeugh? V:
		if (KilletanteSoloist(input)) type = 42; // Eeeugh? V:
		return type;
	}
	
	Actor, Actor, int, Name, int, double, int CheckMonType(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		DDPlayerPawn playpawn;
		playpawn = DDPlayerPawn(source);
		
		EECreature selfEE;
		selfEE = EECreature(self);
		
		int angvstype;
		
		if (Tempest_BossClone(self))
		{
			if (mod == 'HeelExplosion' || (source && (ReelHeel(source) || ReelHeelNew(source)))) damage *= 2.5;
			else
			{
				if ((source && source.master && source.master == self) || (inflictor && inflictor.master && inflictor.master == self))
				{
					damage = 0;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
				else
				if ((source && source.bBOSS) || (inflictor && inflictor.bBOSS))
				{
					damage *= 0.25;
					if (flags & DMG_EXPLOSION) damage *= 0.25;
					if (health <= ((SpawnHealth() + Stamina) * 0.25))
					{
						damage *= 0.25;
						if (flags & DMG_EXPLOSION) damage *= 0.25;
					}
				}
			}
		}
		
		// LOLE Joke Item. Partial thanks to Naka Teleeli for the inspiration. V:
		if (mod == 'LOLEBowling' && !bFRIENDLY) 
		{
			damage = 1872; // 18 * 8 * 13;
			if (DDOrigBoss(self)) damage *= 1024;
											 else damage *= 128;
			if (flags & !DMG_NO_PROTECT) flags |= DMG_NO_PROTECT;
			if (flags & !DMG_NO_FACTOR) flags |= DMG_NO_FACTOR;
			if (flags & !DMG_NO_ARMOR) flags |= DMG_NO_ARMOR;
			if (flags & !DMG_FOILINVUL) flags |= DMG_FOILINVUL;
			if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
		}
		
		Delila_BossClone DBC;
		DBC = Delila_BossClone(self);
		if (DBC)
		{
			if (mod == 'LOLEBowling') { } // Nope, even NoU can't block the bowling ball joke projectile V:
			{
				if (DBC.NoUCooldown > 0) DBC.NoUCooldown *= 0.875;
				let NoU = D_NoUCard(DBC.FindInventory("D_NoUCard"));
				if (NoU)
				{
					DBC.A_StopSound(104);
					DBC.A_StartSound("ReflectDmg1",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
					flags |= DMG_NO_ARMOR;
					flags |= DMG_NO_PROTECT;
					flags |= DMG_THRUSTLESS;
					//Console.Printf("NoU Found!");
					if (source && source != self)
					{
						//Console.Printf("NoU Found! [source]");
						source.A_StopSound(104);
						source.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
						source.DamageMobj(self, self, damage, mod, flags, angle);
					}
					else
					{
						if (inflictor && inflictor != self)
						{
							//Console.Printf("NoU Found! [inflictor]");
							inflictor.A_StopSound(104);
							inflictor.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
							inflictor.DamageMobj(self, self, damage, mod, flags, angle);
						}
					}
					damage = 0;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
				else
				{
					if ((source && source.bBOSS) || (inflictor && inflictor.bBOSS))
					{
						damage *= 0.25;
						if (flags & DMG_EXPLOSION) damage *= 0.25;
						if (health <= ((SpawnHealth() + Stamina) * 0.25))
						{
							damage *= 0.25;
							if (flags & DMG_EXPLOSION) damage *= 0.25;
						}
					}
					if ((source && BadZapShot(source)) || (inflictor && BadZapShot(inflictor)))
					{
						damage = 0;
						return inflictor, source, -1, mod, flags, angle, angvstype;
					}
					if ((source && source.master && source.master == self) || (inflictor && inflictor.master && inflictor.master == self))
					{
						damage = 0;
						return inflictor, source, -1, mod, flags, angle, angvstype;
					}
				}
			}
		}

		DelilaDorsey_HelperFriend DBC2;
		DBC2 = DelilaDorsey_HelperFriend(self);
		if (DBC2)
		{
			if (mod == 'LOLEBowling') // Because this is a helper ally, the bowling ball doesn't damage them V:
			{
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}
			if (DBC2.NoUCooldown > 0) DBC2.NoUCooldown *= 0.875;
			let NoU = D_NoUCard(DBC2.FindInventory("D_NoUCard"));
			if (NoU)
			{
				DBC2.A_StopSound(104);
				DBC2.A_StartSound("ReflectDmg1",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
				flags |= DMG_NO_ARMOR;
				flags |= DMG_NO_PROTECT;
				flags |= DMG_THRUSTLESS;
				//Console.Printf("NoU Found!");
				if (source && source != self)
				{
					//Console.Printf("NoU Found! [source]");
					source.A_StopSound(104);
					source.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
					source.DamageMobj(self, self, damage, mod, flags, angle);
				}
				else
				{
					if (inflictor && inflictor != self)
					{
						//Console.Printf("NoU Found! [inflictor]");
						inflictor.A_StopSound(104);
						inflictor.A_StartSound("ReflectDmg2",104,CHANF_DEFAULT,1.5,ATTN_NORM,frandom(0.875,1.125));
						inflictor.DamageMobj(self, self, damage, mod, flags, angle);
					}
				}
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}
			else
			{
				if ((source && source.bBOSS) || (inflictor && inflictor.bBOSS))
				{
					damage *= 0.25;
					if (flags & DMG_EXPLOSION) damage *= 0.25;
					if (health <= ((SpawnHealth() + Stamina) * 0.25))
					{
						damage *= 0.25;
						if (flags & DMG_EXPLOSION) damage *= 0.25;
					}
				}
				if ((source && BadZapShot(source)) || (inflictor && BadZapShot(inflictor)))
				{
					damage = 0;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
				if ((source && source.master && source.master == self) || (inflictor && inflictor.master && inflictor.master == self))
				{
					damage = 0;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
			}
		}
		
		if (DDOrigBoss(self) && !(Delila_BossClone(self) || Tempest_BossClone(self)))
		{
			if ((source && source.bBOSS) || (inflictor && inflictor.bBOSS))
			{
				damage *= 0.5;
				if (flags & DMG_EXPLOSION) damage *= 0.5;
				if (health <= ((SpawnHealth() + Stamina) * 0.5))
				{
					damage *= 0.5;
					if (flags & DMG_EXPLOSION) damage *= 0.5;
				}
			}
		}
		
		if (HellClericDVDS(self))
		{
			if ((source && Shillfish(source)) || (inflictor && Shillfish(inflictor))) 
			{
				damage *= 12.5;
				damage += ((SpawnHealth() + Stamina) * frandompick(0.25,0.334,0.5));
			}
		}
		if (Shillfish(self))
		{
			ShillFish SF;
			SF = Shillfish(self);
			if (source && PlayerPawn(source)) 
			{
				if (mod == 'Melee' || mod == 'Fist' || mod == 'Kick')
				{
					if (SF && random(1,16) <= random(3,4) && target == source) SF.surpriselol += random(0,5);
				}
			}
			else
			{
				if (inflictor && PlayerPawn(inflictor)) 
				{
					if (mod == 'Melee' || mod == 'Fist' || mod == 'Kick')
					{
						if (SF && random(1,16) <= random(3,4) && target == inflictor) SF.surpriselol += random(0,5);
					}
				}
			}
			
			if (source && HellClericDVDS(source)) 
			{
				if (mod == 'Melee') damage *= 0.4;
				damage *= 0.08;
				if (damage < 1) damage = 1;
				target = source;
				if (SF) SF.surpriselol = 1;
			}
			else
			{
				if (inflictor && HellClericDVDS(inflictor))
				{
					if (mod == 'Melee') damage *= 0.4;
					damage *= 0.08;
					if (damage < 1) damage = 1;
					target = inflictor;
					if (SF) SF.surpriselol = 1;
				}
			}
		}

		if (Reaper(self))
		{
			if ((source && Reaper(source)) || (inflictor && Reaper(inflictor)))
			{
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}

			if (source)
			{
				int type = A_CheckTargType(source);
				if (type == 1) damage /= frandompick(2.5,2.75,3.0); // Demonic foes
				if (type == 2) damage /= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
				if (type == 3) damage /= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
				if (type == 4) damage /= frandompick(2.125,2.3125,2.5); // Hades Scion foes
				
				if (target)
				{
					if (PlayerPawn(target))
					{
						if (type == 1 && random(1,100) <= 95) target = source;
						if (type == 2 && random(1,100) <= 45) target = source;
						if (type == 3 && random(1,100) <= 20) target = source;
						if (type == 4 && random(1,100) <= 70) target = source;
					}
					else
					{
						if (type == 1 && random(1,100) <= 80) target = source;
						if (type == 2 && random(1,100) <= 30) target = source;
						if (type == 3 && random(1,100) <= 5) target = source;
						if (type == 4 && random(1,100) <= 55) target = source;
					}
				}
			}
			else
			if (inflictor)
			{
				int type = A_CheckTargType(inflictor);
				if (type == 1) damage /= frandompick(2.5,2.75,3.0); // Demonic foes
				if (type == 2) damage /= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
				if (type == 3) damage /= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
				if (type == 4) damage /= frandompick(2.125,2.3125,2.5); // Hades Scion foes
					
				if (target)
				{
					if (PlayerPawn(target))
					{
						if (type == 1 && random(1,100) <= 95) target = inflictor;
						if (type == 2 && random(1,100) <= 45) target = inflictor;
						if (type == 3 && random(1,100) <= 20) target = inflictor;
						if (type == 4 && random(1,100) <= 70) target = inflictor;
					}
					else
					{
						if (type == 1 && random(1,100) <= 80) target = inflictor;
						if (type == 2 && random(1,100) <= 30) target = inflictor;
						if (type == 3 && random(1,100) <= 5) target = inflictor;
						if (type == 4 && random(1,100) <= 55) target = inflictor;
					}
				}
			}
		}
		
		if (PushyArchAngel(self))
		{
			if (source)
			{
				if (flags & DMG_EXPLOSION)
				{
					if (PlayerPawn(Source)) damage *= frandom(0.95,1.00);
														 else damage *= frandom(0.00,0.05);
				}
				int type = A_CheckTargType(source);
				if (type == 1) damage /= frandompick(2.5,2.75,3.0); // Demonic foes
				if (type == 2) damage /= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
				if (type == 3) damage /= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
				if (type == 4) damage /= frandompick(2.125,2.3125,2.5); // Hades Scion foes
				if (FlyingBalrog(source) || FlyingBalrogDVDS(source))
				{
					damage = 0;
					target = source;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
				else
				{
					if (AAngelSong(source) || BadZapShot(source) || MusicBall2(source))
					{
						damage = 0;
						return inflictor, source, -1, mod, flags, angle, angvstype;
					}
					
					if (target)
					{
						if (PlayerPawn(target))
						{
							if (type == 1 && random(1,100) <= 95) target = source;
							if (type == 2 && random(1,100) <= 45) target = source;
							if (type == 3 && random(1,100) <= 20) target = source;
							if (type == 4 && random(1,100) <= 70) target = source;
						}
						else
						{
							if (type == 1 && random(1,100) <= 80) target = source;
							if (type == 2 && random(1,100) <= 30) target = source;
							if (type == 3 && random(1,100) <= 5) target = source;
							if (type == 4 && random(1,100) <= 55) target = source;
						}
					}
				}
			}
			else
			if (inflictor)
			{
				if (flags & DMG_EXPLOSION)
				{
					if (PlayerPawn(inflictor)) damage *= frandom(0.95,1.00);
																else damage *= frandom(0.00,0.05);
				}
				int type = A_CheckTargType(inflictor);
				if (type == 1) damage /= frandompick(2.5,2.75,3.0); // Demonic foes
				if (type == 2) damage /= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
				if (type == 3) damage /= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
				if (type == 4) damage /= frandompick(2.125,2.3125,2.5); // Hades Scion foes
				if (FlyingBalrog(inflictor) || FlyingBalrogDVDS(inflictor))
				{
					damage = 0;
					target = inflictor;
					return inflictor, source, -1, mod, flags, angle, angvstype;
				}
				else
				{
					if (AAngelSong(inflictor) || BadZapShot(inflictor) || MusicBall2(inflictor))
					{
						damage = 0;
						return inflictor, source, -1, mod, flags, angle, angvstype;
					}
					
					if (target)
					{
						if (PlayerPawn(target))
						{
							if (type == 1 && random(1,100) <= 95) target = inflictor;
							if (type == 2 && random(1,100) <= 45) target = inflictor;
							if (type == 3 && random(1,100) <= 20) target = inflictor;
							if (type == 4 && random(1,100) <= 70) target = inflictor;
						}
						else
						{
							if (type == 1 && random(1,100) <= 80) target = inflictor;
							if (type == 2 && random(1,100) <= 30) target = inflictor;
							if (type == 3 && random(1,100) <= 5) target = inflictor;
							if (type == 4 && random(1,100) <= 55) target = inflictor;
						}
					}
				}
			}
			else
			{
			}
		}
		
		if ((source && Reaper(source)) || (inflictor && Reaper(inflictor)))
		{
			if (Reaper(self))
			{
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}
			angvstype = A_CheckTargType(self);
			if (angvstype == 1) damage *= frandompick(2.5,2.75,3.0); // Demonic foes
			if (angvstype == 2) damage *= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
			if (angvstype == 3) damage *= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
			if (angvstype == 4) damage *= frandompick(2.125,2.3125,2.5); // Hades Scion foes
			if (target)
			{
				if (PlayerPawn(target))
				{
					if (source && Reaper(source))
					{
						if (angvstype == 1 && random(1,100) <= 95) target = source;
						if (angvstype == 2 && random(1,100) <= 45) target = source;
						if (angvstype == 3 && random(1,100) <= 20) target = source;
						if (angvstype == 4 && random(1,100) <= 70) target = source;
					}
					else
					{
						if (inflictor && Reaper(inflictor))
						{
							if (angvstype == 1 && random(1,100) <= 95) target = inflictor;
							if (angvstype == 2 && random(1,100) <= 45) target = inflictor;
							if (angvstype == 3 && random(1,100) <= 20) target = inflictor;
							if (angvstype == 4 && random(1,100) <= 70) target = inflictor;
						}
					}
				}
				else
				{
					if (source && Reaper(source))
					{
						if (angvstype == 1 && random(1,100) <= 80) target = source;
						if (angvstype == 2 && random(1,100) <= 30) target = source;
						if (angvstype == 3 && random(1,100) <= 5) target = source;
						if (angvstype == 4 && random(1,100) <= 55) target = source;
					}
					else
					{
						if (inflictor && Reaper(inflictor))
						{
							if (angvstype == 1 && random(1,100) <= 80) target = inflictor;
							if (angvstype == 2 && random(1,100) <= 30) target = inflictor;
							if (angvstype == 3 && random(1,100) <= 5) target = inflictor;
							if (angvstype == 4 && random(1,100) <= 55) target = inflictor;
						}
					}
				}
			}
		}
		
		if ((source && PushyArchAngel(source)) || (inflictor && PushyArchAngel(inflictor)))
		{
			if (PushyAngel(self) ||
					PushyArchAngel(self))
			{
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}
			else
			{
				angvstype = A_CheckTargType(self);
				if (angvstype == 1) damage *= frandompick(2.5,2.75,3.0); // Demonic foes
				if (angvstype == 2) damage *= frandompick(1.75,1.875,2.0); // Zombie/Undead foes
				if (angvstype == 3) damage *= frandompick(1.375,1.4375,1.5); // Human/Demon hybrid foes
				if (angvstype == 4) damage *= frandompick(2.125,2.3125,2.5); // Hades Scion foes
				//Console.Printf("angvstype: %d", angvstype);
				if (FlyingBalrog(self) || FlyingBalrogDVDS(self))
				{
					damage += ((SpawnHealth() + Stamina) * frandom(2.5,4.5));
				}
				else
				{
					if (target)
					{
						if (PlayerPawn(target))
						{
							if (source && PushyArchAngel(source))
							{
								if (angvstype == 1 && random(1,100) <= 95) target = source;
								if (angvstype == 2 && random(1,100) <= 45) target = source;
								if (angvstype == 3 && random(1,100) <= 20) target = source;
								if (angvstype == 4 && random(1,100) <= 70) target = source;
							}
							else
							{
								if (inflictor && PushyArchAngel(inflictor))
								{
									if (angvstype == 1 && random(1,100) <= 95) target = inflictor;
									if (angvstype == 2 && random(1,100) <= 45) target = inflictor;
									if (angvstype == 3 && random(1,100) <= 20) target = inflictor;
									if (angvstype == 4 && random(1,100) <= 70) target = inflictor;
								}
							}
						}
						else
						{
							if (source && PushyArchAngel(source))
							{
								if (angvstype == 1 && random(1,100) <= 80) target = source;
								if (angvstype == 2 && random(1,100) <= 30) target = source;
								if (angvstype == 3 && random(1,100) <= 5) target = source;
								if (angvstype == 4 && random(1,100) <= 55) target = source;
							}
							else
							{
								if (inflictor && PushyArchAngel(inflictor))
								{
									if (angvstype == 1 && random(1,100) <= 80) target = inflictor;
									if (angvstype == 2 && random(1,100) <= 30) target = inflictor;
									if (angvstype == 3 && random(1,100) <= 5) target = inflictor;
									if (angvstype == 4 && random(1,100) <= 55) target = inflictor;
								}
							}
						}
					}
				}
			}
		}

		if (Devil(self))
		{
			if ((source && PushyAngel(source)) || (inflictor && PushyAngel(inflictor))) damage *= frandompick(2.0,2.25,2.5);
			if ((source && PushyArchAngel(source)) || (inflictor && PushyArchAngel(inflictor)))
			{
				damage *= frandompick(4.0,5.0625,6.25);
			}
		}
		
		if (PushyAngel(self))
		{
			if ((source && Devil(source)) || (inflictor && Devil(inflictor))) damage *= frandompick(2.0,2.25,2.5);
			if ((source && PushyArchAngel(source)) || (inflictor && PushyArchAngel(inflictor)))
			{
				damage = 0;
				return inflictor, source, -1, mod, flags, angle, angvstype;
			}
		}
		
		if (selfEE && EECardSummon(selfEE))
		{
			damage *= frandom(0.35,0.65);
			if (damage <= 1) damage = 1;
		}

		if (selfEE && EvilDinahEE(selfEE)) 
		{
			int olddmg = damage;
			EvilDinah EvDin;
			EvDin = EvilDinah(selfEE);
			if (EvDin && EvDin.lastweaponused == 5 && mod == 'Zap')
			{
				if (!(ddafd_disablepikegiveszapres && A_CheckDDGame()))
				{
					if (!(EvilDinah(source) || DDPlayerPawn(source))) damage *= frandompick(0.1667,0.20,0.20,0.20,0.25,0.25,0.25,0.25,0.25,0.25,0.334,0.334,0.334,0.40);
																											 else damage *= frandompick(0.3334,0.40,0.40,0.40,0.5,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.667,0.80);
					if (dydudebug_actordmgdisplays) Console.Printf("MDamage [ZapShot w/ Pike Equipped]: %d (%d)", damage, olddmg);
				}
			}
			
			damage *= 0.5;
			if (CountInv("MonsterLevel") >= 10) damage *= frandom(0.49,0.51);
			if (CountInv("MonsterLevel") >= 25) damage *= frandom(0.475,0.525);
			if (CountInv("MonsterLevel") >= 45) damage *= frandom(0.455,0.545);
			if (CountInv("MonsterLevel") >= 70) damage *= frandom(0.430,0.570);
			if (CountInv("MonsterLevel") >= 100) damage *= frandom(0.40,0.60);
			if (CountInv("MonsterLevel") >= 135) damage *= frandom(0.365,0.635);
			if (CountInv("MonsterLevel") >= 175) damage *= frandom(0.325,0.675);
			if (damage <= 1) damage = 1;
			if (source && target && source != target)
			{
				if (source.bISMONSTER)
				{
					if (DDPlayerPawn(target) && random(1,256) <= 64) target = source;
					else if (random(1,256) <= 224) target = source;
				}
				else
				if (DDPlayerPawn(source))
				{
					if (random(1,256) <= 248) target = source;
				}
			}
			else
			if (inflictor && target && inflictor != target)
			{
				if (inflictor.bISMONSTER)
				{
					if (DDPlayerPawn(target) && random(1,256) <= 64) target = inflictor;
														else if (random(1,256) <= 224) target = inflictor;
				}
				else
				if (DDPlayerPawn(inflictor))
				{
					if (random(1,256) <= 248) target = inflictor;
				}
			}
		}

		if (selfEE && EEUniqueBoss(selfEE)) 
		{
			nm = "PennywiseBoss";
			string vict = GetClassName();
			if (vict != nm) damage *= 0.5;
		}
		
		return inflictor, source, damage, mod, flags, angle, angvstype;
	}
	
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		double firstdmgfactor = DamageFactor;
		if (dydudebug_actordmgdisplays) Console.Printf("firstdmgfactor: %.8f, DamageFactor: %.8f", firstdmgfactor, DamageFactor);
		if (DeathIncarnate(self))
		{
			if (Wads.CheckNumForName("EE-STAEONS", Wads.ns_global, -1, true) != -1)
			{
				if (mod == 'Zap' || mod == 'Ice') damage *= 2;
			}
		}
		
		if (mewantsacrifice(self))
		{
			if (mod != 'EDSacrifice')
			{
				damage = 0;
				return 0;
			}
			else
			{
				return damage;
			}
		}
		
		DDPlayerPawn playpawn;
		playpawn = DDPlayerPawn(source);
		int previoushealth = health;
		
		if (Wads.CheckNumForName("EE-BLOOM", Wads.ns_global, -1, true) != -1)
		{
			if (mod == 'ZBloodBullet') mod = "Hitscan";
			if (mod == 'axe') mod = "Chop";
			if (mod == 'SpecialFire') mod = 'Fire';
			if (mod == 'Flare') 
			{
				mod = "Fire";
				damage *= 3.0;
			}
			if (mod == 'Blast' || mod == 'CultistTNT') mod = "Explosive";
			if (CountInv("lolewatdisdo")) damage *= frandompick(0.334,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.667);
			if (CountInv("gimmesacrificelule")) 
			{
				if (source && mewantsacrifice(source))
				{
					damage = 0;
					return 0;
					if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Hit by mewantsacrifice [source]", GetClassName());
				}
				else
				if (inflictor && mewantsacrifice(inflictor))
				{
					damage = 0;
					return 0;
					if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Hit by mewantsacrifice [inflictor]", GetClassName());
				}
				else
				{
					double d1, d2, d3;
					if (mod == 'Sigil' || 
							mod == 'SpectralLow') 
					{
						d1 = 2.0;
						d2 = 3.0;
						d3 = 4.0; 
					}
					else
					if (mod == 'Cricket')
					{
						d1 = 1.5;
						d2 = 2.25;
						d3 = 3.0; 
					}
					else
					if (mod == 'Bonk' || 
							mod == 'Breakfast')
					{
						d1 = 1.25;
						d2 = 1.5;
						d3 = 1.75;
					}
					else
					if (mod == 'Popper') 
					{
						d1 = 1.1875;
						d2 = 1.375;
						d3 = 1.5625;
					}
					else
					if (mod == 'Lead' || 
							mod == 'Chop' ||
							mod == 'Suck' ||
							mod == 'Dust')
					{
						d1 = 1.125;
						d2 = 1.25;
						d3 = 1.375;
					}
					else
					if (mod == 'Dashing' || 
							mod == 'DashingBG' || 
							mod == 'DashingSD')
					{
						d1 = 0.9;
						d2 = 1.0;
						d3 = 1.1; 
					}
					else
					if (mod == 'Fire' || 
							mod == 'Ice' || 
							mod == 'CherryBomb' || 
							mod == 'Spinner' || 
							mod == 'BRocket') 
					{
						d1 = 0.8334;
						d2 = 1.0;
						d3 = 1.1667; 
					}
					else
					if (mod == 'Zap' ||
							mod == 'Beats') 
					{
						d1 = 0.667;
						d2 = 0.83334;
						d3 = 1.0; 
					}
					else 
					{
						d1 = 0.5;
						d2 = 0.75;
						d3 = 1.0; 
					}
					damage *= frandompick(d1,d1,d2,d2,d2,d2,d2,d2,d3,d3);
				}
			}
		}

		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		if (player.CountInv("PlayingAugerZenith") && BossBrainNew(self))
		{
			if (level.GetCheckSum() == '8a9a22ba1deb535da066bd947190e677') damage *= 5;
			let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
			return ret;
		}
		
		EECreature selfEE;
		selfEE = EECreature(self);
		
		int angvstype;
		
		bool isCCardsIllusion = false;
		if (bNOBLOOD == true && 
				bNOPAIN == true &&
				bNOTARGETSWITCH == true &&
				bNOINFIGHTING == true &&
				bFULLVOLACTIVE == false && 
				bFULLVOLDEATH == false &&
				bBOSS == false) isCCardsIllusion = true;
		bool isCCardsGhost = false;
		if (bISMONSTER == false &&
				bBRIGHT == true &&
				bNOBLOOD == true &&
				bNOTARGET == true &&
				bNOCLIP == true &&
				bCANUSEWALLS == false &&
				bACTIVATEMCROSS == false &&
				bCANPUSHWALLS == false &&
				bSHOOTABLE == false) isCCardsGhost = true;

		
		[inflictor, source, damage, mod, flags, angle, angvstype] = CheckMonType(inflictor,source,damage,mod,flags,angle);
		if (damage <= -1) return -1;

		//
		if (Level.MapName == "TITLEMAP")
		{
			let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
			return ret;
		}
		bool surprisehit = false;
		if (mod == 'TrueIP' && flags & DMG_EXPLOSION) flags &= ~DMG_EXPLOSION;
		if (mod == 'Beats') 
		{
			flags |= DMG_NO_ARMOR;
			flags |= DMG_THRUSTLESS;
			if (flags & DMG_EXPLOSION) flags &= ~DMG_EXPLOSION;
		}
		if (DDAFDNPC(self) && mod == 'TrueIP') return -1;
		if (EEProp(self) && mod == 'TrueIP') return -1;
		if (source && 
				target != source && 
				(PlayerPawn(source) || source.bFRIENDLY) && 
				!bFRIENDLY && 
				!ExplosiveBarrel(self) && 
				!ExplosiveBarrel2(self) && 
				!Pod(self) &&
				!PracticeTarget(self) &&
				!PracticeTarget2(self) &&
				!EEUniqueBoss(self) &&
				mod != 'TrueIP' &&
				!bDORMANT)
		{
			int initdmg = damage;
			surprisehit = true;
			A_StopSound(32);
			if (InStateSequence(curstate,ResolveState("Spawn")) ||
				  (InStateSequence(curstate,ResolveState("Idle")) && HeresiarchNew(self)))
			{
				A_SetInventory("JustSurprised",1);
				if (exex_hitweaksounds) A_StartSound("Misc/WeaknessHitMid", 32, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
				damage *= frandompick(1.3334,1.50);
			}
			else
			{
				if (exex_hitweaksounds) A_StartSound("Misc/WeaknessHit", 32, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
				damage *= frandompick(1.0667,1.10);
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) surprisehit: damage: %d (initdmg: %d)", GetClassName(), damage, initdmg);
		}

		bool criticalhit = false;
		bool IsPlayerRaven = false;
		DDPlayerPawn FoundPlayer;
		FoundPlayer = DDPlayerPawn(source);
		if (FoundPlayer)
		{
			let RavenItem = PowerRavenInvisibility(FoundPlayer.FindInventory("PowerRavenInvisibility"));
			if (RavenItem) 
			{
				IsPlayerRaven = true;
			}
			else
			{
				let RavenItem = PowerRavenFlight(FoundPlayer.FindInventory("PowerRavenFlight"));
				if (RavenItem) IsPlayerRaven = true;
			}
		}
		else
		{
			FoundPlayer = DDPlayerPawn(inflictor);
			if (FoundPlayer)
			{
				let RavenItem = PowerRavenInvisibility(FoundPlayer.FindInventory("PowerRavenInvisibility"));
				if (RavenItem) 
				{
					IsPlayerRaven = true;
				}
				else
				{
					let RavenItem = PowerRavenFlight(FoundPlayer.FindInventory("PowerRavenFlight"));
					if (RavenItem) IsPlayerRaven = true;
				}
			}
		}
		if (IsPlayerRaven && self.bISMONSTER && !EEUniqueBoss(self))
		{
			if (self.bFLOAT && self.bNOGRAVITY)
			{
				damage *= 0.4;
				if (exex_hitweaksounds) A_StartSound("Misc/ResistanceHitMid", 31, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
			}
			else
			{
				damage *= 2.5;
				if (exex_hitweaksounds) A_StartSound("Misc/WeaknessHitMid", 31, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
			}
		}
		
		if ((BlunderSmokeSmall(inflictor) || BlunderSmokeSmall(source)) ||
				(BlunderSmokeSmallD(inflictor) || BlunderSmokeSmallD(source)) ||
				(BlunderSmokeSmallF(inflictor) || BlunderSmokeSmallF(source)) ||
				(BlunderSmokeSmallH(inflictor) || BlunderSmokeSmallH(source)))
		{
			if (random(1,4) <= random(1,2)) flags &= ~DMG_NO_PROTECT;
			if (random(1,4) <= 2)
			{
				damage *= 0.5;
				if (damage < 1) damage = 1;
			}
			else
			{
				if (random(1,4) <= 2)
				{
					damage *= 2.0;
				}
			}
			if (dydudebug_actordmgdisplays) Console.Printf("Blundershot Smoke");
		}

		int CritRoll;
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		if (FoundPlayer) 
		{
			if (FoundPlayer.CountInv("DealCriticalHit")) 
			{
				criticalhit = true;
				if (bBOSS && random(1,4) >= 2) criticalhit = false;
				else if (mod == 'Beats' && random(1,8) >= 2) criticalhit = false;
			}
			else
			{
				If (MiscItem)
				{
					CritRoll = MiscItem.CritRoll;
					if (CountInv("BlunderHelmSplitter")) CritRoll *= 0.9275;
					if (CountInv("BlunderHelmSplitter2")) CritRoll *= 0.85;
					if (CountInv("BlunderHelmSplitter3")) CritRoll *= 0.7775;
					if (MiscItem.CritRoll <= 1) 
					{
						criticalhit = true;
						if (bBOSS && random(1,4) >= 2) criticalhit = false;
						else if (mod == 'Beats' && random(1,8) >= 2) criticalhit = false;
					}
				}
			}
			if (dydudebug_actordmgdisplays && MiscItem) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): Critbase: %d / %d", GetClassName(), MiscItem.CritChance, CritRoll);
		}
		
		initdmg = damage;
		if (dydudebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): initdmg vs Damage: %d vs %d (damagefactor: %.8f)", GetClassName(), initdmg, damage, damagefactor);
		double critdmgmulti = 2.0 + (0.01 * random(-10,10));
		if (criticalhit)
		{
			A_SetInventory("TookCriticalHit",1);
			damage *= critdmgmulti;
			if (dydudebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin] (\c[green]%s\c-): Critical Hit Dealth: %d vs %d (damagefactor: %.8f)", GetClassName(), initdmg, damage, damagefactor);
			A_StartSound("misc/critsnd2", 214, CHANF_DEFAULT, frandom(0.75,1.25), ATTN_NONE, frandom(0.75,1.25));
		}
		int shieldtype;
		if (dydudebug_actordmgdisplays && source) Console.Printf("(\c[green]%s\c-): dmgsource: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), source, source.GetClassName());
		if (dydudebug_actordmgdisplays && inflictor) Console.Printf("(\c[green]%s\c-): dmginflictor: \c[brick]%p\c- (\c[red]%s\c-)", GetClassName(), inflictor, inflictor.GetClassName());
		bool isaghost;
		nm = "CCards_Actor_Ghost"; 
		{
			if (CountInv(nm)) 
			{
				A_SetInventory("CCardGhostMarker",1);
				isaghost = true;
				if (dydudebug_actordmgdisplays) Console.Printf("CCardGhostMarker: %d [health: %d], isaghost: %d", CountInv("CCardGhostMarker"), health, isaghost);
			}
		}
		nm = "CCards_Actor_HasRespawned"; if (CountInv(nm)) A_SetInventory("CCardRespawnedMarker",1);
		nm = "CCards_Actor_AssassinBuff"; if (CountInv(nm)) A_SetInventory("CCardAssassinMarker",1);
		
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) DamageMobj [Mixin]", GetClassName());
		int oldhealth = health;
		initdmg = damage;
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) initdmg: %d, oldhealth: %d", GetClassName(), initdmg, oldhealth);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor != null) lastattackeratk = inflictor;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source != null) lastattacker = source;
		if (source == null) sour = "NONE"; else sour = source.GetClassName();
		
		if (sour == "BlackBearNew" || infl == "BlackBearNew")
		{
			mod = 'Melee';
			flags |= DMG_THRUSTLESS;
			flags &= ~DMG_EXPLOSION;
		}
		
		if (sour == "JSkull_Image1" || sour == "JSkull_Image2" || sour == "JSkull_Image3" ||
				infl == "JSkull_Image1" || infl == "JSkull_Image2" || infl == "JSkull_Image3")
		{
			flags &= ~DMG_NO_ARMOR;
			flags &= ~DMG_NO_PROTECT;
		}
		
		if (CountInv("PWDefenseBuff") > 0) damage *= 0.25;
		nm = "PennywiseBoss";
		if (vict == nm)
		{
			nn = "PennywiseShield"; 
			if (CountInv(nn)) 
			{
				if (mod != 'Deadlight') 
				{
					damage *= 0.334;
					if (mod == 'Beats') damage *= 0.667;
				}
				if (mod == 'Deadlight') damage *= 9;
			}
			nn = "PennywiseNotShield"; 
			if (CountInv(nn)) 
			{
				if (mod != 'Deadlight') 
				{
					damage *= 3;
					if (mod == 'Beats') damage *= 1.5;
				}
				if (mod == 'Deadlight') damage *= 1;
			}
			if (CountInv("PWDefenseBuff"))
			{
				if (mod == 'Deadlight') 
				{
					if (source && source != self) damage *= 4;
				}
			}
			if (dydudebug_actordmgdisplays) Console.Printf("Pennywise Boss Check: %d (%d)", damage, initdmg);
		}

		if (score & 16)
		{
			if (GetRenderStyle() != default.GetRenderStyle())
			{
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) alpha: %.8f, defalpha: %d", GetClassName(), alpha, default.alpha);
				if (infl == "VacPuff" && random(1,8) <= 5) A_SetRenderStyle(default.alpha, default.GetRenderStyle());
			}
		}
		
		if (mod == 'PSI') flags |= DMG_NO_ARMOR;
		bool bellefishzap;
		if (mod == 'Melee' && flags & DMG_EXPLOSION && 
				(BelleFish(Source) || BelleFish(Inflictor)))
		{
			int prevdmg = damage;
			flags |= DMG_THRUSTLESS;
			flags &= ~DMG_EXPLOSION;
			bellefishzap = true;
			if (CountInv("PowerNoDrown")) 
			{
				if (waterlevel >= 2) damage *= 0.4;
												else damage *= 0.94;
			}
			if (waterlevel >= 1) damage *= frandom(1.5,2.5);
			if (dydudebug_actordmgdisplays) Console.Printf("Bellefish Zap Melee damage: %d [%d]", damage, prevdmg);
		}
		if (mod == 'Beats' && flags & DMG_EXPLOSION) flags &= ~DMG_EXPLOSION;
		
		if (ExplosiveBarrelNew(self))
		{
			if (mod == 'Beats' && flags & DMG_EXPLOSION)
			{
				damage = 0;
				return 0;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Barrel Hit by AOE 'Beats'", GetClassName());
			}
			else 
			if (CandlePuff(inflictor) || WhipPuff(inflictor))
			{
				if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
				damage += (SpawnHealth() * 2);
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Barrel Hit by Candle Shot 'Beats'", GetClassName());
			}
		}
		
		if (bDORMANT)
		{
			if (!(mod == "SilentMassacre" || mod == "GrowingPains" || mod == "Massacre" || mod == "InstantDeath")) return 0;
		}

		if (dydudebug_actordmgdisplays)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
		}
		
		if (bFRIENDLY && ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor))))
		{
			actor src;
			if (source) src = PlayerPawn(source);
			if (!source && inflictor) src = PlayerPawn(inflictor);
			damage = 0;
			if (dydudebug_actordmgdisplays) 
			{
				if (src) Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY) [src: \c[brick]%p\c- (\c[red]%s\c-)]", GetClassName(), src, src.GetClassName());
						else Console.Printf("(\c[green]%s\c-) (\czActor Defensive Input [STEP Z]\c-: END DAMAGE ATTEMPT (FRIENDLY)", GetClassName());
			}
			return 0;
		}
		
		bool wasblastedimpact = false;
		if (inflictor == null && source == null && mod == 'Melee') 
		{
			wasblastedimpact = true;
			if (bBLASTED && random(1,20) <= 19) 
			{
				damage *= 0.0625;
				bBLASTED = false;
			}
			else
			{
				damage *= 0.25;
			}
			if (vel.x != 0.0) vel.x *= 0.1;
			if (vel.y != 0.0) vel.y *= 0.1;
			if (dydudebug_actordmgdisplays && wasblastedimpact) Console.Printf("(\c[green]%s\c-) (\czwasblastedimpact?: %d", GetClassName(), wasblastedimpact);
		}
		if (PracticeTarget(self) || PracticeTarget2(self))
		{
			if (targetdummyhitcooldown <= 0) targetdummyhitcooldown = 35;
			if (flags & !DMG_THRUSTLESS) flags |= DMG_THRUSTLESS;
			if (!dydudebug_practicetargetsdebuff)
			{
				if (flags & !DMG_NO_PROTECT) flags |= DMG_NO_PROTECT;
				if (flags & !DMG_NO_ARMOR) flags |= DMG_NO_ARMOR;
			}
			if (flags & !DMG_FOILINVUL) flags |= DMG_FOILINVUL;
		}

		//*******
		//*******
		//*******
		double hndmthslddmg;
		if (HandMotherPhaseAClone(self) ||
				HandMotherPhaseBClone(self) ||
				HandMotherPhaseCClone(self))
		{
			int prevdmg = damage;
			if (CountInv("ShieldEmitter")) 
			{
				hndmthslddmg = frandompick(0.2,0.25,0.25,0.25,0.334);
				damage *= hndmthslddmg;
				shieldtype = 3;
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}
		
		double JorgKilSoloFactor = frandompick(1.5,1.75,1.75,1.75,2.0,2.0,2.0,2.0,2.0,2.0,2.25,2.25,2.25,2.5);
		if (Teacher_JorgClone(self))
		{
			int prevdmg = damage;
			if ((inflictor && KilletanteSoloist(inflictor)) || (source && KilletanteSoloist(source)))
			{
				damage *= JorgKilSoloFactor;
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}
		if (KilletanteSoloist(self))
		{
			int prevdmg = damage;
			if ((inflictor && Teacher_JorgClone(inflictor)) || (source && Teacher_JorgClone(source)))
			{
				damage *= (1.0 / JorgKilSoloFactor);
			}
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) %d (%d)", GetClassName(), damage, prevdmg);
		}

		if (Teacher_VokterClone(self))
		{
			int prevdmg = damage;
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone", GetClassName());
			if (CountInv("VokterCloneShield"))
			{
							 if (mod == 'Cricket') damage *= 0.25;
					else if (mod == 'Dashing') damage *= 1.5;
				else if (mod == 'DashingBG') damage *= 8;
				else if (mod == 'DashingSD') damage *= 4;
																else damage *= 0.0625;
				shieldtype = 1;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Shield 1]: %d (%d)", GetClassName(), damage, prevdmg);
			}
			if (CountInv("VokterCloneShield2")) 
			{
							 if (mod == 'Cricket') damage *= 0.25;
					else if (mod == 'Dashing') damage *= 1.5;
				else if (mod == 'DashingBG') damage *= 8;
				else if (mod == 'DashingSD') damage *= 4;
																else damage *= 0.015625;
				shieldtype = 2;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Shield 2]: %d (%d)", GetClassName(), damage, prevdmg);
			}
			if (CountInv("VokterCloneStun"))
			{
				damage *= 2.5;
				shieldtype = 0;
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Vokter Clone [Stunned]: %d (%d)", GetClassName(), damage, prevdmg);
			}
		}

		if (KilletanteSoloist(self) && IsFrozen())
		{
			damage *= frandompick(0.20,0.25);
			Console.Printf("%s resists your damage due to being frozen in time!", GetTag());
			A_StartSound("misc/ResistanceHit",21,CHANF_DEFAULT,frandom(1.25,1.334),ATTN_NORM,frandom(0.875,1.125));
		}

		// Checks for if you're fighting a Serpent Rider boss
		if (mod != 'Sigil' || mod != 'Massacre' || mod != 'Telefrag') // Make sure the Sigil can deal full damage and ignores this resistance entirely :V
		{
			if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Check for Serpent Rider", GetClassName());
			let SerpentRider = Sorcerer2New(self);
			let SerpentRider2 = KoraxNew(self);
			//let SerpentRider3 = EidolonNew(self); // LUL I wish >.>;
			int prevdmg = damage;
			if (SerpentRider || SerpentRider2) // || SerpentRider3
			{
				if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Serpent Rider", GetClassName());
				// If D'Sparil is hit by Cherry Bombs or Korax is hit by Cricket Balls, IGNORE their increasing resistances entirely :V
				if ((SerpentRider && mod != 'CherryBomb') || (SerpentRider2 && mod != 'Cricket'))
				{
					if (dydudebug_actordmgdisplays && SerpentRider) Console.Printf("(\c[green]%s\c-) D'Spari (Wasn't hit by Cherry Bomb)", GetClassName());
					if (dydudebug_actordmgdisplays && SerpentRider2) Console.Printf("(\c[green]%s\c-) Korax (Wasn't hit by Cricket Ball)", GetClassName());
					let SerpRide = Actor(self);
					if (SerpRide)
					{
						if (health < ((SpawnHealth() + Stamina) >> 1)) // <50%
						{
							if (health < ((SpawnHealth() + Stamina) >> 4)) // <6.25%
							{
								if (health < ((SpawnHealth() + Stamina) >> 9)) // <0.1953125%
								{
									damage *= 0.125;
								}
								else
								{
									damage *= 0.25;
								}
							}
							else
							{
								damage *= 0.50;
							}
						}
					}
					if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Serpent Rider [Damage Resist Buff]: %d (%d)", GetClassName(), damage, prevdmg);
				}
			}
		}

		// Special SuperVac Suck Attack Checks :V
		if (GetClassName() == "BossBrainNew" || GetClassName() == "Sorcerer2New" || GetClassName() == "KoraxNew")
		{
			if (mod == 'Suck' && damage > health)
			{
				if (damage > health) 
				{
					Console.Printf("\c[red]You cannot kill %s with the SuperVac's suck attack! You must use a different weapon to finish it!", GetTag());
					return 0; // The above bosses CANNOT die from the SuperVac
				}
			}
		}

		int predmginr = damage;
		// (Partial) Defense Ignoring Attacks
		double prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor;
		[prevDamageFactor, basedmgfactor, ActorDefenseIgnoreFactor] = A_DefenseIgnoreFactor(inflictor, source, damage, mod, flags, angle, wasblastedimpact, bellefishzap, surprisehit, angvstype);
		
		predmginr = damage;
		// Defense Checks
		if (mod == 'Crush' && !inflictor && !source)
		{
			double basecrushdmgfact;
			if (PowerStrength(FindInventory("PowerStrength")) || PowerStrengthDD(FindInventory("PowerStrengthDD")))
			{
				basecrushdmgfact = frandompick(25,33.4,33.4,50,50,50,50,50,50,66.7,66.7,75);
			}
			else
			{
				basecrushdmgfact = frandompick(75,87.5,87.5,100,100,100,100,100,100,112.5,112.5,125);
			}
			damage *= double(basecrushdmgfact / (mass * frandompick(0.25,0.334,0.334,0.5,0.5,0.5,0.5,0.5,0.667,0.667,0.75)));
			damage *= (basecrushdmgfact * 0.01);
			if (damage <= (predmginr * 0.334)) damage = (predmginr * 0.334);
			if (damage >= (predmginr * 3)) damage = (predmginr * 3);
			
			if (dydudebug_actordmgdisplays && damage > 0)
			{
				Console.Printf("    (\czActor Defensive Input [Crush]\c-: \cydmg = %d\c, prevdmg: %d, basecrushdmgfact: %.8f, mass: %d)", damage, predmginr, basecrushdmgfact, mass);
			}
		}
		
		//******************************
		//*This ignores damage factors *
		//******************************
		if (ActorDefenseIgnoreFactor > 1.00) ActorDefenseIgnoreFactor = 1.00;
		prevDamageFactor = DamageFactor;
		if (DamageFactor < 1.00) 
		{
			if (criticalhit) ActorDefenseIgnoreFactor = 1.00;
			DamageFactor += ((1.00 - DamageFactor) * ActorDefenseIgnoreFactor); 
		}
		if (dydudebug_actordmgdisplays && damage > 0)
		{
			if (ActorDefenseIgnoreFactor > 0.00) Console.Printf("    (\czActor Defensive Input [Def Ignoring]\c-: \caDefenseIgnoreFactor = %.8f\c-, \cadmgfactor = %.8f\c-, \caprevdmgfactor = %.8f\c-, \cypredmg = %d\c-, \cydmg = %d\c- (Monster Actor))", ActorDefenseIgnoreFactor, DamageFactor, prevDamageFactor, predmginr, damage);
																			else Console.Printf("    (\czActor Defensive Input [Def Ignoring]\c-: \caSKIPPED\c-, \cydmg = %d\c-)", predmginr);
		}
		
		EECreature check;
		check = EECreature(self);
		if (PikePuff(inflictor) || PikePuff(source))
		{
			int basepoke = 64;
			if (MiscItem) 
			{
				if (TruePlayerLevel >= 100) basepoke *= 0.375;
				else if (TruePlayerLevel >= 40) basepoke *= 0.75;
			}
			if (PikePuffIP(inflictor) || PikePuffIP(source)) basepoke *= 0.125;
			if (bBOSS || EEUniqueBoss(self)) basepoke *= 4;
			if (CountInv("lolewatdisdo")) basepoke *= 0.25;
			if (CountInv("gimmesacrificelule")) basepoke *= 0.25;

			if (random(1,basepoke) <= 1 || criticalhit || (check && check.MonsterFamily == "Balloon"))
			{
				if (Centaurion(self) && bREFLECTIVE && bINVULNERABLE)
				{
					bREFLECTIVE = false;
					bINVULNERABLE = false;
				}
				mod = 'KillPoke';
				if (CountInv("lolewatdisdo") || CountInv("gimmesacrificelule"))
				{
					damage += (((SpawnHealth() + Stamina) * randompick(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2)) / randompick(2,4,4,8,8,8,8,8,8,8,8,16,16,32));
				}
				else
				if (bBOSS || EEUniqueBoss(self)) 
				{
					damage += (((SpawnHealth() + Stamina) * randompick(1,1,1,1,1,1,1,1,1,2)) / randompick(1,2,2,4,4,4,4,4,4,4,4,8,8,16));
				}
				else 
				{
					if (DeathIncarnate(self)) damage += ((SpawnHealth() + Stamina) * random(7,9));
															 else damage += ((SpawnHealth() + Stamina) * random(3,5));
				}
				A_StartSound("pike/pokeykill",213,CHANF_DEFAULT,1.0,ATTN_NORM,frandom(0.75,1.25));
			}
		}
		
		// Healing from Punching/Kicking Practice Targets ala SW
		if (PracticeTarget(self) || PracticeTarget2(self))
		{
			if ((mod == 'Fist' || mod == 'Kick'))
			{
				if (!(flags & DMG_EXPLOSION))
				{
					double multfactorHP = 1.0;
					int randbonusincreaseHP = randompick(3,3,4) * frandom(3.75,5.25) * frandom(0.5,1.5);
					if (mod == 'Fist' && infl == "UppercutPuff") multfactorHP *= frandompick(1.125,1.1875);
					if (mod == 'Kick') multfactorHP *= frandompick(1.0834,1.1667);
					randbonusincreaseHP *= multfactorHP;
					if (criticalhit) randbonusincreaseHP *= critdmgmulti;
					//if (dydudebug_regenpenaltydisplay) Console.Printf("HPBonusTimeAdd: %d", randbonusincreaseHP);
					if (MiscItem) MiscItem.HPRegenBoostTimer += randbonusincreaseHP;
					
					if (playpawn)
					{
						int prehealth = playpawn.player.mo.health;
						int phealmax;
						if (MiscItem) 
						{
							phealmax = MiscItem.MaxHealthTrue;
							phealmax *= (1.0 + (TruePlayerLevel * 0.005));
							if (phealmax > MiscItem.MaxHealthTrue * 3.0) phealmax = (MiscItem.MaxHealthTrue * 3.0);
						}
						if ((prehealth < phealmax) && random(1,16) <= random(7,9))
						{
							int targhealamt = (randompick(1,1,1,1,1,1,1,1,1,1,1,2) * critdmgmulti * multfactorHP);
							prehealth += targhealamt;
							A_RecoverHUD(targhealamt, 0, true);
							//if ((dvds_showdamagemessages & 1) && targhealamt > 0) A_PrintHealingMessage(playpawn, targhealamt);
							//Console.Printf("prehealth: %d, phealmax: %d, targhealamt: %d", prehealth, phealmax, targhealamt);
							if (prehealth > phealmax) prehealth = phealmax;
							playpawn.player.mo.health = playpawn.player.health = prehealth;
						}
					}
				}
			}
		}

		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Pre-Function Call: damage: %d (initdmg: %d) isaghost: %d", GetClassName(), damage, initdmg, isaghost);
		double ssa = 1.00;
		if (CountInv("ExpeditionHat")) ssa += frandompick(0.03,0.04,0.05);
		if (CountInv("ClassyRibbon")) ssa += frandompick(0.015,0.02,0.025);
		damage *= ssa;
		bool miracle = false;
		if ((CountInv("MiracleBoss") > 0 || CountInv("MiracleMonster") > 0) && exex_monstershavemiracles)
		{
			bBUDDHA = true;
			miracle = true;
		}
		if (mod == 'IceWater') mod = 'Ice';
		//************************************************************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//************************************************************************
		if (miracle && exex_monstershavemiracles)
		{
			if (ret >= previoushealth) 
			{
				int newhealth = (SpawnHealth() + Stamina);
				if (CountInv("MiracleBoss") > 0) newhealth *= frandom(0.75,1.000);
				if (CountInv("MiracleMonster") > 0) newhealth *= frandom(0.334,1.000);
				health = newhealth;
				A_SpawnItemEx("MiracleCircle",0,0,(height*0.5),flags:SXF_NOCHECKPOSITION);
				
				double pitchch = frandom(-0.125,0.125);
				if (CountInv("MiracleMonster") > 0 || CountInv("MiracleBoss") > 0)
				{
					A_StartSound("misc/harpkey",544,CHANF_DEFAULT,1.0,ATTN_NORM,(1.00+pitchch));
					A_StartSound("misc/harpkey",545,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.95,1.05)+pitchch));
				}
				if (CountInv("MiracleBoss") > 0)
				{
					A_StartSound("misc/harpkey",546,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.90,1.10)+pitchch));
					A_StartSound("misc/harpkey",547,CHANF_DEFAULT,1.0,ATTN_NORM,(frandom(0.85,1.15)+pitchch));
				}
				A_GiveInventory("MiraclesUsed",1);
			}
			else miracle = false;
			if (bBUDDHA) bBUDDHA = false;
		}

		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Post-Function Call: ret: %d (pre-function damage: %d) (initdmg: %d), isaghost: %d", GetClassName(), ret, damage, initdmg, isaghost);
		
		// Stun Inflict Items to give if they take damage from specific attacks
		bool givemeleeitem = true;
		if (isCCardsIllusion) givemeleeitem = false;
		if ((isCCardsGhost || isaghost) && health <= 0) givemeleeitem = false;
		if (dydudebug_actordmgdisplays) Console.Printf("givemeleeitem: %d [%p (%s)], isCCardsIllusion: %d, isCCardsGhost: %d, isaghost: %d", givemeleeitem, self, GetClassName(), isCCardsIllusion, isCCardsGhost, isaghost);
		if (givemeleeitem)
		{
			if (!miracle)
			{
				if ((KickPuff(inflictor) || KickPuffNoThrust(inflictor) || BadKickPuff(inflictor) || mod == 'Kick') && ret > 0) A_SetInventory("JustKicked",1);
				if ((UppercutPuff(inflictor) && mod == 'Fist') && ret > 0) A_SetInventory("JustUppercutted",1);
				if ((FistPuff(inflictor) && mod == 'Fist') && ret > 0) A_SetInventory("JustPunched",1);
				if (mod == 'DashingBG' && ret > 0) A_SetInventory("JustBatDashed",1);
				if (mod == 'DashingSD' && ret > 0) A_SetInventory("JustShieldDashed",1);
			}
		}
		
		if (miracle && exex_monstershavemiracles)
		{
			if (CountInv("MiracleBoss") > 0 && random(1,100) <= 90) A_TakeInventory("MiracleBoss",1);
			if (CountInv("MiracleMonster") > 0 && random(1,100) <= 99) A_TakeInventory("MiracleMonster",1);
			miracle = false;
		}
		
		if (ret > 0)
		{
			if (FoundPlayer) 
			{
				if (!bFRIENDLY) A_DynamicMusic(forcedplay:true);
			}
			else
			{
				if (bFRIENDLY)
				{
					if (source)
					{
						if (source.bISMONSTER && !source.bFRIENDLY) A_DynamicMusic(forcedplay:true);
					}
					if (inflictor)
					{
						if (inflictor.bISMONSTER && !inflictor.bFRIENDLY) A_DynamicMusic(forcedplay:true);
					}
				}
				else
				{
					if (source)
					{
						if (source.bISMONSTER && source.bFRIENDLY) A_DynamicMusic(forcedplay:true);
					}
					if (inflictor)
					{
						if (inflictor.bISMONSTER && inflictor.bFRIENDLY) A_DynamicMusic(forcedplay:true);
					}
				}
			}
		}
		
		if ((initdmg > 0 && ret == 0) || bINVULNERABLE || bNODAMAGE)
		{
			if (FoundPlayer) A_DynamicMusic(forcedplay:true);
			bool showdmglog;
			int tempdmgval = 10000;
			double tempdmgfactor = damagefactor;
			damagefactor = 1.0;
			int moddedDMG = ApplyDamageFactor(mod, tempdmgval);
			if (shieldtype > 0)
			{
				if (shieldtype == 1) moddedDMG *= 0.0625;
				if (shieldtype == 2) moddedDMG *= 0.03125;
				if (shieldtype == 3) moddedDMG *= hndmthslddmg;
				if (shieldtype >= 1 && shieldtype <= 2)
				{
					if (Teacher_VokterClone(self))
					{
						if (target && ((source && source == target) || (inflictor && inflictor == target)))
						{
							//Console.Printf("@#@");
							int basetauntchance = 1;
							int basetauntchancemax = 8;
							if (mod == 'Zap') basetauntchance *= random(2,3);
							if (mod == 'Cricket') basetauntchancemax *= random(2,3);
							if (random(1,basetauntchancemax) <= basetauntchance)
							{
								A_StopSound(CHAN_VOICE);
								A_StartSound("vokter/shieldtaunt",CHAN_VOICE);
							}
						}
					}
				}
			}
			damagefactor = tempdmgfactor;
			double outputdmgfactor = 1.0;
			outputdmgfactor *= moddedDMG;
			outputdmgfactor /= tempdmgval;
			if (dydudebug_actordmgdisplays || dydudebug_hitsounds) Console.Printf("(\c[green]%s\c-) moddedDMG: %d (%.8f) (%s), damagefactor: %.8f", GetClassName(), moddedDMG, outputdmgfactor, mod, damagefactor);

			if (exex_monsternodmgvol > 0.0)
			{
				if (moddedDMG <= (tempdmgval * 0.6666667) || bINVULNERABLE || bNODAMAGE)
				{
					if ((source && PlayerPawn(source)) || (inflictor && PlayerPawn(inflictor)))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.8,1,1.25));
					}
					else
					if ((source && source.bFRIENDLY) || (inflictor && inflictor.bFRIENDLY))
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(0.5,0.625,0.78125));
					}
					else
					if (source || inflictor)
					{
						showdmglog = true;
						A_StopSound(14);
						A_StartSound("misc/hitnodmg", 14, CHANF_DEFAULT, (exex_monsternodmgvol * frandom(0.875,1.375)), ATTN_NONE, frandompick(1.1,1.375,1.71875));
					}
				}
			}
			if (exex_combatlog && showdmglog)
			{
				string victname = GetTag();
				string atkrname = "(?)";
				string attkernam;
				if (!GetTag()) victname = vict;
				if (source)
				{
					if (source.GetTag()) attkernam = source.GetTag();
													else attkernam = source.GetClassName();
				}
				if (inflictor)
				{
					if (inflictor.GetTag()) atkrname = inflictor.GetTag();
														 else atkrname = inflictor.GetClassName();
				}
				string comblog = "";
				comblog.AppendFormat("\c[red]*\c- ");
				if (mod == 'NONE') mod = 'Typeless';
				comblog.AppendFormat("\c[red]%s\c-", victname);
				if (bINVULNERABLE) comblog.AppendFormat(" is currently \c[purple]invulnerable\c- from", victname);
											else comblog.AppendFormat(" took \c[purple]no damage\c- from", victname);
				if (inflictor && source && (inflictor != source)) comblog.AppendFormat(" \c[purple]%s's", attkernam);
				if (inflictor) comblog.AppendFormat(" \c[red]%s\c-!", atkrname);
				comblog.AppendFormat(" [\c[lightblue]%s\c-]", mod);
				if (dydudebug_showgametic) comblog.AppendFormat(" [%d]", gametic);
				
				Console.Printf(comblog);
			}
		}
		initdmg = 0;
		
		DamageFactor = firstdmgfactor;
		if (dydudebug_actordmgdisplays) Console.Printf("(\c[green]%s\c-) Wrapping Up: finaldmg: %d, DamageFactor: %.8f, firstdmgfactor: %.8f", GetClassName(), ret, DamageFactor, firstdmgfactor);
		return ret;
	}
	
	override void PostBeginPlay()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);

		BossEyeNew actcheck;
		actcheck = BossEyeNew(self);
		if (actcheck)
		{
			if (exex_improvediconofsin) { actcheck.user_bosseyetype = 1; }
			else { actcheck.user_bosseyetype = 0; }
		}
		Actor bsbrn;
		if (BossBrainNew(self))
		{
			bsbrn = self;
			if (dydudebug_bossbraininfo)
			{
				if (bsbrn) Console.Printf("bsbrn: \c[green]%p\c-", bsbrn);
							else Console.Printf("bsbrn: \c[red]NOT FOUND\c-");
			}
			if (exex_improvediconofsin) 
			{
				int foundspawners;
				int foundspawnspots;
				ThinkerIterator SpawnFinder = ThinkerIterator.Create("BossEye");
				Actor mo;
				while (mo = BossEye(SpawnFinder.Next()))
				{
					foundspawners++;
					mo.master = bsbrn;
					if (dydudebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawners);
						if (mo.master) Console.Printf("BossEye (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossEye (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				SpawnFinder = ThinkerIterator.Create("BossTarget");
				while (mo = BossTarget(SpawnFinder.Next()))
				{
					foundspawnspots++;
					if (bsbrn) mo.master = bsbrn;
					if (dydudebug_bossbraininfo) 
					{
						Console.Printf("%s #%d Found!", mo.GetClassName(), foundspawnspots);
						if (mo.master) Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[gold]%p\c-", mo, mo.master);
											else Console.Printf("BossTarget (\c[green]%p\c-) Master: \c[red]NOT FOUND\c-", mo);
					}
				}
				if (foundspawners && foundspawnspots)
				{
					if (!player.CountInv("PlayingAugerZenith"))
					{
						double levelhpmultfactor = 0.025;
						double leveldmgmultfactor = 0.001667;
						double dmgfactbase = 0.5;
						if (skill <= 0) 
						{
							health *= 4.00;
							levelhpmultfactor = 0.015;
							leveldmgmultfactor = 0.000500;
							dmgfactbase = 0.7;
						}
						if (skill == 1) 
						{
							health *= 4.50;
							levelhpmultfactor = 0.020;
							leveldmgmultfactor = 0.000667;
							dmgfactbase = 0.65;
						}
						if (skill == 2) 
						{
							health *= 5.00;
							levelhpmultfactor = 0.025;
							leveldmgmultfactor = 0.0008334;
							dmgfactbase = 0.6;
						}
						if (skill == 3)
						{
							health *= 5.50;
							levelhpmultfactor = 0.030;
							leveldmgmultfactor = 0.001000;
							dmgfactbase = 0.55;
						}
						if (skill >= 4)
						{
							health *= 6.00;
							levelhpmultfactor = 0.035;
							leveldmgmultfactor = 0.0011667;
							dmgfactbase = 0.5;
						}
						A_SetInventory("BossBrainHolder",1);
						actor player = players[0].mo;
						let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
						if (MiscItem)
						{
							health *= (1.0 + (TruePlayerLevel * levelhpmultfactor));
							damagefactor *= (dmgfactbase - (TruePlayerLevel * leveldmgmultfactor));
							if (dydudebug_bossbraininfo) Console.Printf("Icon of Sin is now stronger!");
						}
					}
				}
			}
		}
		
		//
		if (!(GetRenderStyle() == STYLE_Fuzzy && bSHADOW)) score += 16;
		super.PostBeginPlay();
	}
	
	void A_EEHealThing(int healvalue = 0, int healtarget = 0, int silentheal = 0)
	{
		if (healvalue > 0)
		{
			health += healvalue;
			if (health > healtarget) health = healtarget;
		}
		if (silentheal)
		{
			//if (CountInv("DamageTracker")) A_SetInventory("SilentHeal",1);
		}
	}
}

mixin class EvolveMonsters
{
	action int A_GetEvolveChance()
	{
		int SpawnChance = exex_rnd_evolve;
		return SpawnChance;
	}
}

mixin class IPCostCheck
{
	bool A_CheckDDGameB()
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		if (player.CountInv("IsDynDuchess") || player.CountInv("IsAppetite") || player.CountInv("IsCarnOfSouls") || player.CountInv("IsWeddingCake")) return true;
		return false;
	}
	
	int A_GetPlayerLvl2(int type = 0)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		
		int Level = 0;
		if (MiscItem)
		{
			if (exex_expenabled) 
			{
				if (type == 0) Level = MiscItem.PlayerLevel;
				if (type >= 1) Level = MiscItem.TruePlayerLevel;
			}
			else
			{
				if (A_CheckDDGameB()) Level = MiscItem.TotalNRPGLvlPts;
			}
		}
		//if (dydudebug_playerlevelchecks) Console.Printf("\c[green](%s) \c[gold](A_GetPlayerLvl2 - IPCostCheck mixin)\c- PlayerLevel: %d [%d]", GetClassName(), level, gametic);
		return Level;
	}

	double A_GetIPCost(int ipid = 0, bool sigiluse = false, double sigilcostbase = 3.00)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(player.FindInventory("PlayerStatItem"));
		int TruePlayerLevel = A_GetPlayerLvl2(1);
		double cost;
		int IPUseType;
		
		if (ipid == -1) // Flower Crown "True IP" ability
		{
			if (player) 
			{
				if (MiscItem)
				{
					cost = MiscItem.BaseMaxItemPoints;
				}
				else cost = 999.9;
			}
			else cost = 999.9;
			IPUseType = 6;
		}
		
		if (ipid == 1) // Cherry Bomb [Inventory]
		{
			if (skill <= 0) cost = 25.0;
			if (skill == 1) cost = 27.5;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 32.5;
			if (skill >= 4) cost = 35.0;
			cost *= 0.75;
			IPUseType = 5;
		}
		if (ipid == 2) // Bottle Rocket [Inventory]
		{
			if (skill <= 0) cost = 30.0;
			if (skill == 1) cost = 33.75;
			if (skill == 2) cost = 37.5;
			if (skill == 3) cost = 41.25;
			if (skill >= 4) cost = 45.0;
			IPUseType = 5;
		}
		if (ipid == 3) // Sugar Snake [Inventory]
		{
			if (skill <= 0) cost = 40.0;
			if (skill == 1) cost = 45.0;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 55.0;
			if (skill >= 4) cost = 60.0;
			IPUseType = 5;
		}
		if (ipid == 4) // Spinner Chaser [Inventory]
		{
			if (skill <= 0) cost = 40.0;
			if (skill == 1) cost = 45.0;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 55.0;
			if (skill >= 4) cost = 60.0;
			IPUseType = 5;
		}
		if (ipid == 5) // Killetante Effigy [Inventory]
		{
			if (skill <= 0) cost = 64.0;
			if (skill == 1) cost = 72.0;
			if (skill == 2) cost = 80.0;
			if (skill == 3) cost = 88.0;
			if (skill >= 4) cost = 96.0;
			IPUseType = 5;
		}
		if (ipid == 6) // Scatter Popper [Inventory]
		{
			if (skill <= 0) cost = 27.0;
			if (skill == 1) cost = 28.5;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 31.5;
			if (skill >= 4) cost = 33.0;
			IPUseType = 5;
		}
		if (ipid == 7) // Essence of Fury [Inventory]
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
			IPUseType = 5;
		}
		if (ipid == 8) // Essence of Time [Inventory]
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
			cost *= 1.5;
			IPUseType = 5;
		}
		if (ipid == 9) // Apple Wine [Inventory]
		{
			if (skill <= 0) cost = 17.5;
			if (skill == 1) cost = 18.75;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 21.25;
			if (skill >= 4) cost = 22.5;
			IPUseType = 5;
		}
		if (ipid == 10) // Turkey Dinner [Inventory]
		{
			if (skill <= 0) cost = 17.5;
			if (skill == 1) cost = 18.75;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 21.25;
			if (skill >= 4) cost = 22.5;
			cost *= 1.75;
			IPUseType = 5;
		}
		if (ipid == 11) // Door Bell [Inventory]
		{
			IPUseType = 5;
		}
		if (ipid == 12) // Raven Potion [Inventory]
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
			cost *= 0.667;
			IPUseType = 5;
		}
		
		if (ipid == 101) // Cricket Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
			IPUseType = 1;
		}
		if (ipid == 102) // Cricket Bat Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
			IPUseType = 2;
		}
		if (ipid == 103) // Cricket Bat Spinning Attack [Weapon]
		{
			if (skill <= 0) cost = 33.75;
			if (skill == 1) cost = 39.375;
			if (skill == 2) cost = 45.0;
			if (skill == 3) cost = 50.625;
			if (skill >= 4) cost = 56.25;
			IPUseType = 3;
		}
		
		if (ipid == 111) // Blunderaxe Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
			IPUseType = 1;
		}
		if (ipid == 112) // Blunderaxe Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
			IPUseType = 2;
		}
		
		if (ipid == 121) // Scrambler Main Attack [Weapon]
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
			IPUseType = 1;
		}
		if (ipid == 122) // Scrambler Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 22.5;
			if (skill == 1) cost = 26.25;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 33.75;
			if (skill >= 4) cost = 37.5;
			IPUseType = 2;
		}
		if (ipid == 123) // Scrambler Egg Cook Heal/Buff
		{
			if (skill <= 0) cost = 22.5;
			if (skill == 1) cost = 26.25;
			if (skill == 2) cost = 30.0;
			if (skill == 3) cost = 33.75;
			if (skill >= 4) cost = 37.5;
			cost *= 1.25;
			IPUseType = 3;
		}
		
		if (ipid == 131) // AppleJack Melee Attack [Weapon]
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
			IPUseType = 1;
		}
		if (ipid == 132) // AppleJack Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 15.0;
			if (skill == 1) cost = 17.5;
			if (skill == 2) cost = 20.0;
			if (skill == 3) cost = 22.5;
			if (skill >= 4) cost = 25.0;
			cost *= 0.75;
			IPUseType = 2;
		}
		
		if (ipid == 141) // WizardPike Bat Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 7.5;
			if (skill == 1) cost = 8.75;
			if (skill == 2) cost = 10.0;
			if (skill == 3) cost = 11.25;
			if (skill >= 4) cost = 12.5;
			cost *= 1.25;
			IPUseType = 1;
		}
		if (ipid == 142) // WizardPike Ranged/Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 78.75;
			if (skill == 2) cost = 90.0;
			if (skill == 3) cost = 101.25;
			if (skill >= 4) cost = 112.5;
			if (MiscItem && MiscItem.IPPikePokeTimer) 
			{
				for (int i; i < MiscItem.IPPikePokeTimes; i++) cost *= 0.75;
			}
			IPUseType = 2;
		}
		if (ipid == 143) // WizardPike Inviso Mode IP [Weapon]
		{
			if (skill <= 0) cost = 18.75;
			if (skill == 1) cost = 21.375;
			if (skill == 2) cost = 25.0;
			if (skill == 3) cost = 28.625;
			if (skill >= 4) cost = 31.25;
			cost *= 2.0;
			IPUseType = 3;
		}
		
		if (ipid == 151) // SuperVac Main Attack [Weapon]
		{
			if (skill <= 0) cost = 0.75;
			if (skill == 1) cost = 0.875;
			if (skill == 2) cost = 1.0;
			if (skill == 3) cost = 1.125;
			if (skill >= 4) cost = 1.25;
			cost *= 2;
			IPUseType = 1;
		}
		if (ipid == 152) // SuperVac Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 71.25;
			if (skill == 2) cost = 75.0;
			if (skill == 3) cost = 78.75;
			if (skill >= 4) cost = 82.5;
			IPUseType = 2;
		}
		
		if (ipid == 161) // Grimophone Main Attack [Weapon]
		{
			if (skill <= 0) cost = 5.25;
			if (skill == 1) cost = 6.5625;
			if (skill == 2) cost = 7.5;
			if (skill == 3) cost = 8.4375;
			if (skill >= 4) cost = 9.375;
			IPUseType = 1;
		}
		if (ipid == 162) // Grimophone Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 0.5625;
			if (skill == 1) cost = 0.65625;
			if (skill == 2) cost = 0.75;
			if (skill == 3) cost = 0.84375;
			if (skill >= 4) cost = 0.9375;
			IPUseType = 2;
		}
		
		if (ipid == 171) // CandleWhip Melee/Main Attack [Weapon]
		{
			if (skill <= 0) cost = 8.4375;
			if (skill == 1) cost = 9.84375;
			if (skill == 2) cost = 11.25;
			if (skill == 3) cost = 12.65625;
			if (skill >= 4) cost = 14.0625;
			IPUseType = 1;
		}
		if (ipid == 172) // CandleWhip Alt Attack [Weapon]
		{
			if (skill <= 0) cost = 2.8125;
			if (skill == 1) cost = 3.28125;
			if (skill == 2) cost = 3.75;
			if (skill == 3) cost = 4.21875;
			if (skill >= 4) cost = 4.6875;
			IPUseType = 2;
		}
		
		if (ipid == 181 && sigiluse) // ???
		{
			if (skill <= 0) cost = (sigilcostbase * 1.35);
			if (skill == 1) cost = (sigilcostbase * 1.425);
			if (skill == 2) cost = (sigilcostbase * 1.50);
			if (skill == 3) cost = (sigilcostbase * 1.575);
			if (skill >= 4) cost = (sigilcostbase * 1.65);
			IPUseType = 1;
		}
		
		if (ipid == 191) // Hell Warrior Shield
		{
			if (skill <= 0) cost = 11.25;
			if (skill == 1) cost = 13.125;
			if (skill == 2) cost = 15.0;
			if (skill == 3) cost = 16.875;
			if (skill >= 4) cost = 18.75;
			if (MiscItem) cost *= (1.0 + (MiscItem.HellWarriorShieldLevel * 0.0625));
			cost *= 1.25;
			IPUseType = 1;
		}
		if (ipid == 201) // Fosnian CandleVulcan
		{
			if (skill <= 0) cost = 3.75;
			if (skill == 1) cost = 4.375;
			if (skill == 2) cost = 5.0;
			if (skill == 3) cost = 5.625;
			if (skill >= 4) cost = 6.25;
			Cost *= 1.5;
			IPUseType = 1;
		}
		if (ipid == 211) // CrazyBall
		{
			if (skill <= 0) cost = 37.5;
			if (skill == 1) cost = 43.75;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 56.25;
			if (skill >= 4) cost = 62.5;
			cost *= 1.333;
			IPUseType = 1;
		}
		// Strange Aeons
		if (ipid == 301) // ImpalerXBow
		{
			if (skill <= 0) cost = 37.5;
			if (skill == 1) cost = 43.75;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 56.25;
			if (skill >= 4) cost = 62.5;
			cost *= 0.2;
			IPUseType = 1;
		}
		if (ipid == 302) // ImpalerXBow [altfire]
		{
			if (skill <= 0) cost = 37.5;
			if (skill == 1) cost = 43.75;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 56.25;
			if (skill >= 4) cost = 62.5;
			cost *= 0.5;
			IPUseType = 1;
		}
		if (ipid == 303) // DualImpalerXBow
		{
			if (skill <= 0) cost = 37.5;
			if (skill == 1) cost = 43.75;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 56.25;
			if (skill >= 4) cost = 62.5;
			cost *= 0.4;
			IPUseType = 1;
		}
		if (ipid == 304) // DualImpalerXBow [alt]
		{
			if (skill <= 0) cost = 37.5;
			if (skill == 1) cost = 43.75;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 56.25;
			if (skill >= 4) cost = 62.5;
			IPUseType = 1;
		}
		if (ipid == 311) // ScepterOfSouls
		{
			if (skill <= 0) cost = 3.75;
			if (skill == 1) cost = 4.375;
			if (skill == 2) cost = 5.0;
			if (skill == 3) cost = 5.625;
			if (skill >= 4) cost = 6.25;
			cost *= 0.2;
			IPUseType = 1;
		}
		if (ipid == 312) // ScepterOfSouls [alt]
		{
			if (skill <= 0) cost = 3.75;
			if (skill == 1) cost = 4.375;
			if (skill == 2) cost = 5.0;
			if (skill == 3) cost = 5.625;
			if (skill >= 4) cost = 6.25;
			cost *= 0.5;
			IPUseType = 1;
		}
		if (ipid == 313) // DualScepterOfSouls
		{
			if (skill <= 0) cost = 3.75;
			if (skill == 1) cost = 4.375;
			if (skill == 2) cost = 5.0;
			if (skill == 3) cost = 5.625;
			if (skill >= 4) cost = 6.25;
			cost *= 0.4;
			IPUseType = 1;
		}
		if (ipid == 314) // DualScepterOfSouls [alt]
		{
			if (skill <= 0) cost = 3.75;
			if (skill == 1) cost = 4.375;
			if (skill == 2) cost = 5.0;
			if (skill == 3) cost = 5.625;
			if (skill >= 4) cost = 6.25;
			IPUseType = 1;
		}
		// Circus 2
		if (ipid == 321) // GutFlinger [both]
		{
			if (skill <= 0) cost = 1.875;
			if (skill == 1) cost = 2.1875;
			if (skill == 2) cost = 2.5;
			if (skill == 3) cost = 2.8125;
			if (skill >= 4) cost = 3.125;
			IPUseType = 1;
		}
		if (ipid == 331) // Clown Grenades
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
			IPUseType = 1;
		}
		if (ipid == 341) // Gore Balloon
		{
			if (skill <= 0) cost = 18.75;
			if (skill == 1) cost = 21.875;
			if (skill == 2) cost = 25.0;
			if (skill == 3) cost = 28.125;
			if (skill >= 4) cost = 31.25;
			IPUseType = 1;
		}
		if (ipid == 351) // Gas Rockets
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
			cost *= 0.667;
			IPUseType = 1;
		}
		if (ipid == 361) // Popcorn
		{
			if (skill <= 0) cost = 9.375;
			if (skill == 1) cost = 10.9375;
			if (skill == 2) cost = 12.5;
			if (skill == 3) cost = 14.0625;
			if (skill >= 4) cost = 15.625;
			cost *= 0.125;
			IPUseType = 1;
		}
		
		
		if (ipid == 1001) // Knight Gown
		{
			if (skill <= 0) cost = 45.0;
			if (skill == 1) cost = 47.5;
			if (skill == 2) cost = 50.0;
			if (skill == 3) cost = 52.5;
			if (skill >= 4) cost = 55.0;
			if (player && player.CountInv("KnightGownIP1Buff")) cost *= 3;
			IPUseType = 4;
		}
		if (ipid == 1002) // Expert's Knight Gown
		{
			if (skill <= 0) cost = 67.5;
			if (skill == 1) cost = 71.25;
			if (skill == 2) cost = 75.0;
			if (skill == 3) cost = 78.75;
			if (skill >= 4) cost = 82.5;
			if (player && player.CountInv("KnightGownIP2Buff")) cost *= 3;
			IPUseType = 4;
		}
		if (ipid == 1003) // Master's Knight Gown
		{
			if (skill <= 0) cost = 78.75;
			if (skill == 1) cost = 83.125;
			if (skill == 2) cost = 87.5;
			if (skill == 3) cost = 91.875;
			if (skill >= 4) cost = 96.25;
			if (player && player.CountInv("KnightGownIP3Buff")) cost *= 3;
			IPUseType = 4;
		}
		if (ipid == 1004) // Ultimate Knight Gown
		{
			if (skill <= 0) cost = 84.375;
			if (skill == 1) cost = 89.0625;
			if (skill == 2) cost = 93.75;
			if (skill == 3) cost = 98.4375;
			if (skill >= 4) cost = 103.125;
			if (player && player.CountInv("KnightGownIP4Buff")) cost *= 3;
			IPUseType = 4;
		}
		if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost: %.4f", cost);
		
		if (player) 
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem) 
			{
				if (MiscItem.TimeFreezeTimer && MiscItem.TimeFreezeIPBuff)
				{
					if (ipid == 8) cost *= 2.0;
										else cost *= 0.5;
				}

				if (cost > MiscItem.MaxItemPoints) cost = MiscItem.MaxItemPoints;
				if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [freeze timer]: %.4f", cost);
			}
		}
		
		// Double Sphere reduces IP Cost by 25%
		if (player && ipid != -1) 
		{
			if (player.CountInv("PowerDouble"))
			{
				cost *= 0.75;
				if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-DoubSphere]: %.4f", cost);
			}
			if (player.CountInv("PowerHalve"))
			{
				cost *= 1.334;
				if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-HalveDebuff]: %.4f", cost);
			}
		}
		
		// "Mystery Item" reduces IP Cost by 33.3%
		if (player && player.CountInv("MysteryItem") && ipid != -1) 
		{
			cost *= 0.667;
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-MI]: %.4f", cost);
		}
		if (player && player.CountInv("MysteryItem2") && ipid != -1) 
		{
			cost *= 0.667;
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-MI]: %.4f", cost);
		}
		
		if (player) 
		{
			double temp = 1.0;
			if (player.CountInv("ClassyRibbon")) temp -= 0.125;
			if (player.CountInv("ExpeditionHat")) temp -= 0.125;
			if (player.CountInv("MAManual")) temp -= 0.25;
			cost *= temp;
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-Rares]: %.4f", cost);
		}
		
		if (player && (player.CountInv("AngerLevelEvent") > 0 || player.CountInv("AngerLevelEventN")))
		{
			if (ipid != -1) cost *= (1.0 - (player.CountInv("AngerLevelEvent") * 0.001) - (player.CountInv("AngerLevelEventN") * 0.0001));
								 else cost *= (1.0 - (player.CountInv("AngerLevelEvent") * 0.0025) - (player.CountInv("AngerLevelEvent") * 0.00025));
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-anger-event]: %.4f", cost);
		}
		
		// Armor IPs Reduce Costs for Non-Armor IP Abilities
		if (ipid != -1)
		{
			if (!(ipid >= 1000 && ipid <= 1004))
			{
				if (player && player.CountInv("KnightGownIP1Buff")) cost *= 0.8;
				if (player && player.CountInv("KnightGownIP2Buff")) cost *= 0.6;
				if (player && player.CountInv("KnightGownIP3Buff")) cost *= 0.4;
				if (player && player.CountInv("KnightGownIP4Buff")) cost *= 0.2;
			}
			else
			{
				if (player)
				{
					if (!(player.CountInv("MysteryItem") || player.CountInv("MysteryItem2")))
					{
						if (player && player.CountInv("KnightGownIP1Buff")) cost *= 1.075;
						if (player && player.CountInv("KnightGownIP2Buff")) cost *= 1.15;
						if (player && player.CountInv("KnightGownIP3Buff")) cost *= 1.225;
						if (player && player.CountInv("KnightGownIP4Buff")) cost *= 1.30;
					}
				}
			}
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post-ArmorIP]: %.4f", cost);
		}
		
		if (player) 
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem)
			{
				if (ipid != -1 || !(ipid >= 1000 && ipid <= 1004))
				{
					if (ipid == 8)
					{
						if (MiscItem.IPMortalBlowReduceTimer)
						{
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 2) - 1)) cost *= 0.8334;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 2) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 3) - 1)) cost *= 0.75;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 3) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 4) - 1)) cost *= 0.666;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 4) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 5) - 1)) cost *= 0.583;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 5)) cost = 0.5;
						}
					}
					else
					{
						if (MiscItem.IPMortalBlowReduceTimer)
						{
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 2) - 1)) cost *= 0.666;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 2) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 3) - 1)) cost *= 0.5;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 3) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 4) - 1)) cost *= 0.333;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 4) && TruePlayerLevel <= ((exex_mortalblowipcostlvlrequirement * 5) - 1)) cost *= 0.166;
							if (TruePlayerLevel >= (exex_mortalblowipcostlvlrequirement * 5)) cost = 0;
						}
					}
				}
			}
			if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [post mortal-blow]: %.4f", cost);
		}

		if (ipid == -1)
		{
			let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
			if (MiscItem) 
			{
				double sts = 1.0;
				if (MiscItem.sttabs > 0) sts = 1.0 - (MiscItem.sttabs * 0.0333334);
				if (sts <= 0.20) sts = 0.20;
				cost *= sts;

				double costf = (1.0 - ((TruePlayerLevel - 1) * 0.001) - ((MiscItem.totalallkills) * (0.0025 + (MiscItem.totalcompleted) * 0.00005)));
				cost *= costf;
				if (dydudebug_ipdisplays) Console.Printf("\c[olive]costf: %.4f, totalallkills: %d, totalcompleted: %d", costf, MiscItem.totalallkills, MiscItem.totalcompleted);
			}
		}
		else
		{
			if (A_CheckDDGameB())
			{
				double DDCostReduce = 0.0;
				if (MiscItem.DD_RoseMother) DDCostReduce += 0.025;
				if (MiscItem.DD_GameMother) DDCostReduce += 0.025;
				if (MiscItem.DD_MossMother) DDCostReduce += 0.025;
				if (MiscItem.DD_GlobeMother) DDCostReduce += 0.025;
				if (MiscItem.DD_SphinxMother) DDCostReduce += 0.025;
				if (MiscItem.DD_HandMother1) DDCostReduce += 0.025;
				if (MiscItem.DD_HandMother2) DDCostReduce += 0.025;
				if (MiscItem.DD_TrueHandMother) DDCostReduce += 0.025;
				if (MiscItem.AFD_Krag) DDCostReduce += 0.033334;
				if (MiscItem.AFD_Quisling) DDCostReduce += 0.033334;
				if (MiscItem.AFD_Lauritz) DDCostReduce += 0.033334;
				if (MiscItem.AFD_Jorgensen1) DDCostReduce += 0.033334;
				if (MiscItem.AFD_Jorgensen2) DDCostReduce += 0.033334;
				if (MiscItem.AFD_JorgCannon) DDCostReduce += 0.033334;
				if (MiscItem.CoS_Fafnir) DDCostReduce += 0.033334;
				if (MiscItem.CoS_FractalHens) DDCostReduce += 0.033334;
				if (MiscItem.CoS_HandMothers) DDCostReduce += 0.033334;
				if (MiscItem.CoS_ForsakenJorg) DDCostReduce += 0.033334;
				if (MiscItem.CoS_EvilDinah) DDCostReduce += 0.033334;
				if (MiscItem.CoS_Tempest) DDCostReduce += 0.033334;
				if (skill <= 0) DDCostReduce *= 1.5;
				if (skill == 1) DDCostReduce *= 1.25;
				if (skill == 2) DDCostReduce *= 1.0;
				if (skill == 3) DDCostReduce *= 0.75;
				if (skill >= 4) DDCostReduce *= 0.5;
				DDCostReduce *= exex_nrpggeneraleffect;
				cost *= (1.0 - DDCostReduce);
				if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost: %.4f, DDCostReduce: %.4f", cost, DDCostReduce);
			}
			else
			{
				let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
				if (MiscItem) 
				{
					double sts = 1.0;
					if (MiscItem.sttabs > 0) sts = 1.0 - (MiscItem.sttabs * 0.083334);
					if (sts <= 0.50) sts = 0.50;
					cost *= sts;

					double costf = (1.0 - ((TruePlayerLevel - 1) * 0.0025) - ((MiscItem.totalallkills) * (0.000625 + (MiscItem.totalcompleted) * 0.0000125)));
					cost *= costf;
					if (dydudebug_ipdisplays) Console.Printf("\c[olive]costf: %.4f, totalallkills: %d, totalcompleted: %d", costf, MiscItem.totalallkills, MiscItem.totalcompleted);
				}
			}
		}
		
		// Options
		cost *= exex_ipcostall;
		if (IPUseType == 1) cost *= exex_ipcostweapon;
		if (IPUseType == 2) cost *= exex_ipcostweaponalt;
		if (IPUseType == 3) cost *= exex_ipcostweapontri;
		if (IPUseType == 4) cost *= exex_ipcostarmor;
		if (IPUseType == 5) cost *= exex_ipcostinventory;
		if (IPUseType == 6) cost *= exex_ipcostfcrown;
		
		// If Infinite IP Cheat is on, nullify any above cost calculations and set to 0. :V
		if (dydudebug_infiniteip) cost = 0.0;
		
		if (dydudebug_ipdisplays) Console.Printf("\c[olive]cost [%d]: %.4f, Skill: %d", ipid, cost, skill);
		return cost;
	}
	
	play void A_IPDinahVoiceSelect(int IPType = 0, int basechance = 3, int maxroll = 10)
	{
		actor player = players[0].mo;
		let MiscItem = PlayerStatItem(Player.FindInventory("PlayerStatItem"));
		int voiceroll = random(1,6);
		string voiceplay;
		if (player && player.GetClassName() == "DinahPlayer" && exex_dinahextravoices && !MiscItem.IPCallOutCooldown)
		{
			double maskpitch = 1.00;
			if (player.waterlevel >= 3 && MiscItem.CanTalkUnderwater >= 2) maskpitch *= 1.259921885;
			if (random(1,maxroll) <= basechance && (MiscItem && MiscItem.CanTalkUnderwater))
			{
				if (IPType == 0) // Default
				{
					voiceroll = random(1,7);
					if (voiceroll == 1) 
					{
						voiceplay = "dinah/ulikethis";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'YOU LIKE THIS!?'\c-");
					}
					if (voiceroll == 2) 
					{
						voiceplay = "dinah/howsthis";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'HOW'S... THIS!?'\c-");
					}
					if (voiceroll == 3) 
					{
						voiceplay = "dinah/playtimeisover";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'PLAYTIME IS OVER!!'\c-");
					}
					if (voiceroll == 4) 
					{
						voiceplay = "dinah/thiswillendit";
						Console.Printf("\c[gold]'This will end it!!'\c-");
					}
					if (voiceroll == 5) 
					{
						voiceplay = "dinah/thiswillhurt";
						Console.Printf("\c[gold]'This will hurt!!'\c-");
					}
					if (voiceroll == 6) 
					{
						voiceplay = "dinah/yourmine";
						Console.Printf("\c[gold]'You're Mine!!'\c-");
					}
					if (voiceroll == 7) 
					{
						voiceplay = "dinah/NoEscape";
						Console.Printf("\c[gold]'No escape!!'\c-");
					}
				}
				else
				if (IPType == 1) // Support Item Use
				{
					voiceroll = random(1,3);
					if (voiceroll == 1)
					{
						voiceplay = "dinah/playtimeisover";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'PLAYTIME IS OVER!!'\c-");
					}
					if (voiceroll == 2) 
					{
						voiceplay = "Dinah/marvelous";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'Marvellous!'\c-");
					}
					if (voiceroll == 3) 
					{
						voiceplay = "Dinah/AllowMe";
						if (exex_dinahextravoices) Console.Printf("\c[gold]'Allow Me!'\c-");
					}
				}
				player.A_StopSound(CHAN_VOICE);
				player.A_StartSound(voiceplay,CHAN_VOICE,CHANF_DEFAULT,1.0,ATTN_NORM,maskpitch);
				MiscItem.IPCallOutCooldown += (frandom(2.25,3.0) * TICRATE);
			}
		}
	}
	
	play void A_CheckIPModeOnUse()
	{
		actor player = players[0].mo;
		if (exex_ikaripointtechpresstype >= 2 && player && player.CountInv("IPUseMode")) player.A_SetInventory("IPUseMode",0);
	}
}

mixin class InvWeaponShare
{
	// Misc
	const BerserkRecoilMulti = 2.5;
	const minxymoveneg = -3.814697266;
	const minxymovepos = 3.814697266;
	const minzmoveneg = -1.907348633;
	const minzmovepos = 1.907348633;
	
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;
	
	//===========================================================================
	//
	// A_ThrowGrenadeAngle
	//
	// Throws a grenade (like Hexen's fighter flechette) with the added options to tweak
	// the randomized angle-range used, and if to use fixed/doubles or ints for the angles.
	//
	//===========================================================================
	action bool, Actor A_ThrowGrenadeAngle(class<Actor> missile, double zheight = 0, double zheightoffset = 35, double xyvel = 0, double zvel = 0, double angularspreadmin = -4.0, double angularspreadmax = 3.0, bool usefixedangles = false, bool useammo = true, bool checkspawn = true)
	{
		if (dydudebug_attackstuff) Console.Printf("zheight: %.4f, xyvel: %.4f, zvel: %.4f, angularspreadmin: %.4f, angularspreadmax: %.4f", zheight, xyvel, zvel, angularspreadmin, angularspreadmax);
		double anglemin = angularspreadmin;
		double anglemax = angularspreadmax;
		if (!usefixedangles)
		{
			anglemin = int(angularspreadmin); 
			anglemax = int(angularspreadmax);
		}
		else
		{
			anglemin = angularspreadmin; 
			anglemax = angularspreadmax;
		}
		if (dydudebug_attackstuff) Console.Printf("anglemin: %.4f, anglemax: %.4f", anglemin, anglemax);

		if (missile == NULL)
		{
			return false, null;
		}
		if (stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			let player = self.player;
			if (player == null) return false, null;
			let weapon = player.ReadyWeapon;
			// Used from a weapon, so use some ammo

			if (weapon == NULL || (useammo && !weapon.DepleteAmmo(weapon.bAltFire)))
			{
				return true, null;
			}
		}

		let bo = Spawn(missile, pos + (0, 0, (-Floorclip + GetBobOffset() + zheight + zheightoffset + (player? player.crouchoffset : 0.))), ALLOW_REPLACE);
		if (bo)
		{
			if (dydudebug_attackfuncinfo) Console.Printf("bo [spawned]");
			self.PlaySpawnSound(bo);
			if (xyvel != 0)
				bo.Speed = xyvel;
			if (usefixedangles) bo.Angle = Angle + (frandom[grenade](anglemin, anglemax) * (360./256.));
										 else bo.Angle = Angle + (random[grenade](anglemin, anglemax) * (360./256.));

			let pitch = -self.Pitch;
			let angle = bo.Angle;

			// There are two vectors we are concerned about here: xy and z. We rotate
			// them separately according to the shooter's pitch and then sum them to
			// get the final velocity vector to shoot with.

			double xy_xyscale = bo.Speed * cos(pitch);
			double xy_velz = bo.Speed * sin(pitch);
			double xy_velx = xy_xyscale * cos(angle);
			double xy_vely = xy_xyscale * sin(angle);

			pitch = self.Pitch;
			double z_xyscale = zvel * sin(pitch);
			double z_velz = zvel * cos(pitch);
			double z_velx = z_xyscale * cos(angle);
			double z_vely = z_xyscale * sin(angle);

			bo.Vel.X = xy_velx + z_velx + Vel.X / 2;
			bo.Vel.Y = xy_vely + z_vely + Vel.Y / 2;
			bo.Vel.Z = xy_velz + z_velz;

			bo.target = self;
			if (checkspawn) 
			{
				if (dydudebug_attackfuncinfo) Console.Printf("bo: checkspawn: %d", checkspawn);
				if (!bo.CheckMissileSpawn(radius))
				{
					if (dydudebug_attackfuncinfo) Console.Printf("bo: null");
					bo = null;
				}
			}
			return true, bo;
		} 
		else
		{
			return false, null;
		}
	}
}

/*
	Enum ESpawnItemExtendedFlags
	{
		SXF_ABSOLUTEPITCH = 1 << 29,
		SXF_ABSOLUTEROLL = 1 << 30,
		SXF_VELOCITYFROMPITCH = 1 << 31,
		SXF_OFFSETFROMPITCH = 1 << 32,
	};

	Bool, Actor A_SpawnItemExtended(Class<Actor> Actr, Double OffsetX = 0.0, Double OffsetY = 0.0, Double OffsetZ = 0.0, Double VelX = 0.0, Double VelY = 0.0, Double VelZ = 0.0, Double Angle = 0.0, Double Pitch = 0.0, Double Roll = 0.0, Int Flags = 0, Int Flags2 = 0, Int FailChance = 0, Int TID = 0)
	{
		Bool Result;
		Actor MapObject;
		Double CallerAngle;
		Double CallerPitch;
		Double CallerRoll;
		Double CallerPosZ;
		Double CallerVelZ;
		Vector3 Position;
		Double TSin;
		Double TCos;
		Double NewVelX;
	
		If (!Actr)
		{
			Return False, Null;
		}
	
		If (FailChance > 0 && Random[SpawnItemEx]() < FailChance)
		{
			Return True, Null;
		}
	
		If (DamageType == 'Massacre' && GetDefaultByType(Actr).bISMONSTER)
		{
			Return True, Null;
		}
	
		CallerAngle = Self.Angle;
		CallerPitch = Self.Pitch;
		CallerRoll = Self.Roll;
		CallerPosZ = Self.Pos.Z;
		CallerVelZ = Self.Vel.Z;
	
		If (Flags2 & SXF_OFFSETSFROMPITCH)
		{
			Vector3 BaseDirection;
			Double BaseAngle;
			Double BasePitch;
			Vector3 Right;
			Vector3 Up;
			Vector2 OffsetXZ;
			Vector3 Offset;
			
			BaseDirection = (Cos(CallerPitch) * Cos(CallerAngle),Cos(CallerPitch) * Sin(CallerAngle),-Sin(CallerPitch));
			Right = (Cos(CallerAngle - 90.0),Sin(CallerAngle - 90.0),0.0);
			Up = (Cos(CallerPitch - 90.0) * Cos(CallerAngle),Cos(CallerPitch - 90.0) * Sin(CallerAngle),-Sin(CallerPitch - 90.0));
			
			BaseDirection += Sin(Angle) * Right;
			BaseDirection += Sin(-Pitch) * Up;
			
			BaseAngle = VectorAngle(BaseDirection.X,BaseDirection.Y);
			BaseDirection.XY = RotateVector(BaseDirection.XY,-BaseAngle);
			BasePitch = -VectorAngle(BaseDirection.X,BaseDirection.Z);
			
			OffsetY *= -1;
			OffsetXZ = RotateVector((OffsetX,OffsetZ),-BasePitch);
			OffsetX = OffsetXZ.X;
			OffsetZ = OffsetXZ.Y;
			Offset = (OffsetX,OffsetY,OffsetZ);
			Offset.XY = RotateVector(Offset.XY,BaseAngle);
			
			If (Flags & SXF_ABSOLUTEPOSITION)
			{
				Position.XY = Vec2Offset(Offset.X,Offset.Y,False);
			}
			Else
			{
				Position.XY = (Self.Pos.X + Offset.X,Self.Pos.Y + Offset.Y);
			}
			
			Position.Z = CallerPosZ - FloorClip + GetBobOffset(0.0) + Offset.Z;
		}
		Else
		{
			If (!(Flags & SXF_ABSOLUTEANGLE))
			{
				Angle += CallerAngle;
			}
			
			TSin = Sin(Angle);
			TCos = Cos(Angle);
			
			If (Flags & SXF_ABSOLUTEPOSITION)
			{
				Position.XY = Vec2Offset(OffsetX,OffsetY,False);
			}
			Else
			{
				Position.XY = Vec2Offset(OffsetX * TCos + OffsetY * TSin,OffsetX * TSin - OffsetY * TCos,False);
			}
			
			Position.Z = CallerPosZ - FloorClip + GetBobOffset(0.0) + OffsetZ;
		}
	
		MapObject = Spawn(Actr,Position,ALLOW_REPLACE);
		Result = InitSpawnedItem(MapObject,Flags);
	
		If (Result)
		{
			If (Flags2 & SXF_OFFSETSFROMPITCH)
			{
				If (!(Flags & SXF_ABSOLUTEANGLE))
				{
						Angle += CallerAngle;
				}
			
				TSin = Sin(Angle);
				TCos = Cos(Angle);
			}
			
			If (!(Flags2 & SXF_ABSOLUTEPITCH))
			{
				Pitch = Clamp(Pitch + CallerPitch,-90.0,90.0);
			}
			
			If (!(Flags2 & SXF_ABSOLUTEROLL))
			{
				Roll += CallerRoll;
			}
			
			If (!(Flags & SXF_ABSOLUTEVELOCITY))
			{
				NewVelX = VelX * TCos + VelY * TSin;
				VelY = VelX * TSin - VelY * TCos;
				VelX = NewVelX;
			
				If (Flags2 & SXF_ADDZVELOCITY)
				{
							VelZ += CallerVelZ;
				}
			}
			
			MapObject.Angle = Angle;
			MapObject.Pitch = Pitch;
			MapObject.Roll = Roll;
			MapObject.Vel = (VelX,VelY,VelZ);
			
			If (Flags2 & SXF_VELOCITYFROMPITCH)
			{
				If (Flags2 & SXF_ADDZVELOCITY)
				{
						MapObject.Vel3DFromAngle(MapObject.Vel.XY.Length(),VectorAngle(VelX,VelY),MapObject.Pitch);
						MapObject.Vel.Z += VelZ;
				}
				Else
				{
							MapObject.Vel3DFromAngle(MapObject.Vel.Length(),VectorAngle(VelX,VelY),VectorAngle(MapObject.Vel.XY.Length(),VelZ) + Pitch);
				}
			}
			
			If (Flags & SXF_MULTIPLYSPEED)
			{
				MapObject.Vel *= MapObject.Speed;
			}
			
			If (Flags2 & SXF_PITCHFROMMOMENTUM)
			{
				MapObject.A_FaceMovementDirection(0.0,0.0,270.0,FMDF_NOANGLE,AAPTR_DEFAULT);
			}
			
			If (TID != 0)
			{
				MapObject.ChangeTID(TID);
			}
		}
	
		Return Result, MapObject;
	}
*/