mixin class DmgCalc
{
	action int A_GetPunchDamage(int altfire = 0, int shockwave = 0, bool istarget = false)
	{
		Weapon weapon;
		if (istarget && target) weapon = target.player.ReadyWeapon;
		else weapon = player.ReadyWeapon;

		string weaponname;
		weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		int damage;
		int previousdamage;
		int strengthcounter;
		String nm, nn, no, np;

		int Power;
		if (istarget && target) Power = target.player.mo.Stamina;
		else Power = player.mo.Stamina;
		if (Power) Power /= 10;
		if (Power > 10) Power = 10;

		// Character Check [base damage]
		If (weapon is "HandToHand")
		{
			if (altfire == 0)
			{
				damage = (random(9,15) + (Power * 0.9));
			}
			else
			if (altfire == 1)
			{
				damage = (random(59,101) + (Power * 6.663));
			}
			if (Power) damage *= frandom(1.00,(1.00 + (Power * frandompick(0.667,0.75,0.834))));
		}
		else
		{
			damage = random(9,15);
		}
		if (dydudebug_meleedmg) Console.Printf("BaseDmg: %d [%s, %s]", damage, weaponname, actorname);

		// Berserk Check
		previousdamage = damage;
		if (CountInv("PowerStrength", AAPTR_PLAYER1) || CountInv("PowerStrengthDD", AAPTR_PLAYER1)) damage = floor(damage * 10);
		if (dydudebug_meleedmg) Console.Printf("BerserkDmg: %d - (Previous Dmg: %d) [%s, %s]", damage, previousdamage, weaponname, actorname);

		double PerkFactor;
		double temp1, temp2;
		previousdamage = damage;
		if (shockwave)
		{
			if (altfire == 0) damage = floor(damage * (0.04166667 * randompick(1,2,2,2,2,2,3)));
			if (altfire == 1) damage = floor(damage * (0.05 * randompick(1,2,2,2,2,2,3)));
			if (dydudebug_meleedmg) Console.Printf("MeleeDmg [Shockwave]: (%s) %d - (Previous Dmg: %d)", weaponname, damage, previousdamage);
		}
		else
		{
			previousdamage = damage;
		}

		previousdamage = damage;
		If (weapon is "HandToHand")
		{
			if (altfire == 0) damage = damage;
		}
		if (dydudebug_meleedmg && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Punch]", weaponname, damage, previousdamage);
		if (dydudebug_meleedmg && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Uppercut]", weaponname, damage, previousdamage);

		if (istarget)
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %d\c- - \cx(Previous Dmg: %d) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Puff: %s) %d\c- - \cx(Previous Dmg: %d) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		else
		{
			if (dydudebug_meleedmg && altfire == 0) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %d\c- - \cx(Previous Dmg: %d) [Punch]\c-", weaponname, actorname, damage, previousdamage);
			if (dydudebug_meleedmg && altfire == 1) Console.Printf("\cyFinalMeleeDmg: (Weapon: %s - Source: %s) %d\c- - \cx(Previous Dmg: %d) [Uppercut]\c-", weaponname, actorname, damage, previousdamage);
		}
		
		return damage;
	}
}

mixin class CollisionChecker
{
	string infl;
	// Checks for certain projectiles from charmed/friendly allies to pass through other friendlies instead of colliding
	int A_CheckFriendCollisionProjTypeFriendlyDoom()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyDoom:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyHeretic()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHeretic:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyHexen()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyHexen:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendlyStrife()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyStrife:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	int A_CheckFriendCollisionProjTypeFriendlyOthers()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendlyOthers:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	int A_CheckFriendCollisionProjTypeFriendly1()
	{
		infl = GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypeFriendly1:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer(Actor type)
	{
		infl = type.GetClassName();
		
		int type;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}

	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckFriendCollisionProjTypePlayer2(Actor type)
	{
		infl = type.GetClassName();

		int type;
		if (
				// Circus 2 Stuff
				infl == "Sparkles" ||
				infl == "CrazyBits1" ||
				infl == "CrazyBits2" ||
				infl == "CrazyBits3" ||
				infl == "CrazyBits4" ||
				infl == "CrazyBits5" ||
				infl == "CrazyBits6" ||
				infl == "CrazyBits7" ||
				infl == "CrazyBits8" ||
				infl == "CrazyBits9" ||
				infl == "CrazyBits10" ||
				infl == "Popcorn_Shrap1" ||
				infl == "Popcorn_Shrap7" ||
				infl == "CrazyBalls" ||
				infl == "CrazyBall" ||
				infl == "CrazyBallDD"
			 ) type = 1;
		
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]CheckFriendCollisionProjTypePlayer2:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
	
	// Checks for certain projectiles from players to pass through friendlies instead of colliding
	int A_CheckCollisionProjShieldExemption(Actor type)
	{
		infl = type.GetClassName();

		int type;
		if (infl == "MalletShot" || 
				infl == "MalletShotBerserk" || 
				infl == "BlunderShot" || 
				infl == "EggShot" || 
				infl == "EggShotBerserk" || 
				infl == "EggGrenade" || 
				infl == "EggGrenadeBerserk" || 
				infl == "EggMini" || 
				infl == "EggMiniBerserk" || 
				infl == "ZapShot" || 
				infl == "MiniZapShot" || 
				infl == "JackShot" || 
				infl == "JackShotBerserk" || 
				infl == "RecordShot" || 
				infl == "VacShot" || 
				infl == "VacShot2" || 
				infl == "CherryBombShot" || 
				infl == "CherryBombShotBerserk" || 
				infl == "BRocketShot" || 
				infl == "BRocketBoom1" || 
				infl == "BRocketBoom2" || 
				infl == "Spinnershot" || 
				infl == "StreamerShot" || 
				infl == "StreamerTrail" || 
				infl == "PopperPuff1" || 
				infl == "PopperPuff2" || 
				infl == "SnakeGrenade" || 
				infl == "SnakeMiniGrenade" 
			 ) type = 1;
	
		if (dydudebug_generalcollisions) Console.Printf("\c[brick]A_CheckCollisionProjShieldExemption:\c- %s [type: %d] {gametic: %d}", infl, type, gametic);
		return type;
	}
}

mixin class MonsterTickCheck
{
	int hitsoundtimer;
	int hitweaksoundtimer;
	override void Tick()
	{
		super.Tick();
	}
}

mixin class MonsterCollider
{
	int targetdummyhitcooldown;
	Actor lastattacker;
	Actor lastattackeratk;
	Actor playeriskiller;

	// Resurrections
	override bool CanResurrect(Actor other, bool passive)
	{
		bool ResSucceed = true;
		if (!passive) // Monster is the one REVIVING...
		{
			if (other != self)
			{
				let Vile = Archvile(self);
				if (Vile) 
				{
					if (Vile.health > (Vile.SpawnHealth() >> 2)) //
					{
						ResSucceed = true;
						if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Vile's Health is High Enough to resurrect anything");
					}
					else
					{
						if (other.SpawnHealth() <= 150)
						{
							ResSucceed = true;
							if (dydudebug_ressurrectdisplays) Console.Printf("Succeeded: Resurrectee's max health is low enough");
						}
						else
						{
							ResSucceed = false;
							if (dydudebug_ressurrectdisplays) Console.Printf("Failed: Vile's Health Too Low");
						}
					}
				}
				if (exex_combatlog) Console.Printf("\c[red]*\c- \c[brick]%s\c- is resurrecting \c[purple]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
			}
			else
			{
				if (exex_combatlog) Console.Printf("\c[red]*\c- \c[brick]%s\c- is self resurrecting! [%d]", GetTag(), gametic);
			}
		}
		else // Monster is the one BEING REVIVED...
		{
			//if (exex_combatlog) Console.Printf("\c[red]*\c- \c[purple]%s\c- is being resurrected by \c[brick]%s\c-! [%d]", GetTag(), other.GetTag(), gametic);
		}
		return ResSucceed;
	}

	// Collisions
	override bool CanCollideWith(Actor other, bool passive)
	{
		ShieldPart shieldpiece;
		shieldpiece = ShieldPart(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[brick]Collision:\c- NotPassive - %s vs (%s) {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
			
			// Pass through certain shield parts, ones that would normally cause a monster to be bumped around by running into them
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - %s [ShieldPiece] vs (%s) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
				if (shieldpiece.GetClassName() == "CricketShieldPart" || shieldpiece.GetClassName() == "CricketShieldPartNoReflect")
				{
					if (dydudebug_generalcollisions) Console.Printf("\c[sapphire]Collision:  Passive - %s [CricketShieldPart] vs (%s) {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
					return true;
				}
				return false;
			}

			// Pass through players, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.GetSpecies() == "Players")
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [PlayerType] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}

			// Pass through other actors, if the calling monster is Friendly
			if (bFRIENDLY == 1 && other.bFRIENDLY == 1)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false; 
			}
		}
		else
		{
			if (dydudebug_generalcollisions) Console.Printf("\c[red]Collision:\c- Passive - (%s) vs %s {gametic: %d}", GetClassName(), other.GetClassName(), gametic);
			
			if (shieldpiece)
			{
				if (dydudebug_generalcollisions) Console.Printf("\c[lightblue]Collision:\c- NotPassive - %s [Friendly] vs (%s) [Friendly] = False/No Collision {gametic: %d}", other.GetClassName(), GetClassName(), gametic); 
				return false;
			}
			return true; 
		}

		// We don't really care about others making the check.
		return true;
	}
	
	// Damage Tracking
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (dydudebug_actordmgdisplays) Console.Printf("DamageMobj [Mixin]");
		int oldhealth = health;
		int initdmg = damage;
		if (dydudebug_actordmgdisplays) Console.Printf("initdmg: %d, oldhealth: %d", initdmg, oldhealth);
		string infl, sour, vict;
		vict = GetClassName();
		if (inflictor != null) lastattackeratk = inflictor;
		if (inflictor == null) infl = "NONE"; else infl = inflictor.GetClassName();
		if (source != null) lastattacker = source;
		if (source == null) sour = "NONE"; else sour = source.GetClassName();

		if (bDORMANT)
		{
			if (!(mod == "SilentMassacre" || mod == "Massacre" || mod == "InstantDeath")) return 0;
		}

		if (dydudebug_actordmgdisplays)
		{
			if (flags & DMG_NO_ARMOR) Console.Printf("    (\cyIgnoresArmor?: yes)");
			if (flags & DMG_INFLICTOR_IS_PUFF) Console.Printf("    (\cyInflictorIsPuff?: yes)");
			if (flags & DMG_THRUSTLESS) Console.Printf("    (\cyThrustless?: yes)");
			if (flags & DMG_FORCED) Console.Printf("    (\cyForcedDamage?: yes)");
			if (flags & DMG_NO_FACTOR) Console.Printf("    (\cyNoDmgFactor?: yes)");
			if (flags & DMG_PLAYERATTACK) Console.Printf("    (\cyPlayerAttack?: yes)");
			if (flags & DMG_FOILINVUL) Console.Printf("    (\cyFoilInvuln?: yes)");
			if (flags & DMG_FOILBUDDHA) Console.Printf("    (\cyFoilBuddha?: yes)");
			if (flags & DMG_NO_PROTECT) Console.Printf("    (\cyBypassPowerProtection?: yes)");
			if (flags & DMG_NO_ENHANCE) Console.Printf("    (\cyBypassPowerDamage?: yes)");
			if (flags & DMG_USEANGLE) Console.Printf("    (\cyUsesAngle?: yes)");
			if (flags & DMG_EXPLOSION) Console.Printf("    (\cyIsAoEBurst?: yes)");
		}

		bool wasblastedimpact = false;
		if (inflictor == null && source == null && mod == 'Melee') 
		{
			wasblastedimpact = true;
			if (bBLASTED && random(1,4) <= 3) bBLASTED = false;
			if (vel.x != 0.0) vel.x *= 0.1;
			if (vel.y != 0.0) vel.y *= 0.1;
			//if (wasblastedimpact) Console.Printf("    (\czwasblastedimpact?: %d", wasblastedimpact);
		}

		int playweaksound = 0;
		//*******************
		//* Weakness Sounds *
		//*******************
		int tempdmgval = 10000;
		double tempdmgfactor = damagefactor;
		damagefactor = 1.0;
		int moddedDMG = ApplyDamageFactor(mod, tempdmgval);
		damagefactor = tempdmgfactor;
		double outputdmgfactor = 1.0;
		outputdmgfactor *= moddedDMG;
		outputdmgfactor /= tempdmgval;
		if (vict != "PracticeTarget" || vict != "PracticeTarget2")
		{
			if (damage > 0 && !(flags & DMG_NO_FACTOR)) 
			{
				if (!(mod == '' || mod == 'Normal' || mod == 'Crush' || mod == 'Falling' || mod == 'Drowning'))
				{
					if (moddedDMG <= (tempdmgval * 0.25)) playweaksound = -3;
					if (moddedDMG >= (tempdmgval * 0.25) && moddedDMG <= (tempdmgval * 0.3999999)) playweaksound = -2;
					if (moddedDMG >= (tempdmgval * 0.4) && moddedDMG <= (tempdmgval * 0.6666667)) playweaksound = -1;
					if (moddedDMG >= (tempdmgval * 1.5) && moddedDMG <= (tempdmgval * 2.4999999)) playweaksound = 1;
					if (moddedDMG >= (tempdmgval * 2.5) && moddedDMG <= (tempdmgval * 3.9999999)) playweaksound = 2;
					if (moddedDMG >= (tempdmgval * 4.0)) playweaksound = 3;
					if (playweaksound > 0) A_SetInventory("TookWeaknessHit",playweaksound);
					else if (playweaksound < 0) A_SetInventory("TookResistanceHit",(playweaksound*-1));
					if (dydudebug_actordmgdisplays) Console.Printf("moddedDMG: %d (%.8f) (%s), playweaksound: %d, damagefactor: %.8f", moddedDMG, outputdmgfactor, mod, playweaksound, damagefactor);
				}
			}
			//Console.Printf("playweaksound: %d", playweaksound);
		}
		if (vict == "PracticeTarget" || vict == "PracticeTarget2") targetdummyhitcooldown = 175;

		//*******
		//*******
		//*******
		if (GetClassName() == "KilletanteSoloist" && IsFrozen())
		{
			damage *= frandompick(0.20,0.25);
			Console.Printf("%s resists your damage due to being frozen in time!", GetTag());
			A_StartSound("misc/ResistanceHit",21,CHANF_DEFAULT,frandom(1.25,1.334),ATTN_NORM,frandom(0.875,1.125));
		}

		// Checks for if you're fighting a Serpent Rider boss
		if (mod != 'Sigil' || mod != 'Massacre' || mod != 'Telefrag') // Make sure the Sigil can deal full damage and ignores this resistance entirely :V
		{
			let SerpentRider = Sorcerer2New(self);
			let SerpentRider2 = KoraxNew(self);
			int prevdamage = damage;
			//let SerpentRider3 = EidolonNew(self); // LUL I wish >.>;
			if (SerpentRider || SerpentRider2) // || SerpentRider3
			{
				// If D'Sparil is hit by Cherry Bombs or Korax is hit by Cricket Balls, IGNORE their increasing resistances entirely :V
				if ((SerpentRider && mod != 'CherryBomb') || (SerpentRider2 && mod != 'Cricket'))
				{
					let SerpRide = Actor(self);
					if (SerpRide)
					{
						if (health < (SpawnHealth() >> 1)) // <50%
						{
							if (health < (SpawnHealth() >> 4)) // <6.25%
							{
								if (health < (SpawnHealth() >> 9)) // <0.1953125%
								{
									damage *= 0.125;
								}
								else
								{
									damage *= 0.25;
								}
							}
							else
							{
								damage *= 0.50;
							}
						}
					}
				}
			}
		}

		// Special SuperVac Suck Attack Checks :V
		if (GetClassName() == "BossBrainNew" || GetClassName() == "Sorcerer2New" || GetClassName() == "KoraxNew")
		{
			if (mod == 'Suck' && damage > health)
			{
				if (damage > health) 
				{
					Console.Printf("\c[red]You cannot kill %s with the SuperVac's suck attack! You must use a different weapon to finish it!", GetTag());
					return 0; // The above bosses CANNOT die from the SuperVac
				}
			}
		}

		//************************************************************************
		let ret = super.DamageMobj(inflictor, source, damage, mod, flags, angle);
		//************************************************************************
		
		bool makesound;
		PlayerPawn playpawn;
		Actor othermon;
		string weakplayedsound = "";
		if (exex_hitweaksounds && playweaksound != 0) // && hitweaksoundtimer <= 0)
		{
			//Console.Printf("!$!@$");
			//hitweaksoundtimer += exex_hitweaksounddelay;

			if (playweaksound == -3) weakplayedsound = "Misc/ResistanceHitHigh";
			if (playweaksound == -2) weakplayedsound = "Misc/ResistanceHitMid";
			if (playweaksound == -1) weakplayedsound = "Misc/ResistanceHit";
			if (playweaksound == 1) weakplayedsound = "Misc/WeaknessHit";
			if (playweaksound == 2) weakplayedsound = "Misc/WeaknessHitMid";
			if (playweaksound == 3) weakplayedsound = "Misc/WeaknessHitHigh";

			if (initdmg > 0) makesound = true;
			if (oldhealth > 0 && oldhealth > health) makesound = true;
			if (makesound)
			{
				if (source) 
				{
					//Console.Printf("source: %s", source.GetClassName());
					playpawn = PlayerPawn(source);
					if (bFRIENDLY)
					{
						A_StartSound(weakplayedsound, 11, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 0.67);
					}
					else
					if (playpawn) 
					{
						//Console.Printf("playpawn: %s", playpawn.GetClassName());
						if (!bFRIENDLY) A_StartSound(weakplayedsound, 11, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 1.0);
					}
					else
					{
						othermon = Actor(source);
						if (othermon) 
						{
							//Console.Printf("othermon: %s", othermon.GetClassName());
							if (othermon.bFRIENDLY && !bFRIENDLY) A_StartSound(weakplayedsound, 11, CHANF_DEFAULT, (exex_hitweaksoundvol * frandom(0.75,1.25)), ATTN_NONE, 1.5);
						}
					}
				}
			}
		}
		
		return ret;
	}
	
	void A_EEHealThing(int healvalue = 0, int healtarget = 0, int silentheal = 0)
	{
		if (healvalue > 0)
		{
			health += healvalue;
			if (health > healtarget) health = healtarget;
		}
		if (silentheal)
		{
			//if (CountInv("DamageTracker")) A_SetInventory("SilentHeal",1);
		}
	}
}